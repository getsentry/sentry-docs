---
title: Silo de control
sidebar_order: 10
---

El Silo de control incluye funciones que nos permiten mantener la compatibilidad con versiones anteriores tanto para el uso de la API por parte de clientes como para las integraciones

<div id="api-gateway">
  # Puerta de enlace de API
</div>

Antes de nuestra oferta multirregi√≥n, todo el tr√°fico de API de los clientes se enviaba a [sentry.io](http://sentry.io). Debemos seguir admitiendo estas URL aunque algunos clientes residan en la regi√≥n `us` y otros en la regi√≥n `de`. La funcionalidad de la puerta de enlace de API del control silo inspeccionar√° las solicitudes y las reenviar√° a la regi√≥n adecuada seg√∫n los par√°metros de ruta de la solicitud. Las solicitudes pueden enrutarse por:

- Slug o id de la organizaci√≥n
- UUID de la instalaci√≥n de Sentry App
- Slug de Sentry App
- Host de DSN
- Una lista est√°tica de nombres de URL (lista de fijaci√≥n de regi√≥n)

<Alert>
üí° Las solicitudes dirigidas a sentry.io no cumplen los requisitos de residencia de datos. Los clientes deber√°n usar dominios regionales para evitar que las solicitudes vayan a EE. UU.
</Alert>

La puerta de enlace de API se implementa como un middleware que solo act√∫a cuando Sentry se ejecuta como Control Silo. Tras hacer coincidir las URL, el middleware verifica el modo de silo del endpoint coincidente. Si el endpoint coincidente es un endpoint de **regi√≥n**, la puerta de enlace de API intenta enrutar la solicitud a una regi√≥n bas√°ndose en algunas heur√≠sticas.

<div id="slug-id-and-uuid-based-routing">
  ### Enrutamiento basado en slug, id y UUID
</div>

Para las solicitudes que usan los par√°metros `organization_slug`, `organization_id_or_slug`, `sentry_app_slug` o `uuid`, la puerta de enlace de la API puede determinar la regi√≥n de la organizaci√≥n usando datos presentes en el silo de control. Una vez determinada la regi√≥n, las solicitudes se env√≠an mediante proxy de forma s√≠ncrona a la regi√≥n correspondiente.

<div id="dsn-host">
  ### Host DSN
</div>

La p√°gina heredada de inserci√≥n de errores requiere un manejo especializado y extraemos el destino del par√°metro de consulta `dsn`.

<div id="region-pin-list">
  ### Lista de pines de regi√≥n
</div>

Tenemos algunos endpoints de la API que no ofrecen pistas √∫tiles para enrutar solicitudes entre regiones. Cuando se hace una solicitud a una de estas rutas, asumimos que la intenci√≥n es enviarla a la regi√≥n `us`.

<div id="direct-location-header">
  ### Encabezado de ubicaci√≥n directa
</div>

Cuando una solicitud es procesada por el API Gateway, la respuesta enviada al cliente incluir√° el encabezado `X-Sentry-Proxy-Url`, que contiene la URL que los clientes deben usar para evitar la latencia adicional introducida por el API Gateway.

<div id="integration-credential-proxy">
  # Proxy de credenciales de integraci√≥n
</div>

Las integraciones pueden compartirse entre varias organizaciones. Por ejemplo, un √∫nico espacio de trabajo de MS Teams puede conectarse a varias organizaciones, y estas pueden estar en distintas regiones. Algunas de nuestras integraciones utilizan tokens de renovaci√≥n y emplean tokens de acceso de corta duraci√≥n. Para evitar condiciones de carrera al actualizar cuando los tokens se invalidan y deben renovarse, enviamos las solicitudes salientes al control silo, que act√∫a como proxy del servicio de integraci√≥n. Al canalizar todo el tr√°fico saliente de las integraciones que requieren tokens de renovaci√≥n a trav√©s del control silo, podemos coordinar con m√°s facilidad el reemplazo de tokens.

```mermaid
sequenceDiagram
  actor RegionSilo
  actor ControlSilo
  actor MsTeams

  RegionSilo ->> RegionSilo: enviar alerta de incidencia
  RegionSilo ->> ControlSilo : enviar alerta de incidencia a msteams
  ControlSilo ->> ControlSilo : cargar metadatos de integraci√≥n
  ControlSilo ->> ControlSilo : a√±adir credenciales de integraci√≥n a la solicitud
  ControlSilo ->> MsTeams : enviar solicitud de notificaci√≥n con credenciales
  MsTeams -->> ControlSilo : ¬°token caducado!
  ControlSilo ->> MsTeams : renovar token
  MsTeams -->> ControlSilo : respuesta
  ControlSilo ->> ControlSilo : actualizar token almacenado
  ControlSilo ->> MsTeams : enviar notificaci√≥n con nuevo token
  MsTeams -->> ControlSilo : respuesta
  ControlSilo -->> RegionSilo : respuesta
```

El proxy de integraci√≥n est√° implementado como una clase que las integraciones que requieren tokens de actualizaci√≥n pueden extender. Actualmente, las siguientes integraciones usan el proxy de credenciales de integraci√≥n:

* GitHub
* GitLab
* MSTeams
* Azure DevOps Services (Visual Studio Team Services)


<div id="integration-credential-proxy-headers">
  ### Encabezados del proxy de credenciales de integraci√≥n
</div>

El proxy de credenciales de integraci√≥n utiliza varios encabezados especializados para cumplir su funci√≥n:

- `X-Sentry-Subnet-Organization-Integration` El ID de la `OrganizationIntegration` desde la cual se deben agregar las credenciales.
- `X-Sentry-Subnet-Base-Url` define el host de la integraci√≥n y la URL base a la que se debe reenviar la solicitud.
- `X-Sentry-Subnet-Signature` Una firma de solicitud basada en HMAC que se verifica en el silo de control.
- `X-Sentry-Subnet-Path` La ruta que se debe usar en la solicitud reenviada.
- `X-Sentry-Subnet-Keyid` Para integraciones que usan un llavero, el ID de la clave a usar.

<div id="integration-webhook-forwarding">
  # Reenv√≠o de webhooks de integraci√≥n
</div>

Muchos de los servicios de terceros con los que nos integramos solo ofrecen un √∫nico endpoint al que env√≠an webhooks. Como todo nuestro tr√°fico actual de webhooks se env√≠a a `sentry.io`, necesitamos recibir all√≠ las solicitudes. Para los webhooks que deben manejarse en un silo regional, almacenamos los webhooks en Postgres y luego entregamos de forma as√≠ncrona los webhooks capturados a las regiones correspondientes.

Capturar y reproducir webhooks nos permite resolver algunos problemas de disponibilidad:

1. Muchas entregas de webhooks tienen tiempos de espera breves y requieren respuestas r√°pidas.
2. Las integraciones pueden ser compartidas por organizaciones en varias regiones y el reenv√≠o s√≠ncrono corre el riesgo de exceder los tiempos de espera.
3. El reenv√≠o s√≠ncrono de webhooks podr√≠a provocar el agotamiento de los workers de RPC.

<div id="webhook-storage">
  ### Almacenamiento de webhooks
</div>

Las cargas √∫tiles de los webhooks se almacenan en Postgres. Estas cargas se organizan en ‚Äúbuzones‚Äù y los mensajes dentro de un buz√≥n se entregan en el orden en que se reciben. Por lo general, cada buz√≥n corresponde a una sola integraci√≥n, pero para clientes con integraciones de alto volumen dividimos los mensajes en particiones m√°s peque√±as para aumentar el rendimiento de entrega.

El modelo de almacenamiento de los webhooks es similar al de las outboxes, ya que originalmente se almacenaban dentro de ellas. Sin embargo, fue necesario separarlos en un almacenamiento independiente, porque los l√≠mites transaccionales que requieren las outboxes no son compatibles con las solicitudes de mayor duraci√≥n que conlleva la entrega de webhooks.

```sql
create table hybridcloud_webhookpayload (
  id bigserial primary key,

  -- mailbox_name contendr√≠a valores como 'jira:12364'
  mailbox_name char,
  region_name char,
  schedule_for datetime,
  attempts int default 0,

  -- atributos de la carga √∫til
  request_method char,
  request_path char,
  request_headers text,
  request_body text,

  date_added datetime,
  index(mailbox_name),
  index(schedule_for),
)
```


<div id="high-volume-integration-mailboxes">
  ### Buzones de alto volumen para integraciones
</div>

Para los proveedores de integraci√≥n con m√∫ltiples clientes de alto volumen, dividimos los mensajes en buzones m√°s espec√≠ficos. La estrategia de particionado var√≠a seg√∫n la integraci√≥n, pero el objetivo es dividir los mensajes por recursos remotos de modo que todas las operaciones sobre un mismo recurso vayan al mismo buz√≥n. Algunos ejemplos de buenas claves de particionado son los project IDs de GitLab o los issue IDs de Jira.

<div id="webhook-scheduling">
  ### Programaci√≥n de webhooks
</div>

Con este modelo de almacenamiento, usamos un par de consultas en una tarea de Celery que se ejecuta cada 10 segundos para encontrar el pr√≥ximo webhook en cada buz√≥n.

```sql
-- Obtener el 'primer' mensaje de cada buz√≥n
select min(id), mailbox_name
from sentry_webhookpayload
group by mailbox_name

-- Obtener los buzones con mensajes listos para entregar
select * from sentry_webhookpayload
where id in (...) and schedule_for < current_timestamp
```

Para cada buz√≥n con mensajes no entregados, seleccionamos un lote de mensajes y actualizamos su pr√≥xima hora de programaci√≥n para dentro de unos minutos. Esto ayuda a evitar que la siguiente tarea de programaci√≥n intente volver a entregar los mismos mensajes.

```mermaid
sequenceDiagram
  participant Control Silo

  Control Silo ->> Control Silo : buscar buzones con mensajes
  Control Silo ->> Control Silo : filtrar buzones con entrega programada
  Control Silo ->> Control Silo : actualizar la hora de la pr√≥xima entrega para el siguiente bloque
  Control Silo ->> Control Silo : iniciar una tarea para vaciar un buz√≥n
```


<div id="webhook-delivery">
  ### Entrega de webhooks
</div>

Los webhooks programados se entregan mediante tareas de Celery. Las tareas de entrega intentan reenviar las solicitudes al silo de la regi√≥n correspondiente. Si la entrega tiene √©xito, el registro del payload se elimina de Postgres. Si la solicitud falla y `attempts` es menor que el n√∫mero m√°ximo de intentos (10), el mensaje se deja como est√°; si `attempts` es igual o superior al m√°ximo, se emite un mensaje de log y se descarta el webhook.

Vaciar un buz√≥n consiste en enviar tantos mensajes de un buz√≥n dado como sea posible. Si se produce un error de red, el elemento que est√° al frente de la cola se reprogramar√° y se incrementar√° su contador de intentos.

```mermaid
sequenceDiagram
  participant Silo de Control
  participant Silo de Regi√≥n

  Silo de Control ->> Silo de Control : Obtener el bloque principal del buz√≥n
  loop para cada mensaje
    Silo de Control ->> Silo de Control : si el hook supera el m√°ximo de intentos, eliminar
    Silo de Control ->> Silo de Regi√≥n : Entregar hook
    alt √©xito
      Silo de Regi√≥n -->> Silo de Control : 200-40x
      Silo de Control ->> Silo de Control : eliminar hook
    else error
      Silo de Regi√≥n -->> Silo de Control : 50x
      Silo de Control ->> Silo de Control : incrementar el intento y reprogramar
    end
  end
```

Cabe destacar que la mayor√≠a de los errores 40x se consideran entregas ‚Äúcorrectas‚Äù. Esto se debe a que volver a intentar la entrega de un webhook que inicialmente arroj√≥ una respuesta 40x generalmente no dar√° como resultado un 200.

---
title: Proxy inverso autoalojado
sidebar_title: Proxy inverso
sidebar_order: 80
---

<Alert title="Importante" level="warning">
    Esta documentación fue aportada por la comunidad. Sentry no ofrece soporte oficial para configuraciones autoalojadas más allá de la instalación predeterminada.
</Alert>

Añadir un proxy inverso delante de tu implementación de Sentry es muy recomendable por una razón importante: puedes afinar cada configuración para adaptarla a tu entorno actual. Un proxy inverso dedicado que haga la terminación de SSL/TLS y también reenvíe la dirección IP del cliente dentro de la red interna de Docker Compose (ya que esto es [casi imposible de lograr de otra manera](https://github.com/getsentry/self-hosted/issues/554)) te brindará la mejor experiencia con Sentry.

Una vez que hayas configurado un proxy inverso para tu instancia de Sentry, debes modificar `system.url-prefix` en el archivo `config.yml` para que coincida con tu nueva URL y protocolo. También debes actualizar la sección de SSL/TLS en el script `sentry/sentry.conf.py`; de lo contrario, podrías encontrarte con errores relacionados con CSRF al realizar ciertas acciones, como configurar integraciones.

Ten en cuenta que toda esta configuración usa nodos únicos para todos los servicios, incluido Kafka. Para cargas más grandes, necesitarás una máquina potente con mucha RAM y almacenamiento en disco. Para escalar aún más, probablemente utilices clústeres con una herramienta más compleja, como Kubernetes. Debido a la naturaleza muy personalizada de las instalaciones autoalojadas, no ofrecemos recomendaciones ni orientación sobre cómo escalar. Hacemos lo que nos funciona para nuestros miles de clientes en [sentry.io](https://sentry.io/) y nos encantaría recibirte cuando sientas que el mantenimiento de tu instalación local se convierte en una carga en lugar de una satisfacción.

<div id="enabling-https">
  ## Habilitar HTTPS
</div>

Recomendamos realizar la terminación de TLS en tu propio balanceador de carga o proxy dedicado. Aunque puedes configurarla en el archivo `nginx.conf` proporcionado por la instalación autohospedada, no es recomendable, ya que las versiones autohospedadas más recientes podrían modificar algunas configuraciones del archivo. Algunos ejemplos están disponibles en la sección [Ejemplos de proxy inverso](#reverse-proxy-examples).

<div id="expose-only-ingest-endpoint-publicly">
  ## Exponer públicamente solo el endpoint de ingesta
</div>

Algunos despliegues autogestionados requieren que el panel sea accesible únicamente a través de la red interna. Pero también necesitan ofrecer un endpoint público de ingesta de Sentry para dispositivos cliente como apps móviles y de escritorio. Puedes exponer públicamente algunos de estos endpoints:

- `/api/[0-9]+/envelope/` - Endpoint principal para enviar eventos desde el SDK
- `/api/[0-9]+/minidump/` - Endpoint para enviar minidumps desde SDKs nativos
- `/api/[0-9]+/security/` - Endpoint para enviar datos relacionados con la seguridad, como errores de CSP
- `/api/[0-9]+/store/` - Endpoint antiguo para enviar eventos desde el SDK; está en desuso.
- `/api/[0-9]+/unreal/` - Endpoint para enviar informes de fallos desde el SDK de Unreal Engine

`[0-9]+` es una cadena de expresión regular que se obtiene del DSN del proyecto.

<div id="rate-limiting">
  ## Limitación de tasas
</div>

De forma predeterminada, Sentry no gestiona la limitación de tasas para ninguna solicitud entrante. En la versión alojada de Sentry (SaaS) incluye una función llamada [spike protection](https://docs.sentry.io/product/accounts/quotas/spike-protection/) que puede protegerte frente a avalanchas de eventos. El código de ese módulo no está disponible en el repositorio público de [sentry](https://github.com/getsentry/sentry); en su lugar, se encuentra en el repositorio privado de getsentry.

Para implementaciones autoalojadas, se recomienda contar con un limitador de tasas en el balanceador de carga dedicado para evitar estas situaciones. Es aún más recomendable si expones públicamente tu instancia de Sentry en internet.

<div id="health-checks">
  ## Comprobaciones de estado
</div>

El endpoint para comprobaciones de estado está disponible en `/_health/` mediante HTTP. Devuelve 200 si Sentry está en funcionamiento o 500 con la lista de problemas.

<div id="reverse-proxy-examples">
  ## Ejemplos de proxy inverso
</div>

<div id="nginx">
  ### NGINX
</div>

Recomendamos instalar NGINX, ya que es lo que usamos en [sentry.io](https://sentry.io/).

```nginx
error_log /var/log/nginx/error.log warn;

# generated 2024-04-29, Mozilla Guideline v5.7, nginx 1.24.0, OpenSSL 3.0.13, modern configuration, no HSTS, no OCSP
# https://ssl-config.mozilla.org/#server=nginx&version=1.24.0&config=modern&openssl=3.0.13&hsts=false&ocsp=false&guideline=5.7
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;

    ssl_certificate /etc/letsencrypt/live/sentry.yourcompany.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/sentry.yourcompany.com/privkey.pem;
    ssl_session_timeout 1d;
    ssl_session_cache shared:MozSSL:10m;  # aproximadamente 40000 sesiones
    ssl_session_tickets off;

    ssl_dhparam /etc/letsencrypt/ffdhe2048.txt;

    # configuración moderna
    ssl_protocols TLSv1.3;
    ssl_prefer_server_ciphers off;

    proxy_buffering on;
    proxy_buffer_size    128k;
    proxy_buffers        4 256k;

    # Maneja encabezados relacionados con CORS para los endpoints de ingesta.
    # También puedes exponer únicamente los endpoints de ingesta
    # eliminando la otra directiva `location`.
    #
    # Se recomienda implementar un limitador de velocidad en los endpoints de ingesta.
    location ~ ^/api/[0-9]+/(envelope|minidump|security|store|unreal)/ {
        add_header Access-Control-Allow-Origin * always;
        add_header Access-Control-Allow-Credentials false always;
        add_header Access-Control-Allow-Methods GET,POST,PUT always;
        add_header Access-Control-Allow-Headers sentry-trace,baggage always;
        add_header Access-Control-Expose-Headers sentry-trace,headers always;
        include proxy_params;
        proxy_pass http://your-sentry-ip:9000;
    }

    location / {
        include proxy_params;
        proxy_pass http://your-sentry-ip:9000;
    }
}

server {
    server_name sentry.yourcompany.com;
    listen 80;
    listen [::]:80;

    root /var/www/html;
    # Permite a certbot realizar desafíos http-01
    location /.well-known/ {
        try_files $uri =404;
    }
    # de lo contrario, redirige a HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
}
```

Para usar NGINX con un servidor ACME como Let&#39;s Encrypt, consulta esta [entrada del blog de NGINX](https://www.nginx.com/blog/using-free-ssltls-certificates-from-lets-encrypt-with-nginx/).

También se recomienda afinar la configuración de NGINX para obtener mejoras de rendimiento. Puedes consultar estas entradas del blog de NGINX:

* [Ajuste de NGINX para mejorar el rendimiento - NGINX](https://www.nginx.com/blog/tuning-nginx/)
* [Optimización del rendimiento: consejos y trucos - NGINX](https://www.nginx.com/blog/performance-tuning-tips-tricks/)


<div id="caddy">
  ### Caddy
</div>

[Caddy](https://caddyserver.com/) es una alternativa a NGINX que gestiona automáticamente los certificados TLS mediante ACME. Después de [instalar Caddy](https://caddyserver.com/docs/install), modifica el archivo de configuración de Caddy ubicado en `/etc/caddy/Caddyfile`.

```caddyfile
sentry.yourcompany.com {
    # Maneja los encabezados relacionados con CORS para los endpoints de ingesta.
    # También puedes exponer únicamente los endpoints de ingesta
    # eliminando la otra directiva `handle`.
    #
    # Se recomienda implementar un limitador de velocidad en los endpoints de ingesta.
    @ingest_endpoint path_regexp ^/api/[0-9]+/(envelope|minidump|security|store|unreal)/

    handle @ingest_endpoint {
        header {
            Access-Control-Allow-Origin *
            Access-Control-Allow-Credentials false
            Access-Control-Allow-Methods GET,POST,PUT
            Access-Control-Allow-Headers sentry-trace,baggage
            Access-Control-Expose-Headers sentry-trace,headers
        }

        reverse_proxy your-sentry-ip:9000 {
            health_uri /_health/
            health_status 2xx
            header_up Host {upstream_hostport}
        }
    }

    handle {
        reverse_proxy your-sentry-ip:9000 {
            health_uri /_health/
            health_status 2xx
            header_up Host {upstream_hostport}
        }
    }

    # Por defecto, el certificado TLS se obtiene de Let's Encrypt
    tls name@yourcompany.com

    # Si tienes un certificado autofirmado
    # tls /path/to/server-certificate.crt /path/to/server-certificate.key

    header {
        # Eliminar el encabezado "Server"
        -Server
    }

    # Para habilitar el limitador de velocidad, instala el módulo adicional desde
    # https://github.com/mholt/caddy-ratelimit
    # rate_limit {
    #     zone sentry {
    #         key {remote_host}
    #         window 1s
    #         events 100
    #     }
    # }
}
```

Para obtener documentación detallada sobre la configuración de Caddyfile, consulta la [documentación de Caddy](https://caddyserver.com/docs/caddyfile).


<div id="traefik">
  ### Traefik
</div>

[Traefik](https://doc.traefik.io/traefik/) es otro proxy inverso que ofrece muchos complementos e integraciones listas para usar. También gestiona automáticamente los certificados TLS mediante ACME. Después de [instalar Traefik](https://doc.traefik.io/traefik/getting-started/install-traefik/), añade una configuración a Traefik como se muestra a continuación (este ejemplo usa el proveedor de archivos YAML; conviértelo al proveedor de configuración que prefieras según sea necesario).

La siguiente configuración está pensada para Traefik v3 con un proveedor de archivos.

```yaml
http:
  routers:
    # Maneja los encabezados relacionados con CORS para los endpoints de ingesta.
    # También puedes exponer solo los endpoints de ingesta
    # eliminando la otra directiva `handle`.
    #
    # Se recomienda colocar un limitador de velocidad en los endpoints de ingesta.
    sentry-ingest:
      entryPoints:
        - web       # Asumiendo que este es tu entrypoint HTTP
        - websecure # Asumiendo que este es tu entrypoint HTTPS
      service: sentry@file
      rule: "Host(`sentry.yourcompany.com`) && PathRegexp(`^/api/[0-9]+/(envelope|minidump|security|store|unreal)`)"
      tls:
        certResolver: letsencrypt # Asumiendo que tienes un resolvedor de certificados TLS llamado "letsencrypt"
      middlewares:
        - https_redirect@file
        - cors_headers@file # Para manejar clientes de navegador
        - rate_limiter@file
    sentry:
      entryPoints:
        - web       # Asumiendo que este es tu entrypoint HTTP
        - websecure # Asumiendo que este es tu entrypoint HTTPS
      service: sentry@file
      rule: "Host(`sentry.yourcompany.com`)"
      tls:
        certResolver: letsencrypt # Asumiendo que tienes un resolvedor de certificados TLS llamado "letsencrypt"
      # Habilita middleware según sea necesario
      middlewares:
        - https_redirect@file

  services:
    sentry:
      loadBalancer:
        servers:
          - url: "http://your-sentry-ip:9000"
        healthCheck:
          scheme: http
          path: /_health/
          interval: 30s
          timeout: 10s
        passHostHeader: true

  middlewares:
    https_redirect:
      redirectScheme:
        scheme: "https"
        port: "443"
        permanent: true
    cors_headers:
      headers:
        customResponseHeaders:
          addVaryHeader: true
          # Si quieres establecer esto en true, ajusta "accessControlAllowOriginList" a un dominio válido y elimina el asterisco comodín
          accessControlAllowCredentials: false
          accessControlAllowOriginList:
            - "*"
          accessControlAllowHeaders:
            - "sentry-trace"
            - "baggage"
          accessControlAllowMethods:
            - GET
            - POST
            - PUT
          accessControlExposeHeaders:
            - "sentry-trace"
            - "baggage"
    rate_limiter:
      rateLimit:
        average: 100
        period: 1s
        burst: 150
```


<div id="haproxy">
  ### HAProxy
</div>

[HAProxy](https://www.haproxy.org/) es un proxy inverso de alto rendimiento. Es el proxy inverso recomendado si has experimentado fallos de red con otros proxies inversos debido a su rendimiento. HAProxy requiere un módulo externo para gestionar automáticamente los certificados TLS.

Para instalar HAProxy, se recomienda obtenerlo desde el gestor de paquetes de tu distribución (apt o yum). Consulta [sus repositorios de distribución oficiales](https://github.com/haproxy/wiki/wiki/Packages#official-distribution-repositories). Luego podrás configurar el archivo de configuración de HAProxy, que debería estar en `/etc/haproxy/haproxy.cfg`.

```haproxy
global
	# Tu configuración global (puede variar según la versión y distribución de Linux)

defaults
    mode	http
    log     global
    option	httplog
    option	dontlognull
    option  forwardfor
    option  http-server-close
    option  http-keep-alive
    timeout connect 10s         # Tiempo de espera de conexión de 10s
    timeout client  30s         # Tiempo de espera del cliente de 30s
    timeout server  30s         # Tiempo de espera del servidor de 30s
    timeout http-keep-alive 2m  # Mantener conexión HTTP activa por 2 minutos
    # El resto de tu configuración de defaults

frontend http_bind
    bind *:80 name http_port
    mode http

    acl sentry_domain hdr(host) -i sentry.yourcompany.com

    # Redirección a HTTPS
    http-request redirect scheme https code 301 if sentry_domain !{ ssl_fc }

    use_backend sentry


frontend https_bind
    bind *:443 ssl crt /etc/haproxy/certs/ name https_port
    mode http

    acl sentry_domain   hdr(host) -i sentry.yourcompany.com
    acl ingest_endpoint path_reg -i /api/[0-9]+/(envelope|minidump|security|store|unreal)/

    # Maneja encabezados relacionados con CORS para los endpoints de ingesta.
    # También puedes exponer únicamente los endpoints de ingesta
    # eliminando la otra directiva `handle`.
    #
    # Se recomienda implementar un limitador de tasa en los endpoints de ingesta.
    use_backend sentry_ingest if sentry_domain ingest_endpoint

    use_backend sentry if sentry_domain

backend sentry_ingest
    mode http
    option httpchk
    server server1 your-sentry-ip:9000 check
    http-response set-header Access-Control-Allow-Origin *
    http-response set-header Access-Control-Allow-Credentials false
    http-response set-header Access-Control-Allow-Methods GET,POST,PUT
    http-response set-header Access-Control-Allow-Headers sentry-trace,baggage
    http-response set-header Access-Control-Expose-Headers sentry-trace,headers

backend sentry
    mode http
    option httpchk
    server server1 your-sentry-ip:9000 check
```

Para usar HAProxy con un servidor ACME como Let&#39;s Encrypt, consulta esta [publicación del blog de HAProxy](https://www.haproxy.com/blog/haproxy-and-let-s-encrypt).

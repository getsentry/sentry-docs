---
title: Publicación de una API
sidebar_order: 4
---

<div id="introduction">
  ## Introducción
</div>

En este documento explicamos cuándo y cómo publicar la documentación de la API en la documentación pública de Sentry.

<div id="api-versioning">
  ## Versionado de la API
</div>

Actualmente, la API de Sentry está en **`v0`** y se considera en fase de borrador. Si bien no esperamos grandes cambios en nuestros endpoints públicos, ten en cuenta que nuestra API aún está en desarrollo.

<div id="public-apis">
  ## APIs públicas
</div>

Una API pública es una API estable y bien documentada en [https://docs.sentry.io/api/](https://docs.sentry.io/api/).
Cuando haces público un endpoint, te comprometes a devolver siempre al menos el conjunto de
atributos definidos cuando se invoca ese endpoint. Por lo tanto, los atributos **no se pueden eliminar**
de un endpoint una vez que son públicos. Además, el tipo del atributo **no se puede cambiar** una vez
que el atributo es público. La razón por la que el atributo y su tipo no se pueden cambiar es que tanto
los clientes externos como los administrados dependen de que ese endpoint devuelva el atributo público.

Sí, **puedes** añadir atributos a un endpoint público.

<div id="when-to-make-an-api-public">
  ## ¿Cuándo hacer pública una API?
</div>

¿Debería publicar mi API? En la mayoría de los casos, la respuesta es **sí**. Como empresa orientada a desarrolladores, es fundamental
poner a disposición de los desarrolladores las funcionalidades de Sentry para que las usen en sus distintas automatizaciones. No intentes predecir si
una automatización encontrará útil la API, porque no podemos anticipar todas las automatizaciones que nuestros clientes podrían querer
crear. Dicho esto, hay 3 excepciones en las que no publicamos APIs:

1. **APIs experimentales:** APIs que están en desarrollo o sujetas a iteraciones frecuentes,
   lo que puede ocasionar cambios incompatibles. Se espera que, pasado un tiempo, se publiquen o se eliminen.
2. **APIs privadas:** APIs que controlan funciones de la interfaz de Sentry, como la visibilidad de un Button.
3. **APIs en getsentry:** Si eres ingeniero/a de Sentry y creas APIs en el repositorio de getsentry, no
   se publicarán. Este es el comportamiento esperado para todas las APIs de getsentry, pero si crees que hay un caso
   que debería publicarse, avisa a [owners-api](https://github.com/orgs/getsentry/teams/owners-api)
   y podemos ayudarte con ello.

<Alert title="Nota">
  Ten siempre en cuenta que tus APIs pueden seguir utilizándose incluso si son `private`. Todas las APIs
  en el repositorio de Sentry son accesibles debido a nuestra naturaleza de código abierto.
</Alert>

<div id="before-publishing">
  ### Antes de publicar
</div>

Recuerda: hacer pública una API significa que solo puedes añadir; no puedes realizar *ningún* cambio que rompa compatibilidad.

Como guía, considera estas preguntas:

1. ¿La funcionalidad para la que estás creando el endpoint público es estable?
2. ¿Cambiará sustancialmente la API en el futuro?

Si tus respuestas son «sí» y «no», estás listo: haz público el endpoint. Dirígete a la
[lista de verificación de la API pública](/es/backend/api/checklist/) y asegúrate de que tu endpoint cumpla con la lista.

<div id="publishing-an-api">
  ## Publicar una API
</div>

Usamos [OpenAPI Spec 3](https://swagger.io/docs/specification/about/) y la
biblioteca [drf-spectacular](https://drf-spectacular.readthedocs.io/en/latest/readme.html) para documentar
nuestras API.

**La documentación de la API incluye**:

1. Propietario
2. Estado de publicación
3. Pestaña de la barra lateral
4. Descripción del endpoint
5. Decorador del método
   * Título
   * Parámetros de ruta y de consulta
   * Parámetros del cuerpo
   * Respuestas satisfactorias
   * Respuestas de error
   * Ejemplo de cuerpo de respuesta

Utilizamos el decorador
[`extend_schema`](https://drf-spectacular.readthedocs.io/en/latest/drf_spectacular.html#drf_spectacular.utils.extend_schema)
de drf-spectacular para elaborar la documentación. Las secciones a continuación describen cada paso para usar este decorador.

<div id="1-owner">
  ### 1. Propietario
</div>

Especifica un propietario para el endpoint. Este sería el equipo de Sentry responsable de mantener
y hacerse cargo del endpoint. Puedes ver la lista completa de equipos
[aquí](https://github.com/getsentry/sentry/blob/master/src/sentry/api/api_owners.py).

```python
class OrganizationTeamsEndpoint(...):
    owner = ApiOwner.ENTERPRISE
```

<div id="2-publish-status">
  ### 2. Estado de publicación
</div>

Haz públicos los métodos del endpoint configurando su publish&#95;status en `PUBLIC`.

```python
class OrganizationTeamsEndpoint(...):
    owner = ApiOwner.ENTERPRISE
    publish_status = {
        'GET': ApiPublishStatus.PUBLIC,
        'POST': ApiPublishStatus.PUBLIC,
        'PUT': ApiPublishStatus.EXPERIMENTAL,
    }
```

<div id="3-sidebar-tab">
  ### 3. Pestaña de la barra lateral
</div>

Especifica la pestaña de la barra lateral del endpoint usando el decorador `extend_schema` en
la clase del endpoint. Puedes ver la lista actual de etiquetas o agregar nuevas
[aquí](https://github.com/getsentry/sentry/blob/master/src/sentry/apidocs/build.py). En el ejemplo
a continuación, el [endpoint](https://docs.sentry.io/api/teams/create-a-new-team/) está etiquetado en la pestaña de la barra lateral `Teams`.

```python
from drf_spectacular.utils import extend_schema

@extend_schema(tags=["Teams"])
class OrganizationTeamsEndpoint(...):
    owner = ApiOwner.ENTERPRISE
    publish_status = {
        'GET': ApiPublishStatus.PUBLIC,
        'POST': ApiPublishStatus.PUBLIC,
        'PUT': ApiPublishStatus.EXPERIMENTAL,
    }
```

<div id="4-endpoint-description">
  ### 4. Descripción del endpoint
</div>

Especifica la descripción del endpoint en la documentación usando su docstring.
Incluye una descripción para todos los recursos cuando no sea evidente de inmediato.
Por ejemplo, `team` y `organization` no requieren descripción, pero otros términos más ambiguos como
`external-issue` o `integration` sí necesitan una descripción.

```python
def post(self, request, organization, **kwargs):
    """
    Crea un nuevo equipo vinculado a una organización.
    """
```

<div id="5-method-decorator">
  ### 5. Decorador de método
</div>

Utilizamos otro decorador `@extend_schema` en el método del endpoint para elaborar la mayor parte de la documentación. El siguiente código muestra un ejemplo de una API POST completamente documentada.

```python
@extend_schema(tags=["Teams"])
class OrganizationTeamsEndpoint(...):
    owner = ApiOwner.ENTERPRISE
    publish_status = {
        'GET': ApiPublishStatus.PUBLIC,
        'POST': ApiPublishStatus.PUBLIC,
        'PUT': ApiPublishStatus.EXPERIMENTAL,
    }

    @extend_schema(
        operation_id="Crear un nuevo equipo",
        parameters=[GlobalParams.ORG_ID_OR_SLUG],
        request=TeamPostSerializer,
        responses={
            201: TeamSerializer,
            400: RESPONSE_BAD_REQUEST,
            403: RESPONSE_FORBIDDEN,
            404: OpenApiResponse(description="Ya existe un equipo con este slug."),
        },
        examples=TeamExamples.CREATE_TEAM,
    )
    def post(self, request, organization, **kwargs):
        """
        Crear un nuevo equipo vinculado a una organización.
        """
```

A continuación se describe cada argumento del decorador:

* **operation&#95;id:** se mostrará como el título de la página del endpoint en la documentación.

* **parámetros:** es una lista de parámetros de ruta y de consulta.
  * Puedes encontrar los parámetros existentes en este
    [archivo](https://github.com/getsentry/sentry/blob/master/src/sentry/apidocs/parameters.py). Ten en cuenta
    que el campo `description` en `OpenApiParameter` rellena la descripción del parámetro en la
    documentación.
  * Los serializers de DRF se convierten cómodamente en parámetros. Consulta
    [aquí](https://github.com/getsentry/sentry/blob/0b9b6563bc4e232334cfc71f136a49117171d13f/src/sentry/api/endpoints/organization_stats_v2.py#L145)
    un ejemplo de esto.
  * Ten en cuenta que el orden de la lista determina el orden de los parámetros en la documentación.
    Los parámetros obligatorios se colocarán automáticamente al principio de la sección.

* **request:** es un serializador que genera parámetros del cuerpo.
  * Por lo general, puede ser simplemente el serializer de DRF del propio endpoint.
    * El argumento `help_text` de cada campo del serializer completa la descripción del parámetro del cuerpo en la documentación.
      * Para serializers anidados, usa en su lugar el docstring de la clase para completar la descripción del parámetro.
        Consulta [aquí](https://github.com/getsentry/sentry/blob/338916947b1a316bf908d048b9feb27dceced351/src/sentry/api/serializers/rest_framework/project_key.py#L9-L24)
        un ejemplo de esto.
    * Para excluir ciertos parámetros del cuerpo, puedes pasar `exclude_fields` al decorador
      [extend&#95;schema&#95;serializer](https://drf-spectacular.readthedocs.io/en/latest/drf_spectacular.html#drf_spectacular.utils.extend_schema_serializer).
      Consulta [aquí](https://github.com/getsentry/sentry/blob/5573be76bcbbf8cc8f5d36c72bea57c6ca207122/src/sentry/api/endpoints/organization_teams.py#L51)
      un ejemplo de esto.
    * El orden de los campos del serializer determina el orden de los parámetros del cuerpo. Los parámetros obligatorios se colocarán automáticamente en la parte superior de la sección.
      * Ten en cuenta que, para los Model serializers, el orden viene determinado por el orden del array `fields` dentro de la clase Meta. Consulta [aquí](https://github.com/getsentry/sentry/pull/57884)
        un ejemplo de esto.
  * Si necesitas más personalización o el endpoint no usa un serializer, puedes usar un
    [inline&#95;serializer](https://drf-spectacular.readthedocs.io/en/latest/drf_spectacular.html#drf_spectacular.utils.inline_serializer)
    para crear un serializer puntual. Consulta [aquí](https://github.com/getsentry/sentry/blob/6cc2769e13a09414175005bc967bd0e1db8c81bc/src/sentry/api/endpoints/project_key_details.py#L75-L98)
    un ejemplo de esto.
  * Para campos de serializer personalizados, debes tiparlos explícitamente usando el
    decorador [extend&#95;schema&#95;field](https://drf-spectacular.readthedocs.io/en/latest/drf_spectacular.html#drf_spectacular.utils.extend_schema_field).
    Consulta [aquí](https://github.com/getsentry/sentry/blob/236cc90daa1db5fcedade1db2b0bd7bb1ce9bdcd/src/sentry/api/serializers/rest_framework/project.py#L9-L10)
    un ejemplo de esto.
  * Si no hay cuerpo en la solicitud, puedes omitir por completo el campo `request`.

* **respuestas:** incluye todos los posibles casos de respuesta HTTP, tanto de éxito como de error. Puedes obtener más información sobre ellos en la siguiente sección.

* **ejemplos:** especifica la respuesta de ejemplo del endpoint. Mantenemos todos nuestros ejemplos en esta
  [carpeta](https://github.com/getsentry/sentry/tree/master/src/sentry/apidocs/examples), organizados por
  etiquetas de la barra lateral.
  * Ten en cuenta que la opción `response_only=True` es obligatoria para todos los ejemplos.
  * Actualmente solo mostramos un ejemplo de respuesta por endpoint, pero planeamos admitir
    varios en el futuro, así que siéntete libre de añadir múltiples ejemplos aquí.

    ```python
    @extend_schema(
        ...
        examples=TeamExamples.CREATE_TEAM,
    )

    from drf_spectacular.types import OpenApiExample

    class TeamExamples:
    CREATE_TEAM = [
        OpenApiExample(
            # descripción del ejemplo, no se utiliza para nada
            "Crear un nuevo equipo",
            # cuerpo real de la respuesta
            value={"slug": "my-team", "name": "My Team"},
            # los códigos de estado a los que aplica este ejemplo
            status_codes=["201"],
            # DEBES INCLUIR esto en todos los ejemplos
            response_only=True,
        )
    ]
    ```

<div id="success-responses">
  #### Respuestas satisfactorias
</div>

Especifica el tipo de retorno de las respuestas satisfactorias, que se usan para generar el esquema de la respuesta y
validar cualquier respuesta de ejemplo incluida. Hay tres formas de hacerlo:

1. Si la respuesta satisfactoria es un único objeto en lugar de una lista, puedes pasar un serializer de DRF como
   la respuesta. Para que este serializer genere un esquema, su método `serialize` debe estar
   tipado para devolver un [TypedDict](https://peps.python.org/pep-0589/)`*`

Por ejemplo, este [código de muestra](https://github.com/getsentry/sentry/blob/0b9b6563bc4e232334cfc71f136a49117171d13f/src/sentry/scim/endpoints/members.py#L202)
tiene el código de estado `200` que devuelve un `OrganizationMemberSCIMSerializer`. Su método
[`serialize`](https://github.com/getsentry/sentry/blob/0b9b6563bc4e232334cfc71f136a49117171d13f/src/sentry/api/serializers/models/organization_member/scim.py#L14-L16)
está tipado para devolver un
[`OrganizationMemberSCIMSerializerResponse`](https://github.com/getsentry/sentry/blob/0b9b6563bc4e232334cfc71f136a49117171d13f/src/sentry/api/serializers/models/organization_member/response.py#L60)
TypedDict que especifica los tipos del cuerpo de la respuesta.

Para indicar campos opcionales que pueden o no estar presentes en la respuesta, debes usar
[totality](https://peps.python.org/pep-0589/#totality) y separar tu TypedDict en
dos clases. La primera clase debe contener solo campos opcionales y heredar de un TypedDict
con `total=False` en el encabezado de su clase. La segunda clase debe contener solo campos obligatorios,
y heredar de la primera clase. Consulta
[aquí](https://github.com/getsentry/sentry/blob/4404deda8376bf1a011b76964b45b58671c2a33b/src/sentry/monitors/serializers.py#L35-L48)
un ejemplo de esto.

Para campos que pueden ser nulos, usa `Optional` seguido del tipo del campo. Ten en cuenta
que un campo puede ser a la vez opcional y nulo.

```python
class ExampleResponse(TypedDict):
    potentiallyNullStringField: Optional[str]
```

`*`Al igual que con el serializador de solicitudes, usa
[extend&#95;schema&#95;serializer](https://drf-spectacular.readthedocs.io/en/latest/drf_spectacular.html#drf_spectacular.utils.extend_schema_serializer)
directamente sobre el `TypedDict` para excluir cualquier campo privado del esquema de respuesta.
Consulta [este ejemplo](https://github.com/getsentry/sentry/blob/4828c60fd7f9fce5e32769054b9a7b10dc795aaa/src/sentry/replays/post_process.py#L43-L44).

2. Para devolver una lista de objetos o para más personalización, usa
   [inline&#95;sentry&#95;response&#95;serializer](https://github.com/getsentry/sentry/blob/aa61724035370a47fdc112c14d1467be2609d9a2/src/sentry/apidocs/utils.py#L24).
   Ten en cuenta que el nombre de cada uno debe ser único o la documentación no superará las pruebas.

```python
from sentry.apidocs.utils import inline_sentry_response_serializer

@extend_schema(
    responses={
        200: inline_sentry_response_serializer(
            "RespuestaListaEquiposDeOrg", List[TeamSerializerResponse]
        ),
    }
)
```

Ten en cuenta que DESACONSEJAMOS ENCARECIDAMENTE devolver un único objeto TypedDict si tu
endpoint utiliza un serializador existente y devuelve un solo objeto. En su lugar,
usa el primer método, ya que esto garantiza que la documentación se mantenga actualizada a medida que el
endpoint evoluciona.

3. También puedes proporcionar el JSON de OpenAPI si estás teniendo problemas, aunque recomendamos evitarlo
   si es posible.

<div id="error-responses">
  #### Respuestas de error
</div>

Especifica las respuestas de error usando las constantes `OpenApiResponse` existentes en este
[archivo](https://github.com/getsentry/sentry/blob/master/src/sentry/apidocs/constants.py). También puedes
definir las tuyas propias para mensajes más detallados, como en el ejemplo a continuación.

```python
responses={
    201: TeamSerializer,
    400: RESPONSE_BAD_REQUEST,
    403: RESPONSE_FORBIDDEN,
    404: OpenApiResponse(description="Ya existe un equipo con este identificador (slug)."),
},
```

<div id="private-attributes-in-a-public-endpoint">
  ### Atributos privados en un endpoint público
</div>

Puedes incluir atributos privados dentro de un endpoint público.

Por ejemplo:
[https://docs.sentry.io/api/teams/retrieve-a-team/](https://docs.sentry.io/api/teams/retrieve-a-team/).
La respuesta incluye varios atributos:

```json
{
  "id": "2",
  "slug": "the-interstellar-jurisdiction"
  ...
}
```

Supongamos que también devolvemos un `nickname` para un equipo. Si los datos devueltos no están documentados como parte de una respuesta en nuestra documentación pública, ese atributo es un atributo privado dentro de un endpoint público.

<div id="caveats">
  ### Advertencias
</div>

* **Si el endpoint que estás modificando tenía documentación JSON previa, debes eliminar la
  ruta de la documentación antigua en [este
  archivo](https://github.com/getsentry/sentry/blob/master/api-docs/openapi.json)
  y su correspondiente compilación JSON en [esta
  carpeta](https://github.com/getsentry/sentry/blob/master/api-docs/paths).**

* **Además, si hay varios tipos de solicitud en el mismo endpoint que usan la documentación JSON antigua,
  debes actualizar todos en el mismo PR. Actualizar solo una solicitud y
  eliminar la documentación antigua hará que las demás solicitudes desaparezcan de la documentación.**

<div id="building-and-testing-locally">
  ### Compilar y probar localmente
</div>

**Comandos**:

* `make test-api-docs` compila el JSON de OpenAPI, valida el esquema de todos los ejemplos y ejecuta todas
  las pruebas de la documentación de la API.
* `make build-api-docs` compila el JSON de OpenAPI. La compilación fallará si hay alguna advertencia.
* `make diff-api-docs` genera un diff entre tu JSON de OpenAPI local y el de producción.
* `make watch-api-docs` recompila automáticamente el JSON de OpenAPI cuando hay cambios.

**Para ver tus cambios en la documentación localmente**:

En `sentry`:

1. Usa `make watch-api-docs` para compilar continuamente el artefacto intermedio
   `tests/apidocs/openapi-derefed.json` localmente.
2. Copia la ruta completa a `{YOUR_SYSTEM_FOLDER}/tests/apidocs/openapi-derefed.json`,

p. ej. `/Users/yourname/code/sentry/tests/apidocs/openapi-derefed.json`.

En `sentry-docs`:

1. Ejecuta `OPENAPI_LOCAL_PATH=<COPIED_FULL_PATH> DISABLE_THUMBNAILS=1 yarn dev` y sustituye
   `<COPIED_FULL_PATH>` por la ruta a tu openapi-derefed.json local.

   Lamentablemente, los cambios no se reflejan automáticamente en tu servidor local, así que tendrás que
   volver a ejecutar este comando con cada cambio. Esperamos añadir esta función en el futuro.

Consulta [aquí](https://docs.sentry.io/contributing/environment/) para obtener instrucciones detalladas sobre la compilación de la documentación.

Cuando abras el pull request, agrega una captura de pantalla de la página o páginas que estés agregando.

<div id="build-process">
  ### Proceso de compilación
</div>

La prueba de openapi-diff fallará cuando CI se ejecute en tu pull request; esto es esperado y sirve para
resaltar las diferencias. No es necesario para poder hacer el merge.

Una vez que hagas cambios en un endpoint y fusiones el cambio en Sentry, se activará una serie de GitHub Actions
para que tus cambios se publiquen automáticamente:

1. El [workflow openapi en
   sentry](https://github.com/getsentry/sentry/blob/master/.github/workflows/openapi.yml) actualiza
   el esquema en [sentry-api-schema](https://github.com/getsentry/sentry-api-schema) con el
   artefacto de compilación de OpenAPI.
2. El [workflow cascade-to-sentry-docs en
   sentry-api-schema](https://github.com/getsentry/sentry-api-schema/blob/main/.github/workflows/cascade-to-sentry-docs.yml)
   reacciona al push a `main` en (1) activando el [workflow bump-api-schema-sha en
   sentry-docs](https://github.com/getsentry/sentry-docs/blob/master/.github/workflows/bump-api-schema-sha.yml).
3. El [workflow bump-api-schema-sha en
   sentry-docs](https://github.com/getsentry/sentry-docs/blob/master/.github/workflows/bump-api-schema-sha.yml)
   obtiene el SHA del último commit de `sentry-api-schema` y lo escribe en el archivo correspondiente; luego
   crea y fusiona un PR en `sentry-docs`, lo que inicia un despliegue a través de Vercel a
   https://docs.sentry.io/api/.

<div id="troubleshooting-api-docs-tests">
  ## Solución de problemas en las pruebas de la documentación de la API
</div>

NOTA: La prueba `openapi-diff` debería fallar cuando CI se ejecuta en tu pull request, ya que está pensada para resaltar los cambios en el esquema. No es necesaria para hacer el merge.

**Problema**: `TypeError: Cannot read properties of null (reading 'type')`

**Solución**: Si tienes un `ChoiceField` que puede ser null, asegúrate de usar la opción adecuada. Usa `allow_blank` para elecciones textuales y `allow_null` para elecciones numéricas y otras no textuales.

***

**Problema**: `must have required property '<property_name>'`

```json
{
        "type": "Validation",
        "message": "debe tener la propiedad obligatoria '<property_name>'",
        "instancePath": "",
        "schemaPath": "#/required",
        "keyword": "required",
        "params": {
            "missingProperty": "<property_name>"
        },
        "examplePath": "<endpoint_path>"
}
```

**Solución**: A tu respuesta de ejemplo le falta la propiedad obligatoria `<property_name>` especificada por la clase de respuesta. `<property_name>` debe hacerse opcional en la clase de respuesta o añadirse a la respuesta de ejemplo.

***

**Problema**: `no debe tener propiedades adicionales`

```json
{
        "type": "Validation",
        "message": "no debe tener propiedades adicionales",
        "instancePath": "",
        "schemaPath": "#/additionalProperties",
        "keyword": "additionalProperties",
        "params": {
            "additionalProperty": "<nombre_de_la_propiedad>",
        },
        "examplePath": "<ruta_del_endpoint>"
}
```

**Solución**: Tu ejemplo de respuesta incluye una propiedad `<property_name>` que no está definida en la clase de respuesta. Debes añadirla a la clase de respuesta o eliminarla del ejemplo.

***

**Problema**: `debe ser <type>`

```json
{
        "type": "Validation",
        "message": "debe ser de tipo <type>",
        "instancePath": "/0/<property_name>",
        "schemaPath": "#/items/properties/<property_name>/type",
        "keyword": "type",
        "params": {
            "type": "<type>"
        },
        "examplePath": "<endpoint_path>"
}
```

**Solución**: El tipo del valor de una propiedad en tu respuesta de ejemplo no coincide con el tipo de la propiedad especificado por la clase de respuesta. Debes corregir el valor de ejemplo o el tipo de la propiedad en la clase de respuesta.

***

**Problema**: `sentry.apidocs.utils.SentryApiBuildError: projects is not defined by OPENAPI_TAGS in src/sentry/apidocs/build.py for <endpoint title>`

**Solución**: Debes agregar el endpoint a una [pestaña de la barra lateral](/es/backend/api/public/#3-sidebar-tab) con el decorador `@extend_schema(tags=['<section title>'])`.

***

**Problema**: `drf_spectacular.plumbing.UnableToProceedError' <class 'serializer_path.FooSerializer'> ... raise UnableToProceedError(hint)`

**Solución**: Verifica que la respuesta de tu documentación de la API use un TypedDict en lugar de un serializer.

Si el esquema se ve así:

```python
...
200: inline_sentry_response_serializer(
                "ListDocIntegrationResponse", list[FooSerializer]
            ),
```

Luego debes cambiarlo para usar un TypedDict: primero tipa el serializador y luego actualiza el esquema para usar el TypedDict:

```python
...
200: inline_sentry_response_serializer(
                "ListDocIntegrationResponse", list[FooSerializerResponse]
            ),
```

Consulta la sección anterior sobre [Respuestas correctas](#success-responses) para obtener más información.

***

<div id="requesting-an-api-to-be-public">
  ## Solicitar que una API sea pública
</div>

¿Usas Sentry y quieres que un endpoint sea público?

Consulta los [issues en Sentry con la etiqueta `Component: API`](https://github.com/getsentry/sentry/issues?q=is%3Aopen+is%3Aissue+label%3A%22Component%3A+API%22).
Si ya existe una solicitud para hacer público el endpoint, dale un “me gusta”. Si no, crea
una [solicitud de función](https://github.com/getsentry/sentry/issues/new?template=feature.yml) en Sentry
y añade la etiqueta `Component: API`.

El equipo responsable del endpoint revisará su estabilidad. Si el endpoint
no tendrá cambios disruptivos en el futuro, podrán decidir si hacerlo público.

<div id="faqs">
  ### Preguntas frecuentes
</div>

**¿Cuándo debe ser `required` un atributo?**

Un atributo es `required` si la API siempre lo devuelve.

**¿Qué significa que una respuesta no tenga un esquema?**

Algunos endpoints no tienen esquema de respuesta. Esto significa que, aunque el endpoint sea público, los atributos
de ese endpoint pueden cambiar en cualquier momento. Esto es un vestigio de la migración de la documentación desde
nuestro enfoque anterior. Ten en cuenta que, en adelante, recomendamos que los nuevos endpoints siempre incluyan un
esquema de respuesta.

**¿Pueden los clientes usar endpoints privados?**

Sí, si así lo desean. Sin embargo, los endpoints privados pueden cambiar en cualquier momento sin previo aviso,
lo que podría romper el código del cliente. Por favor, ten cuidado al usarlos.

**Tengo una pregunta y no ha sido respondida.**

No hay problema. Envíanos un [correo](mailto:partners@sentry.io) para que podamos responder tu pregunta.
---
title: Principios de dise√±o
sidebar_order: 2
---

Este documento contiene un conjunto de principios de dise√±o y requisitos que deben aplicarse a todas las API de Sentry. Estos son _requisitos_ al dise√±ar API p√∫blicas (como la API web de Sentry), pero las API internas (como un servicio interno con el que Sentry se comunica) tambi√©n deber√≠an intentar ce√±irse a estos principios cuando tenga sentido.

En el monolito de Sentry, usamos [Django REST framework](https://www.django-rest-framework.org/) (DRF).

<Alert>

**Nota:** No todas las API que hemos expuesto siguen estas pautas, pero se espera que los nuevos endpoints s√≠ lo hagan, y trabajaremos para migrar los endpoints existentes a fin de que cumplan estos principios.

</Alert>

<div id="apis-are-public">
  ## Las API son p√∫blicas
</div>

**Cada endpoint de la API de Sentry es p√∫blico.**

Aunque no est√© documentado p√∫blicamente, si existe en las rutas expuestas debes tratarlo como p√∫blico. **No** debes exponer detalles internos, incluidos par√°metros que controlen el comportamiento del sistema subyacente.

Por ejemplo, si tuvieras un endpoint que en algunos casos deba consultar una r√©plica, **no** expongas un par√°metro para controlar ese comportamiento (por ejemplo, `useReplica=1`). En su lugar, deber√≠as controlar esta bandera desde el backend en funci√≥n de otra informaci√≥n (como un feature flag o la configuraci√≥n de la cuenta).

<div id="route-design">
  ## Dise√±o de rutas
</div>

Las rutas son una de las partes m√°s importantes de la estructura de tu API, ya que comunican relaciones e intenci√≥n. Es importante definirlas correctamente y seguir un conjunto de pautas para facilitar la comprensi√≥n y el uso de la API.

Esto no es distinto ‚Äîy es igual de importante‚Äî a c√≥mo piensas en la estructura de URL de tu interfaz de usuario.

Usa las siguientes pautas para nombrar recursos y sus colecciones:

- **Usa** nombres de colecciones en min√∫sculas y con guiones, p. ej., `commit-files`.
- **Usa** nombres de colecciones en plural. Evita usar palabras incontables porque el usuario no puede saber si el GET devuelve un elemento o una lista.
- **Usa** `snake_case` para los par√°metros de ruta, p. ej., `tags/{tag_name}/`.
- **Acorta** de forma consistente los par√°metros excesivamente largos cuando el t√©rmino sea inequ√≠voco, p. ej., `organization` -> `org`.

Par√°metros de ruta est√°ndar que deber√≠an abreviarse en las rutas:

- `organization` -> `org` (p. ej., `/organizations/{org}/`)

<div id="prefixes-and-scoping">
  ### Prefijos y alcance
</div>

La informaci√≥n en Sentry suele estar restringida por tenants. Es decir, casi toda la informaci√≥n est√° asociada a una organizaci√≥n. Todos los endpoints que consultan datos de clientes **deben** estar acotados a una organizaci√≥n:

- **Haz** que las colecciones de recursos de organizaci√≥n lleven el prefijo `/organizations/{org}/`.
- **Haz** que las colecciones de recursos de proyecto lleven el prefijo `/projects/{org}/{project}/`.
- **No** expongas endpoints que requieran `org` como par√°metro de consulta (siempre debe ser un par√°metro de ruta).

Elegir a qu√© restricci√≥n acoplar un endpoint depender√° de su prop√≥sito. Por ejemplo, si un endpoint solo se va a usar para consultar datos de un √∫nico proyecto, deber√≠a llevar el prefijo `/projects/{org}/{project}/things`. Si un endpoint necesitara existir para consultar varios proyectos (algo com√∫n en consultas entre proyectos), probablemente deber√≠as exponerlo como `/organizations/{org}/things` y ofrecer un par√°metro de consulta para filtrar por proyecto(s).

Las excepciones a estas reglas incluyen:

- Los datos espec√≠ficos del usuario no est√°n asociados a una organizaci√≥n.
- Endpoints usados para administrar el propio Sentry, como el endpoint `health` o endpoints administrativos (que pueden consultar datos de varias organizaciones).

<div id="resource-nesting">
  ### Anidaci√≥n de recursos
</div>

**No** superes los tres niveles de anidaci√≥n de recursos.

La anidaci√≥n de recursos como `/organizations/{org}/projects/` es **preferible** a recursos planos como `/0/projects/`. Esto mejora la legibilidad y facilita una comprensi√≥n natural de la jerarqu√≠a y las relaciones entre recursos. Sin embargo, la anidaci√≥n puede hacer que las URL sean demasiado largas y dif√≠ciles de usar. Sentry utiliza una anidaci√≥n de 3 niveles como soluci√≥n h√≠brida.

Estos son algunas posibles URL para valores con esta jerarqu√≠a de recursos: organizaci√≥n -> proyecto -> etiqueta -> valor:

- üëç `/projects/{org}/{project}/tags/{tag}/values`
- üëé `/organizations/{org}/projects/{project}/tags/{tag}/values/`
- üëé `/values/`

La jerarqu√≠a aqu√≠ no implica necesariamente que una colecci√≥n pertenezca a una colecci√≥n superior; simplemente indica una relaci√≥n. Por ejemplo:

- `/projects/{project_identifier}/teams/` se refiere a los **equipos** que se han a√±adido a un proyecto espec√≠fico
- `/teams/{team_identifier}/projects/` se refiere a los **proyectos** a los que se ha a√±adido un equipo espec√≠fico

<div id="parameter-design">
  ## Dise√±o de par√°metros
</div>

- **Usa** `camelCase` para los par√°metros de consulta y del cuerpo de la solicitud. p. ej., `/foo/?userId=123`.
- **Usa** `camelCase` para todos los atributos de respuesta. p. ej., `{userId: "123"}`.

Para mantener la coherencia, tambi√©n procuramos reutilizar par√°metros conocidos en todos los endpoints.

- **Usa** `sortBy` para ordenar. p. ej., `?sortBy=-dateCreated`.
- **Usa** `orderBy` para especificar el orden. p. ej., `?orderBy=asc` o `?orderBy=desc`.
- **Usa** `limit` para limitar la cantidad de resultados devueltos. p. ej., `?limit=10`.
- **Usa** `cursor` para la paginaci√≥n.

<div id="resource-identifiers">
  ### Identificadores de recursos
</div>

Los identificadores existen tanto en la ruta (`/organizations/{organization}/projects/`) como en otros par√°metros, como las cadenas de consulta (`?organization=123`) y los cuerpos de la solicitud (`{organization: "123"}`).

Lo m√°s importante aqu√≠ es garantizar que se exponga un √∫nico identificador como clave para los recursos. Por ejemplo, es preferible usar `organization` y aceptar tanto `organization_id` como `organization_slug` como identificadores v√°lidos.

- **Debes** acortar el nombre del atributo para representar el recurso (p. ej., `organization` en lugar de `organization_slug`).
- **Debes** admitir tanto identificadores num√©ricos como legibles por personas para los recursos en un √∫nico par√°metro (p. ej., `organization`).
- **No debes** exigir par√°metros tipados espec√≠ficamente para los identificadores (p. ej., `organization_slug` y `organization_id`).

Adem√°s, las respuestas deben exponer ambos par√°metros al cliente y sugerir el uso del identificador legible por personas cuando se muestre a los usuarios finales.

<div id="operations-and-verbs">
  ## Operaciones y verbos
</div>

Al usar HTTP, nos ce√±imos a un subconjunto de los verbos disponibles para definir nuestras operaciones. Estos crean operaciones impl√≠citas sobre los recursos.

Por ejemplo, en una API tradicional de estilo RPC, podr√≠amos definir un m√©todo `listProjects`. En HTTP recurrimos al verbo `GET` y a la ruta de la URL para indicar que esta operaci√≥n devolver√° una lista de recursos.

Los siguientes verbos se usan en nuestro dise√±o de API:

* **GET** - Leer un recurso
* **POST** - Crear un recurso
* **PUT** - Actualizar un recurso; debe admitir actualizaciones parciales
* **DELETE** - Eliminar un recurso

No utilices **PATCH**, ya que es redundante.

**PATCH** se usa com√∫nmente para aplicar actualizaciones parciales, pero, dado que en la pr√°ctica las actualizaciones casi siempre son parciales, preferimos admitir ese comportamiento mediante **PUT**.

Adem√°s, aunque no es com√∫n, si tienes un caso de uso en el que necesites ‚Äúreemplazar un recurso‚Äù, debes definirlo usando una solicitud **POST**:

```
POST /resources/{id}
```


<div id="batch-operations">
  ### Operaciones por lotes
</div>

Los recursos pueden volverse complejos cuando necesitas exponer operaciones por lotes frente a operaciones sobre un √∫nico recurso. Para las operaciones por lotes, es preferible exponerlas como una solicitud `PUT` sobre la colecci√≥n cuando sea posible.

Supongamos, por ejemplo, que tenemos un endpoint que modifica un issue:

```
PUT /api/0/organizations/{org}/issues/{issue}/
```

Al dise√±ar una interfaz por lotes, simplemente la exponemos en la colecci√≥n en lugar de en el recurso individual:

```
PUT /api/0/organizations/{org}/issues/
```

Es posible que tambi√©n debas exponer selectores en recursos de procesamiento por lotes, lo cual puede hacerse mediante par√°metros de solicitud normales:

```
PUT /api/0/organizations/{org}/issues/
{
  "issues": [1, 2, 3]
}
```


<div id="resource-isolation">
  ## Aislamiento de recursos
</div>

Cada API debe ser **sin estado**, tener un prop√≥sito claro y hacer una cosa espec√≠fica. Para lograrlo, ap√©gate a los m√©todos est√°ndar que se indican a continuaci√≥n. Si tu API necesita ser m√°s compleja, colabora con [owners-api](https://github.com/orgs/getsentry/teams/owners-api) para definir c√≥mo crearla.

* **Haz** que tus endpoints operen sobre objetos individuales (como un proyecto)
* **No** combines m√∫ltiples operaciones en un solo endpoint *a menos que sea necesario* (p. ej., si requiere garant√≠as transaccionales).
* **Haz** usar endpoints personalizados expl√≠citos para operaciones complejas, en lugar de sobrecargar el endpoint de un √∫nico recurso.

| Funcionalidad | M√©todo HTTP | Objeto de respuesta | Ejemplo |
| --- | ---- | ---- | ---- |
| Crear | POST | Recurso creado serializado | [Crear un proyecto](https://github.com/getsentry/sentry/blob/756bda4419cfaf28b2e351278a5c4c1665082eba/src/sentry/api/endpoints/team_projects.py#L156) |
| Actualizar | PUT | Recurso actualizado serializado | [Actualizar la configuraci√≥n del proyecto](https://github.com/getsentry/sentry/blob/756bda4419cfaf28b2e351278a5c4c1665082eba/src/sentry/api/endpoints/project_details.py#L474) |
| Obtener | GET | Recurso individual serializado | [Obtener un proyecto](https://github.com/getsentry/sentry/blob/756bda4419cfaf28b2e351278a5c4c1665082eba/src/sentry/api/endpoints/project_details.py#L415) |
| Eliminar | DELETE | Ninguno | [Eliminar un proyecto](https://github.com/getsentry/sentry/blob/756bda4419cfaf28b2e351278a5c4c1665082eba/src/sentry/api/endpoints/project_details.py#L840) |
| Listar | GET | Lista de m√∫ltiples recursos serializados | [Listar todos los proyectos de una organizaci√≥n](https://github.com/getsentry/sentry/blob/756bda4419cfaf28b2e351278a5c4c1665082eba/src/sentry/api/endpoints/organization_projects.py#L49) |
| Obtener en lote | GET | Lista de recursos serializados | Obtener detalles de proyectos por IDs espec√≠ficos |
| Crear en lote | POST | Lista de recursos creados serializados | Crear m√∫ltiples proyectos con la misma configuraci√≥n  |
| Actualizar en lote | PUT | Lista de recursos actualizados serializados | [Actualizar una lista de issues](https://github.com/getsentry/sentry/blob/ea14f740c78b8df68281ffad6a3bf3709ed3d5b5/src/sentry/api/endpoints/organization_group_index.py#L379) |
| Eliminar en lote | DELETE | Ninguno | [Eliminar una lista de issues](https://github.com/getsentry/sentry/blob/ea14f740c78b8df68281ffad6a3bf3709ed3d5b5/src/sentry/api/endpoints/organization_group_index.py#L467)|

Aqu√≠ tienes algunos ejemplos de c√≥mo usar m√©todos est√°ndar para representar tareas complejas:

**Obtener estad√≠sticas de un recurso**

La mejor opci√≥n aqu√≠ es incluirlo como un atributo del recurso:

```
GET /api/0/projects/{project}/
{
  "projects": [],
  "count": 100,
}
```

En algunos casos, esto se devolver√° como parte de un encabezado HTTP, espec√≠ficamente para aspectos relacionados con la paginaci√≥n.

**Obtener los recursos m√°s recientes**

El orden y el filtrado deben realizarse mediante los par√°metros de consulta de la API de listado. Aqu√≠ tienes una [buena lectura](https://www.moesif.com/blog/technical/api-design/REST-API-Design-Filtering-Sorting-and-Pagination/).

* **Usa** `orderBy` y `sortBy`. p. ej., `/api/0/issues/{issue_id}/events?orderBy=-date`
* **No** crees rutas espec√≠ficas para estos comportamientos.


<div id="responses">
  ## Respuestas
</div>

Cada objeto de respuesta devuelto por una API debe ser una versi√≥n serializada del modelo de Django asociado al recurso. Puedes ver todos los serializadores existentes [aqu√≠](https://github.com/getsentry/sentry/tree/master/src/sentry/api/serializers/models).

Algunas pautas sobre la estructura de las respuestas:

* **S√≠** usa `camelCase` para todos los atributos de la respuesta. p. ej., `{"numCount": "123"}`.
* **S√≠** devuelve las respuestas como un recurso con nombre (p. ej., `{"user": {"id": "123"}}`).
* **S√≠** indica colecciones usando sustantivos en plural (p. ej., `{"users": []}`).
* **No** devuelvas objetos personalizados. **S√≠** usa un `Serializer` para serializar el recurso.
* **S√≠** devuelve la menor cantidad de datos necesaria para representar el recurso.

Adem√°s, dado que JavaScript es un consumidor principal, ten en cuenta las restricciones sobre aspectos como los n√∫meros. En t√©rminos generales:

* **S√≠** devuelve identificadores de recursos (incluso num√©ricos) como cadenas.
* **S√≠** devuelve decimales como cadenas.
* **No** devuelvas n√∫meros en coma flotante.

**Nota sobre el formato del recurso**

Ver√°s que la mayor√≠a de nuestros recursos pueden incumplir el formato de respuesta de recurso con nombre. Es decir, `/api/0/projects/{project}/` devuelve una representaci√≥n aplanada:

```
GET /api/0/projects/{project}/
{
  "id": 5,
  "name": "foo",
  ...
}
```

Mientras que nuestras pautas indican que deber√≠a estar anidado:

```
GET /api/0/projects/{project}/
{
  "project": {
    "id": "5",
    "name": "foo",
    ...
  }
}
```

As√≠ fue como se dise√±√≥ la API original, pero debido a sus limitaciones, planeamos pasar a objetos anidados en el futuro.


<div id="expanding-responses">
  ### Ampliaci√≥n de respuestas
</div>

Las respuestas ampliadas nos permiten incluir informaci√≥n relacional de un recurso sin cargarla de forma predeterminada.

En general, los endpoints deben exponer la menor cantidad de campos necesaria para que la API resulte usable en el caso general. Hacer una consulta SQL por cada solicitud a la API es una buena regla general. Para devolver informaci√≥n sobre una relaci√≥n acotada, los endpoints deben apoyarse en el par√°metro `expand`. Para devolver una relaci√≥n no acotada, deber√≠a existir otro endpoint.

Por ejemplo, hablemos del endpoint de la lista de proyectos. Un proyecto pertenece a una organizaci√≥n, pero puede estar en varios equipos.

De forma predeterminada, as√≠ deber√≠a verse el endpoint de proyectos

```json
GET /api/0/projects/{project}/
{
  "id": 5,
  "name": "foo",
  ...
}
```

Para mostrar informaci√≥n sobre una relaci√≥n acotada, el usuario deber√≠a poder usar el par√°metro `expand`. Esto suele aplicarse √∫nicamente a relaciones 1:1.

```json
GET /api/0/projects/{project}/?expand=organization
{
  "id": 5,
  "name": "foo",
  "organization": {
    "slug": "bar",
    "isEarlyAdopter": false,
    ...
  }
  ...
}
```

Para relaciones no acotadas, realiza una consulta independiente. Esto permite paginar la consulta y reduce el riesgo de obtener una carga arbitrariamente grande.

```json
GET /api/0/projects/{project}/teams
[
  {
    "id": 1,
    "name": "Equipo 1",
    "slug": "team1",
  },
  {
    "id": 2,
    "name": "Equipo 2",
    "slug": "team2",
  }
]

```


<div id="collapsing-responses">
  ### Contracci√≥n de respuestas
</div>

Al igual que con la expansi√≥n de respuestas, un endpoint de API tambi√©n puede contraer respuestas. Cuando se pasa el par√°metro `collapse`, la API no debe devolver los atributos que se hayan contra√≠do.

Veamos de nuevo los endpoints de la lista de proyectos. Un proyecto recibe eventos y, por lo tanto, tiene un componente `stats` que indica cu√°ntos eventos se recibieron para el proyecto. Supongamos que hicimos p√∫blico el componente de estad√≠sticas del endpoint, junto con el resto del endpoint de la lista de proyectos.

```json
GET /api/0/projects/{project}/
{
  "id": 5,
  "name": "foo",
  "stats": {
    "24h": [
        [1629064800, 27],
        [1629068400, 24],
        ...
    ]
  }
}
```

Se puede pasar el par√°metro `collapse` para no devolver informaci√≥n de estad√≠sticas.

```json
GET /api/0/projects/{project}/?collapse=stats
{
  "id": 5,
  "name": "foo",
  ...
}
```

Esto suele ser necesario solo si el endpoint ya es p√∫blico y no queremos introducir un cambio incompatible. Recuerda: si el endpoint es p√∫blico y eliminamos un atributo, es un cambio incompatible. Si est√°s iterando en un endpoint no documentado, devuelve el conjunto m√≠nimo de atributos y utiliza el par√°metro `expand` para obtener informaci√≥n m√°s detallada.


<div id="pagination">
  ### Paginaci√≥n
</div>

> > Las API a menudo necesitan proporcionar colecciones de datos, m√°s com√∫nmente mediante el m√©todo est√°ndar `List`. Sin embargo, las colecciones pueden tener tama√±os arbitrarios y tienden a crecer con el tiempo, lo que aumenta tanto el tiempo de b√∫squeda como el tama√±o de las respuestas que se env√≠an por la red. Por eso es importante paginar las colecciones.

La paginaci√≥n de respuestas es una [pr√°ctica est√°ndar para API](https://google.aip.dev/158) que Sentry sigue.

Arriba vimos un ejemplo de un endpoint `List`; estos endpoints tienen dos se√±ales claras:

```json
GET /api/0/projects/{project}/teams
[
  {
    "id": 1,
    "name": "Team 1",
    "slug": "team1",
  },
  {
    "id": 2,
    "name": "Team 2",
    "slug": "team2",
  }
]

```

1. El endpoint devuelve una lista, o varios objetos, en lugar de solo uno.
2. El endpoint a veces puede terminar en plural (s), pero lo m√°s importante es que **no** termina en un identificador (`*_slug` o `*_id`).

Para paginar una respuesta en Sentry, puedes usar el m√©todo [`self.paginate`](https://github.com/getsentry/sentry/blob/24.2.0/src/sentry/api/base.py#L463-L476) como parte de tu endpoint.
`self.paginate` es la forma estandarizada en que paginamos en Sentry y nos ayuda a unificar el registro y la monitorizaci√≥n.
Puedes encontrar varios [ejemplos de esto](https://github.com/getsentry/sentry/blob/24.2.0/src/sentry/api/endpoints/api_applications.py#L22-L33) en el c√≥digo. Se ver√°n algo como:

```python
def get(self, request: Request) -> Response:
    queryset = ApiApplication.objects.filter(
        owner_id=request.user.id, status=ApiApplicationStatus.active
    )

    return self.paginate(
        request=request,
        queryset=queryset,
        order_by="name",
        paginator_cls=OffsetPaginator,
        on_results=lambda x: serialize(x, request.user),
    )
```

El ejemplo anterior utiliza un paginador de tipo offset, pero puedes usar el tipo de paginador que mejor se ajuste a las necesidades de tu endpoint.
Hay algunos [tipos ya disponibles](https://github.com/getsentry/sentry/blob/24.2.0/src/sentry/api/paginator.py) que puedes usar tal cual, o puedes extender la clase base [`BasePaginator`](https://github.com/getsentry/sentry/blob/24.2.0/src/sentry/api/paginator.py#L48) e implementar el tuyo propio.

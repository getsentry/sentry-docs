---
title: Serializadores
sidebar_order: 10
---

Los serializadores se utilizan para convertir modelos complejos de Python en JSON. También pueden emplearse para deserializar JSON de vuelta a los modelos de Python, tras validar los datos entrantes.

En Sentry contamos con **dos** tipos de serializadores: los de Django Rest Framework y los serializadores de modelos.

<div id="django-rest-framework">
  ## Django Rest Framework
</div>

Los serializadores de Django Rest Framework se utilizan para validar y transformar los datos que ingresan a Sentry.

<div id="example">
  ### Ejemplo
</div>

En un serializador típico, se especifican los campos para que validen el tipo y el formato de los datos según tus especificaciones. Los serializadores de Django Rest Framework también pueden guardar la información en la base de datos si se implementan para ajustarse al modelo.

```python
from rest_framework import serializers
from sentry.api.serializers.rest_framework import ValidationError

class ExampleSerializer(serializers.Serializer):
    name = serializers.CharField()
    age = serializers.IntegerField(required=False)
    type = serializers.CharField()

    def validate_type(self, attrs, source):
        type = attrs[source]
        if type not in ['bear', 'rabbit', 'puppy']:
            raise ValidationError('%s no es un tipo válido' % type)
	return attrs
```

**Verificación de campos**

En el ejemplo anterior, el serializador aceptará y validará JSON que contenga tres campos: `name`, `age` y `type`. Aquí, `name` y `type` deben ser `strings` y `age` debe ser un `integer`, como se indica. De forma predeterminada, los campos son obligatorios y, si no se proporcionan, el serializador los marcará como no válidos. Ten en cuenta que en el campo entero `age`, `required` está establecido en `False`. Por lo tanto, puede omitirse y el serializador seguirá considerándose válido.

**Validación personalizada**

Para valores que necesitan validación personalizada (además de la verificación simple de tipos), se puede crear

`def validate_<variable_name>(self, attrs, source)`

donde `<variable_name>` se sustituye por el nombre de la variable **exacto** tal como se definió el campo. Por ejemplo, si tuvieras un campo llamado `typeName`, el nombre del método de validación sería `validate_typeName`, mientras que si tuvieras un campo llamado `type_name`, el nombre del método sería `validate_type_name`. En el ejemplo anterior, `type` se comprueba y debe ser una cadena específica. Si un campo no coincide con lo que espera tu método de validación, lanza un `ValidationError`.


<div id="usage">
  ### Uso
</div>

En un endpoint, este es el uso típico de un serializer de Django REST Framework

```python
class ExampleEndpoint(Endpoint):
    def post(self, request):
        serializer = ExampleSerializer(request.DATA)
        if not serializer.is_valid():
            return Response(serializer.errors, status=400)

        result = serializer.object

        # Suponiendo que Example es un modelo con los mismos campos
        try:
            with transaction.atomic():
                Example.objects.create(
                    name=result['name'],
                    age=result.get('age'),
                    type=result['type'],
                )
        except IntegrityError:
            return Response('Este ejemplo ya existe', status=409)

        return Response(serialize(result, request.user), status=201)
```

**Validación de datos**

El serializer de Django Rest Framework se usará en métodos con datos entrantes (es decir, los métodos `put` y `post`) que necesiten validación. Una vez instanciado el serializer, puedes llamar a `serializer.is_valid()` para validar los datos. `serializer.errors` proporcionará información específica sobre qué fue inválido en los datos proporcionados.

Por ejemplo, dado el siguiente input

```python
{
	'edad':5,
	'tipo':'cachorro'
}
```

El serializador devolvería un error indicando que no se proporcionó el campo obligatorio name.

**Guardar datos**

Una vez que hayas verificado que los datos son válidos, puedes guardarlos de dos maneras. El ejemplo anterior es el más común en Sentry. Toma `serializer.object`, que es simplemente los datos validados (y será `None` si `serializer.is_valid()` devuelve `False`), y guarda esos datos directamente en el modelo con `<ModelName>.objects.create`.

Un método alternativo aprovecha más funciones de Django Rest Framework, el [ModelSerializer](http://www.tomchristie.com/rest-framework-2-docs/api-guide/serializers#modelserializer)

```python
from rest_framework import serializers
from sentry.api.serializers.rest_framework import ValidationError

class ExampleSerializer(serializer.ModelSerializer):
    name = serializers.CharField()
    age = serializers.IntegerField(required=False)
    type = serializers.CharField()

    class Meta:
        model = Example

    def validate_type(self, attrs, source):
        type = attrs[source]
        if type not in ['bear', 'rabbit', 'puppy']:
            raise ValidationError('%s no es un tipo válido' % type)
        return attrs

class ExampleEndpoint(Endpoint):
    def post(self, request):
        serializer = ExampleSerializer(request.DATA)
        if not serializer.is_valid():
            return Response(serializer.errors, status=400)

        example = serializer.save()
        return Response(serialize(example, request.user), status=201)
```


<div id="model-serializer">
  ## Serializador de modelos
</div>

[Los serializadores de modelos de Sentry](https://github.com/getsentry/sentry/blob/master/src/sentry/api/serializers/base.py) son una implementación propia que se usa solo para datos de salida. El serializador de modelos típico luce así:

```python
@register(Example)
class ExampleSerializer(Serializer):
    def get_attrs(self, item_list, user):
        attrs = {}
        types = ExampleTypes.objects.filter(
            type_name__in=[i.type for i in item_list]
        )

        for item in item_list:
            attrs[item] = {}
            attrs[item]['type'] = [t for t in types if t.name == item.type_name]
	    return attrs

    def serialize(self, obj, attrs, user):
        return {
            'nombre': obj.name,
            'tipo': attrs['type'],
            'edad': obj.age,
        }
```

**Registrar serializadores de modelos**

Se requiere el decorador `@register` para que

```python
return Response(serialize(example, request.user), status=201)
```

funciona. Internamente, busca un modelo correspondiente —en este caso, `Example`— según el tipo de la variable `example`. Para asociar el serializador con el Model, simplemente haz

```python
@register(<NombreDelModelo>)
class SerializadorDeModelo(Serializador):
...
```

**Método get&#95;attrs**

¿Por qué hacer esto si Django Rest Framework ofrece una funcionalidad similar? La razón es el método `get_attrs`. Te permite hacer una consulta en bloque en lugar de múltiples consultas. En nuestro ejemplo, en lugar de llamar a `ExampleTypes.objects.get(...)` para varios elementos, puedo filtrar los que quiero y asignarlos al elemento en cuestión usando Python. En el caso del diccionario `attr`, la `key` es el propio elemento y el `value` es un diccionario con el nombre del atributo que quieres agregar y sus valores.

```python
attrs[item] = {'nombre_atributo': atributo}
```

**Método Serialize**

Por último, devuelve un diccionario con información serializable a JSON que se incluirá en la respuesta.

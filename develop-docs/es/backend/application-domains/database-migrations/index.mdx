---
title: Migraciones de bases de datos
sidebar_order: 20
og_image: /og-images/backend-application-domains-database-migrations.png
---

Las migraciones de Django son la forma en que manejamos los cambios en la base de datos en Sentry.

Documentación oficial sobre migraciones de Django: [https://docs.djangoproject.com/en/5.1/topics/migrations/](https://docs.djangoproject.com/en/5.1/topics/migrations/). Ahí encontrarás la mayoría de lo necesario para entender qué hace una migración.

<div id="commands">
  ## Comandos
</div>

Ten en cuenta que en todos estos comandos puedes sustituir `getsentry` por `sentry` si estás en el repositorio `getsentry`.

<div id="upgrade-your-database-to-latest">
  ### Actualiza tu base de datos a la versión más reciente
</div>

`sentry upgrade` actualizará automáticamente tus migraciones. También puedes ejecutar `sentry django migrate` para acceder directamente al comando de migración.

<div id="move-your-database-to-a-specific-migration">
  ### Mueve la base de datos a una migración específica
</div>

Esto puede ser útil cuando quieres probar una migración.

`sentry django migrate <app_name> <migration_name>` - Ten en cuenta que `migration_name` puede ser una coincidencia parcial; a menudo con el número basta.

Por ejemplo: `sentry django migrate sentry 0005`

También puedes usarlo para revertir una migración. Útil en desarrollo si cometes un error.

<div id="produce-sql-for-a-migration">
  ### Generar SQL para una migración
</div>

Una acción de GitHub comentará automáticamente en tu PR con el SQL de tu migración, y el comentario se mantendrá actualizado con cualquier cambio futuro.
También puedes generar el SQL manualmente con este comando:

`sentry django sqlmigrate <app_name> <migration_name>`

p. ej., `sentry django sqlmigrate sentry 0003`

<div id="generate-migrations">
  ### Generar migraciones
</div>

Esto genera migraciones automáticamente en función de los cambios que hayas hecho en los modelos.

`sentry django makemigrations`

o

`sentry django makemigrations <app_name>` para una app específica.

p. ej., `sentry django makemigrations sentry`

También puedes generar una migración vacía con `sentry django makemigrations <app_name> --empty`. Esto es útil para migraciones de datos y otros trabajos personalizados.

Ten en cuenta que si has añadido un modelo nuevo, también debes importar el modelo en `__init__.py`, o no se reconocerá durante las pruebas.

<div id="merging-migrations-to-master">
  ## Fusionar migraciones en master
</div>

Al fusionar en master, puede que notes un conflicto con `migrations_lockfile.txt`. Este archivo está para ayudarnos a evitar fusionar dos migraciones con el mismo número de migración en master; si entras en conflicto con él, probablemente alguien haya confirmado una migración antes que tú.

<div id="automatically-resolving-conflicts">
  ### Resolución automática de conflictos
</div>

Hay un [script útil](https://github.com/getsentry/sentry/blob/master/bin/update-migration) para mover automáticamente tu migración a la parte superior del historial de migraciones.

```bash
bin/update-migration <nombre_migración>
```

Cambiará el nombre de la migración, la modificará para que dependa de la migración más reciente y actualizará el lockfile y el nombre de cualquier prueba, si existen.


<div id="manually-resolving-conflicts">
  ### Resolver conflictos manualmente
</div>

Para realizar estos pasos manualmente, haz rebase contra la rama master más reciente, elimina tu migración actual y luego vuelve a generarla. Si tu migración era personalizada, guarda las operaciones en un archivo de texto para poder volver a aplicarlas en la migración regenerada.

Siempre registra (commit) los cambios en `migrations_lockfile.txt` junto con tu migración.

<div id="guidelines">
  ## Pautas
</div>

Hay algunas cosas a las que debemos prestar atención al ejecutar migraciones.

<div id="testing">
  ### Pruebas
</div>

Nota: Las migraciones habituales que modifican la estructura de la tabla no necesitan pruebas de migración.

[Las migraciones de datos](https://docs.djangoproject.com/en/4.0/topics/migrations/#data-migrations) son especialmente arriesgadas, ya que operan sobre datos y pueden provocar pérdida o corrupción de datos irreversible. Por ello, cada migración de datos debe tener una prueba de integración correspondiente.

Para probar tu migración, deriva un caso de prueba de `TestMigrations` y agrégalo a `tests/sentry/migrations`.
Por ejemplo:

```python
class MyMigrationTest(TestMigrations):
    migrate_from = "0123_previous_migration"
    migrate_to = "0124_my_new_migration"

    def setup_before_migration(self, apps):
        # Crea aquí el estado de tu base de datos
        Project = apps.get_model("sentry", "Project")
        self.project = Project.objects.create(organization_id=self.organization.id, name="my_project")

    def test(self):
        # Prueba el estado tras la migración
        self.project.refresh_from_db()
        assert self.project.name == "MyProject"

```

Para ejecutar la prueba localmente, ejecuta `pytest` con la opción `--migrations`. Por ejemplo: `pytest -v --migrations tests/getsentry/migrations/test_0XXX_migration_name.py`.

Si quieres acelerar las pruebas de migración y no necesitas reconstruir las bases de datos en cada ejecución, añade `--reuse-db` como opción adicional al comando de prueba.


<div id="notes">
  #### Notas
</div>

- Hay un [problema conocido](https://github.com/getsentry/sentry/blob/e4627f093de4718e054ba9c6b002ff0b9a5b6033/tests/sentry/migrations/test_0295_backfill_alertrule_type.py#L1-L3) con el paquete `django-pg-zero-downtime-migrations` que provoca que falle la reversión de una restricción `NOT NULL`.
  Si esto ocurre con una migración de prueba antigua, puedes eliminar la prueba en lugar de intentar solucionar el problema.
- Si quieres usar las funciones auxiliares existentes [`create_*`](https://github.com/getsentry/sentry/blob/5f81ff47685db524133e75db181eb36e93f04327/src/sentry/testutils/factories.py#L241) para crear instancias de modelos, sobrescribe [`setup_initial_state`](https://github.com/getsentry/sentry/blob/57367022f65ada2323fb40147b38e795f869f148/src/sentry/testutils/cases.py#L1596-L1602)
  en lugar de `setup_before_migration`. Esta función se ejecutará _antes_ de que la base de datos se revierta a `migration_from`.

<div id="filters">
  ### Filtros
</div>

Si una migración de datos implica tablas grandes o columnas sin índice, es mejor iterar sobre toda la tabla en lugar de usar un filtro.
Por ejemplo:

```python
EnvironmentProject.objects.filter(environment__name="none")
```

Como hay demasiadas filas de `EnvironmentProject`, esto cargaría demasiadas en memoria a la vez.
En su lugar, debemos iterar sobre todas las filas de `EnvironmentProject` usando `RangeQuerySetWrapperWithProgressBar`, ya que lo hará por lotes.
Por ejemplo:

```python
for env in RangeQuerySetWrapperWithProgressBar(EnvironmentProject.objects.all()):
	if env.name == 'none':
		# Haz lo que tengas que hacer
```

Por lo general, preferimos evitar usar `.filter` con `RangeQuerySetWrapperWithProgressBar`. Como ya ordena por el id para iterar por la tabla,
no podemos aprovechar los índices de los campos y, potencialmente, podría escanear una gran cantidad de filas en cada bloque. Esto se ejecutará más lento, pero
por lo general lo preferimos, ya que distribuye la carga durante un período de tiempo más largo y hace que cada consulta para obtener cada bloque sea bastante barata.


<div id="indexes">
  ### Índices
</div>

El framework de migraciones los gestiona automáticamente; basta con crearlos en el modelo de Django y generar la migración.

Al añadir índices a tablas grandes, deberías usar una migración `is_post_deployment`, ya que crear el índice podría tardar más que el tiempo de espera de 5 s de la sentencia de migración.

Nota: Se crean usando `CONCURRENTLY`, por lo que es importante no establecer `atomic = True` en migraciones que incluyan índices. Esto está deshabilitado de forma predeterminada.

<div id="deleting-columns">
  ### Eliminación de columnas
</div>

Esto es complicado debido a nuestro proceso de despliegue. Cuando hacemos un despliegue, ejecutamos las migraciones y luego publicamos el código de la aplicación, lo cual lleva un tiempo. Esto significa que si simplemente eliminamos una columna o un modelo, el código en Sentry seguirá buscando esas columnas/tablas y arrojará errores hasta que el despliegue termine. En algunos casos, esto puede significar que Sentry esté completamente caído hasta que finalice el despliegue.

Para evitarlo, sigue estos pasos:

* Primero, si la columna no permite valores nulos o no tiene un `db_default` definido, crea un PR para permitir nulos con `null=True`.
* Luego, elimina todos los usos de la columna en el código en un PR aparte; esto ayuda principalmente con la limpieza del código. Este PR debe fusionarse antes de los próximos PR de migración, pero no hace falta preocuparse por si se despliega primero.
* Crea otro PR que:
  * Si la columna es una clave foránea, elimine la restricción de clave foránea a nivel de base de datos configurando `db_constraint=False`.
  * Elimine la columna y, en la migración generada, usa `SafeRemoveField(..., deletion_action=DeletionAction.MOVE_TO_PENDING)` en lugar de `RemoveField(...)`. Esto solo marca el estado de la columna como eliminada.
  * Combine estas migraciones para evitar múltiples despliegues
* Despliega tus cambios de migración. Es importante que todos los pull requests anteriores estén en producción antes de eliminar la columna real de la tabla.
* Crea un pull request que genere una nueva migración con la misma operación `SafeRemoveField` de antes, pero configurando `deletion_action=DeletionAction.DELETE`. Esto elimina la columna real de la tabla en Postgres.
* Despliega la migración que elimina la columna.

Aquí tienes un ejemplo de cómo eliminar la columna `project` de este modelo. Es una clave foránea y, además, no permite nulos:

```python
@region_silo_model
class TestModel(Model):
    __relocation_scope__ = RelocationScope.Excluded

    project = FlexibleForeignKey("sentry.Project")
    name = models.TextField()

    class Meta:
        app_label = "uptime"
        db_table = "uptime_testmodel"
```

Primero, eliminamos todas las referencias a este campo del código. Lo mejor es hacerlo en un PR separado para mantener todo ordenado.

Luego creamos dos migraciones, en PRs individuales que desplegaremos por separado.

Primer PR

```python
# <Campo eliminado completamente del modelo y del código>

# Primera migración
# ... Plantilla/boilerplate de migración ...
operations = [
    migrations.AlterField(
        model_name="testmodel",
        name="project",
        field=sentry.db.models.fields.foreignkey.FlexibleForeignKey(
            db_constraint=False,
            null=True,
            on_delete=django.db.models.deletion.CASCADE,
            to="sentry.project",
        ),
    ),
    SafeRemoveField(model_name="testmodel", name="project", deletion_action=DeletionAction.MOVE_TO_PENDING),
]
# ... Plantilla/boilerplate de migración ...
```

Segundo PR:

```python
# Segunda migración
# ... Código base de la migración ...
operations = [
    SafeRemoveField(model_name="testmodel", name="project", deletion_action=DeletionAction.DELETE),
]
# ... Código base de la migración ...
```

Entonces, una vez que tengamos estos dos PR, hacemos merge y desplegamos el primero, luego el segundo, y la tabla queda completamente eliminada.

Para recapitular los pasos:

* Elimina todas las referencias a la columna en el código en un pull request separado y haz merge. No importa si esto se despliega antes o después del siguiente paso.
* Si la columna tiene una restricción de clave foránea, elimínala. Si no permite nulos y no tiene `db_default`, márcala como nullable. Luego elimina la columna usando `SafeRemoveField(..., deletion_action=DeletionAction.MOVE_TO_PENDING)`. Estas operaciones pueden estar en la misma migración para ahorrar tiempo.
* Despliega todo lo anterior antes de continuar.
* Elimina la columna de la tabla en Postgres usando `SafeRemoveField(..., deletion_action=DeletionAction.DELETE),`

Si te sientes cómodo creando estos PR y desplegándolos, puedes detenerte aquí. De lo contrario, la siguiente sección cubre cómo crearlos con más detalle.

Para crear la primera migración, necesitamos eliminar la restricción de clave foránea a nivel de base de datos, hacer que la columna sea nullable y eliminar la columna del código. Para eliminar las restricciones de clave foránea a nivel de base de datos y marcar la columna como nullable, agregamos `db_constraint=False, null=True` a esta columna y generamos una migración:

```python
# Cambio en el modelo
...
project = FlexibleForeignKey("sentry.Project", db_constraint=False, null=True)
...

# Operaciones de migración
operations = [
    migrations.AlterField(
        model_name="testmodel",
        name="project",
        field=sentry.db.models.fields.foreignkey.FlexibleForeignKey(
            db_constraint=False,
            null=True,
            on_delete=django.db.models.deletion.CASCADE,
            to="sentry.project",
        ),
    ),
]
```


Una vez hecho esto, podemos eliminar la columna del modelo y generar la migración para removerla. La migración generada luce así:

```python
operations = [
    migrations.RemoveField(model_name="testmodel", name="project"),
]
```

Django no conoce la operación `SafeRemoveField`, así que la sustituimos por esa. Esto nos permite eliminar todo el estado relacionado con la columna, pero aplazar su eliminación hasta una migración posterior. Así, esto se convierte en

```python
operations = [
    SafeRemoveField(model_name="testmodel", name="project", deletion_action=DeletionAction.MOVE_TO_PENDING),
]
```

Como paso final, podemos combinar estas operaciones en una única migración, que será la primera que queremos implementar.

```python
operations = [
    migrations.AlterField(
        model_name="testmodel",
        name="project",
        field=sentry.db.models.fields.foreignkey.FlexibleForeignKey(
            db_constraint=False,
            null=True,
            on_delete=django.db.models.deletion.CASCADE,
            to="sentry.project",
        ),
    ),
    SafeRemoveField(model_name="testmodel", name="project", deletion_action=DeletionAction.MOVE_TO_PENDING),
]
```

Para crear la segunda migración, generamos una migración vacía (`sentry django makemigrations <your_app> --empty`), luego usamos el mismo comando `SafeRemoveField` de la migración anterior, pero cambiamos `deletion&#95;action` a `DeletionAction.DELETE`. Esta operación eliminará la columna de la tabla en Postgres:

```python
operations = [
    SafeRemoveField(model_name="testmodel", name="proyecto", deletion_action=DeletionAction.DELETE),
]
```


<div id="deleting-tables">
  ### Eliminación de tablas
</div>

Es necesario tener especial cuidado si la tabla se referencia como clave foránea en otras tablas. En ese caso, primero elimina las columnas de clave foránea en las otras tablas y luego vuelve a este paso.

* Crea un pull request para eliminar todos los usos del modelo en el código, en un pull request aparte. Esto ayuda principalmente con la limpieza del código. Debe fusionarse antes que los pull requests de migración, pero no es necesario preocuparse por si se despliega primero.
* Crea otro pull request para:
  * Eliminar cualquier restricción de clave foránea a nivel de base de datos desde esta tabla hacia otras, estableciendo `db_constraint=False` en las columnas. Si es una clave foránea de nube híbrida, establece `null=True` en su lugar.
  * Eliminar el modelo y, en la migración generada, usar `SafeDeleteModel(..., deletion_action=DeletionAction.MOVE_TO_PENDING)` en lugar de `DeleteModel(...)`. Esto solo marca el estado del modelo como eliminado.
* Despliega. Es importante que todos los pull requests anteriores estén en producción antes de eliminar la tabla real.
* Crea un pull request que genere una nueva migración con la misma operación `SafeDeleteModel` que antes, pero establece `deletion_action=DeletionAction.DELETE` en su lugar. Esto elimina la tabla real de Postgres.
* Despliega

Aquí tienes un ejemplo de cómo eliminar este modelo:

```python
@region_silo_model
class TestModel(Model):
    __relocation_scope__ = RelocationScope.Excluded

    project = FlexibleForeignKey("sentry.Project")
    name = models.TextField()

    class Meta:
        app_label = "uptime"
        db_table = "uptime_testmodel"
```

Primero, eliminamos todas las referencias a este modelo del repositorio de código, asegurándonos también de que ningún otro modelo lo utilice. Lo mejor es hacerlo en un PR independiente para mantener todo ordenado.

Luego generamos dos migraciones, en PRs individuales que desplegaremos por separado.

Primer PR

```python
# <Modelo eliminado completamente del código>

# Primera migración
# ... Código base de la migración ...
operations = [
    migrations.AlterField(
        model_name="testmodel",
        name="project",
        field=sentry.db.models.fields.foreignkey.FlexibleForeignKey(
            db_constraint=False,
            on_delete=django.db.models.deletion.CASCADE,
            to="sentry.project",
        ),
    ),
    SafeDeleteModel(name="TestModel", deletion_action=DeletionAction.MOVE_TO_PENDING),
]
# ... Código base de la migración ...
```

Segundo PR:

```python
# Segunda migración
# ... Plantilla de migración ...
operations = [
    SafeDeleteModel(name="TestModel", deletion_action=DeletionAction.DELETE),
]
# ... Plantilla de migración ...
```

Entonces, una vez que tengamos estos dos PR, fusionamos/desplegamos el primero, luego el segundo y así la tabla queda completamente eliminada.

Para recapitular los pasos:

* Elimina todas las referencias al modelo en el código en un pull request aparte y haz merge. No importa si esto se despliega antes o después del siguiente paso.
* Elimina cualquier restricción de clave foránea y elimina el modelo usando `SafeDeleteModel(..., deletion_action=DeletionAction.MOVE_TO_PENDING)`. Estas operaciones pueden ir en la misma migración para ahorrar tiempo.
* Despliega todo lo anterior antes de continuar.
* Elimina la tabla de Postgres usando `SafeDeleteModel(..., deletion_action=DeletionAction.DELETE),`

Si te sientes cómodo creando estos PR y desplegándolos, puedes detenerte aquí. De lo contrario, la siguiente sección explica cómo crearlos con más detalle.

Para crear la primera migración, necesitamos eliminar cualquier restricción de clave foránea a nivel de base de datos y eliminar la tabla del código. Para eliminar las restricciones de clave foránea a nivel de base de datos, agregamos `db_constraint=False` a esta columna y generamos una migración:

```python
project = FlexibleForeignKey("sentry.Project", db_constraint=False)
```

Esto genera una migración con operaciones como:

```python
operations = [
    migrations.AlterField(
        model_name="testmodel",
        name="project",
        field=sentry.db.models.fields.foreignkey.FlexibleForeignKey(
            db_constraint=False,
            on_delete=django.db.models.deletion.CASCADE,
            to="sentry.project",
        ),
    ),
]
```

A continuación, eliminamos el modelo del código y generamos la migración para quitarlo. La migración generada queda así:

```python
operations = [
    migrations.DeleteModel(name="TestModel"),
]
```

Django no conoce la operación `SafeDeleteModel`, así que la sustituimos por esa. Esto nos permite eliminar todo el estado relacionado con el modelo, pero posponer su eliminación hasta una migración posterior. Así queda

```python
operations = [
    SafeDeleteModel(name="TestModel", deletion_action=DeletionAction.MOVE_TO_PENDING),
]
```

Ahora, como paso final, podemos combinar estas operaciones en una única migración, que será la primera que queremos implementar.


```python
operations = [
    migrations.AlterField(
        model_name="testmodel",
        name="project",
        field=sentry.db.models.fields.foreignkey.FlexibleForeignKey(
            db_constraint=False,
            on_delete=django.db.models.deletion.CASCADE,
            to="sentry.project",
        ),
    ),
    SafeDeleteModel(name="TestModel", deletion_action=DeletionAction.MOVE_TO_PENDING),
]
```

Para crear la segunda migración, generamos una migración vacía (`sentry django makemigrations <your_app> --empty`), luego usamos el mismo comando `SafeDeleteModel` de la migración anterior, pero cambiamos deletion&#95;action a `DeletionAction.DELETE`. Esta operación eliminará la tabla de Postgres:

```python
operations = [
    SafeDeleteModel(name="TestModel", deletion_action=DeletionAction.DELETE),
]
```

Este segundo PR contendrá únicamente la migración y el código base relacionado.


<div id="foreign-keys">
  ### Claves foráneas
</div>

Crear claves foráneas suele ser correcto, pero en algunas tablas grandes o muy activas, como `Project` y `Group`, la migración puede fallar por dificultades para adquirir un bloqueo en la tabla. El procedimiento general es reintentar la migración hasta que se complete: el framework de migración agrega un tiempo de espera para la adquisición del bloqueo, así que es seguro hacerlo.

<div id="renaming-tables">
  ### Cambiar el nombre de tablas
</div>

Cambiar el nombre de tablas es arriesgado y provocará tiempo de inactividad. Esto sucede porque durante el despliegue se ejecuta una mezcla de código antiguo y nuevo. En cuanto renombremos la tabla en Postgres, el código antiguo empezará a fallar inmediatamente si intenta acceder a ella. Hay dos formas de manejar el cambio de nombre de una tabla:

- No cambies el nombre de la tabla en Postgres. En su lugar, renombra solo el modelo en Django y asegúrate de que `Meta.db_table` apunte al nombre de la tabla actual para que nada se rompa. Este es el método preferido.
- Si realmente quieres cambiar el nombre de la tabla, los pasos serían:
 - Crea una tabla con el nuevo nombre
 - Comienza a escribir en ambas tablas, la antigua y la nueva, idealmente dentro de una transacción.
 - Rellena la nueva tabla con las filas antiguas.
 - Cambia el modelo para empezar a leer de la nueva tabla.
 - Deja de escribir en la tabla antigua y elimina las referencias del código.
 - Elimina la tabla antigua.
 - En general, no compensa: implica mucho riesgo y esfuerzo en comparación con el beneficio.

<div id="adding-columns">
  ### Agregar columnas
</div>

Con Postgres 14, se pueden agregar columnas a tablas de cualquier tamaño como migraciones en tiempo de despliegue si sigues las pautas sobre valores predeterminados y permitir valores nulos. Al crear nuevas columnas, estas deben ser:

- No nulas con un valor predeterminado
- Creadas como aceptan nulos. Si no se puede establecer un valor predeterminado en la columna, lo mejor es simplemente permitir valores nulos.

Para columnas que aceptan nulos con una restricción y columnas no nulas con un valor predeterminado, consulta [Agregar restricciones a columnas](#adding-constraints-to-columns-including-not-null). En tablas más grandes, estas restricciones pueden bloquear la tabla y provocar tiempo de inactividad.

<div id="adding-columns-with-a-default">
  ### Agregar columnas con un valor predeterminado
</div>

Como ejecutamos Postgres >= 14 en producción, podemos agregar columnas con un valor predeterminado. Para hacerlo, en lugar de usar `default=<your_default>`, usa `db_default=<your_default>`. Esto le indica a Django que establezca un valor predeterminado a nivel de base de datos y lo gestione allí, en lugar de manejarlo en el código de la aplicación.

No podemos usar `default` porque el comportamiento predeterminado de Django al crear una columna nueva no nula con un valor predeterminado es peligroso. Al usar default, en la migración Django agregará el valor predeterminado para rellenar todos los campos y luego lo quitará de inmediato para poder gestionarlos en la capa de la aplicación. Esto significa que, durante un despliegue, la columna queda en producción sin un valor predeterminado hasta que se lance todo el código, lo que implica que las inserciones en esta tabla fallarán hasta que el despliegue termine.

<div id="adding-constraints-to-columns-including-not-null">
  ### Agregar restricciones a columnas (incluida NOT NULL)
</div>

Puede ser riesgoso agregar restricciones a columnas, ya sean nuevas o existentes, incluso si los datos de cada fila de la tabla no infringen la restricción. Esto se debe a que Postgres igual debe comprobar todas las filas antes de poder agregarla. En tablas pequeñas esto puede estar bien, ya que la comprobación será rápida, pero en tablas más grandes puede provocar tiempo de inactividad. Hay algunas opciones para hacerlo de forma segura:

```sql
ALTER TABLE tbl ADD CONSTRAINT cnstr CHECK (col IS NOT NULL) NOT VALID;  -- ejemplo de una restricción NOT NULL
ALTER TABLE tbl VALIDATE CONSTRAINT cnstr;
```

Una opción es crear la restricción como no válida y validarla después. Aun así, hay que escanear toda la tabla para validarla, pero solo necesitamos mantener un bloqueo `SHARE UPDATE EXCLUSIVE`, que únicamente bloquea otros comandos `ALTER TABLE` y permite que las lecturas y escrituras continúen. Esto funciona bien, aunque tiene una ligera penalización de rendimiento del 0,5–1 %. A partir de Postgres 12 podemos ampliar este método para añadir la restricción definitiva.

Como alternativa, si la tabla es lo suficientemente pequeña y de bajo volumen, debería ser seguro crear la restricción tal cual. “Pequeña” significa unos pocos millones de filas o menos.


<div id="altering-column-types">
  ### Modificar tipos de columnas
</div>

Modificar el tipo de una columna suele ser peligroso, ya que requerirá reescribir toda la tabla. Hay algunas excepciones:

- Cambiar un `varchar(<size>)` a un `varchar` con un tamaño mayor.
- Cambiar cualquier `varchar` a `text`.
- Cambiar un `numeric` a otro `numeric` donde la `precision` sea mayor pero la `scale` sea la misma.

Para cualquier otro tipo, lo más recomendable suele ser:

- Crear una columna con el nuevo tipo.
- Empezar a escribir en paralelo tanto en la columna antigua como en la nueva.
- Rellenar y convertir los valores de la columna antigua a la nueva.
- Cambiar el código para usar el nuevo campo.
- Dejar de escribir en la columna antigua y eliminar sus referencias en el código.
- Eliminar la columna antigua de la base de datos.

Por lo general, esto merece una conversación en #discuss-backend.

<div id="renaming-columns">
  ### Cambiar el nombre de columnas
</div>

Cambiar el nombre de columnas es arriesgado y provocará tiempo de inactividad. Esto ocurre porque durante el despliegue se ejecuta una mezcla de código antiguo y nuevo. Así que, en cuanto cambiemos el nombre de la columna en Postgres, el código antiguo empezará a fallar inmediatamente si intenta acceder a ella. Hay dos formas de manejar el cambio de nombre de una columna:

- No cambies el nombre de la columna en Postgres. En su lugar, cambia solo el nombre del campo en Django y usa `db_column` en la definición para señalar el nombre de la columna existente, de modo que nada se rompa. Este es el método preferido.
- Si de verdad quieres cambiar el nombre de la columna, los pasos serían:
  - Crear una columna con el nuevo nombre.
  - Empezar a escribir en paralelo tanto en la columna antigua como en la nueva.
  - Rellenar en la nueva columna los valores de la columna antigua.
  - Cambiar el campo para que empiece a leer desde la nueva columna.
  - Dejar de escribir en la columna antigua y eliminar sus referencias del código.
  - Eliminar la columna antigua de la base de datos.
  - En general, no compensa: supone mucho riesgo y esfuerzo para el beneficio que aporta.

<div id="siloed-database-management">
  ## Gestión de bases de datos en silos
</div>

La base de datos local para servidores en silos es independiente de la base de datos usada para operaciones monolíticas. Las bases de datos en silos se llaman `region` y `control`, en consonancia con los modos de silo. En Django, la conexión `default` corresponde a la base de datos de región y la conexión `control` a la base de datos `control`. Los mismos nombres de base de datos los usan tanto Sentry como Getsentry.

<div id="cloning-a-monolith-database">
  ### Clonación de una base de datos monolítica
</div>

```bash
# Copia los datos de tu aplicación existente en las bases de datos divididas.
bin/split-silo-database --database sentry --reset

# Cuando trabajes con getsentry, ejecuta lo siguiente desde el directorio raíz de getsentry
bin/split-silo-database --database getsentry --reset
```

Hay un script tanto en sentry como en getsentry que es funcionalmente equivalente. Si estás trabajando en getsentry, debes usar el script de getsentry para asegurarte de que todas tus tablas terminen en la base de datos segmentada correcta.

Los scripts `split-silo-database` usan anotaciones de silo en los modelos para volcar selectivamente tu base de datos monolítica en las bases de datos segmentadas.

Es posible que debas establecer `SENTRY_MONOLITH_REGION="us"` en tu configuración de sentry para poder actualizar correctamente los mapeos de la organización.


<div id="apply-migrations-to-siloed-databases">
  ### Aplicar migraciones a bases de datos aisladas
</div>

Tienes dos opciones para mantener bases de datos aisladas:

1. Ejecutar migraciones en tu base de datos monolítica y usar `split-silo-database` para reconstruir tus bases de datos aisladas.
2. Ejecutar migraciones para bases de datos aisladas.

Para ejecutar migraciones en las bases de datos aisladas, ejecútalas en modo región y en modo control.

```bash
# Ejecutar migraciones para el modo región
SENTRY_SILO_DEVSERVER=1 SENTRY_SILO_MODE=REGION SENTRY_REGION=us getsentry upgrade

# Ejecutar migraciones para el modo control
SENTRY_SILO_DEVSERVER=1 SENTRY_SILO_MODE=CONTROL getsentry upgrade
```


<div id="migration-deployment">
  ## Implementación de migraciones
</div>

<Alert title="Solo para empleados" level="warning">
  La siguiente sección trata la implementación de migraciones en los productos SaaS de Sentry.
</Alert>

Ofrecemos dos tipos de migraciones en nuestros despliegues SaaS:

- Migraciones en el momento del despliegue
- Migraciones posteriores al despliegue

<div id="deployment-migrations">
  ### Migraciones de despliegue
</div>

Las migraciones de despliegue se ejecutan en cada región y tenant antes de desplegar el código. Se espera que finalicen rápidamente y que todas las sentencias se completen en un máximo de 5 segundos. Si una migración pudiera tardar más porque se opera sobre un gran número de filas, debería realizarse como una migración posterior al despliegue. Las migraciones de despliegue son ideales para:

* Añadir nuevas tablas y columnas.
* Añadir índices a la mayoría de las tablas.
* Eliminar columnas y tablas, siempre que sigas los procesos descritos
  arriba.

<div id="post-deploy-migrations-is_post_deployment">
  ### Migraciones posteriores al despliegue (is_post_deployment)
</div>

Las migraciones posteriores al despliegue las ejecutan manualmente los ingenieros **después** de que una migración se haya desplegado **en todas** las regiones. Durante el despliegue, estas migraciones se marcan como completadas (simuladas) mediante el comportamiento de migraciones simuladas de Django. Cuando se ejecuta una migración posterior al despliegue, se aplica a todas las regiones y a todos los tenants. Las migraciones posteriores al despliegue se inician manualmente por parte de los ingenieros.

Las migraciones posteriores al despliegue son ideales para:

* Agregar índices a tablas grandes, cuando agregar el índice tarde más de
  10 segundos en cualquier región.
* Realizar backfills de datos o mutaciones en tablas con más de 50.000 filas.

Las migraciones posteriores al despliegue **no deben** usarse para:

* Agregar, eliminar o cambiar el nombre de columnas.
* Crear tablas.

Usar migraciones posteriores al despliegue para estas operaciones provocará una caída del servicio.

<div id="running-post-deploy-migrations">
  ### Ejecución de migraciones post-deploy
</div>

Las migraciones post-deploy (tanto de datos como de esquema) ahora se ejecutan a través de un [pipeline de GoCD](https://deploy.getsentry.net/go/pipelines?viewName=Default#!/) llamado
`post-deploy-migrations`.

Para ejecutar una migración post-deploy, primero ubica el `post-deploy-migrations job`. Haz clic en el botón de reproducir:

![tarea post-deploy](./img/post-deploy-pipeline-tile.png)

En `Materials`, ingresa el SHA de getsentry desde el que quieres ejecutar las migraciones. El SHA que elijas debe ser uno que contenga la migración y que haya sido desplegado en todas las regiones.

![materiales de la migración post-deploy](./img/post-deploy-pipeline-materials.png)

Luego haz clic en `Environment Variables` y completa un valor para `django_app` y `django_migration`. `django_app` debe coincidir con el nombre de la app que contiene la migración, p. ej., `sentry`, `getsentry`. A continuación, ingresa el nombre de la migración a ejecutar, p. ej., `0233_pickle_to_json_admin_auditlogentry`.

![variables de la migración post-deploy](./img/post-deploy-pipeline-variables.png)

<div id="cancelling-a-post-deploy-migration">
  ### Cancelar una migración posterior al despliegue
</div>

Solo cancela la etapa de GoCD.

No tenemos herramientas para deshacer migraciones, así que, por lo general, creamos otra migración que revierta la que queremos deshacer y la ejecutamos.

<div id="cancelling-a-ddlschema-migration">
  ### Cancelar una migración de DDL/esquema
</div>

GoCD no siempre podrá detener una consulta de larga duración; en ese caso, necesitaremos localizar la consulta en `pg_stat_activity` y terminarla con `pg_terminate_backend(pid)`. Esto requerirá la asistencia de SRE.
---
title: "Feature Flags"
sidebar_order: 30
---

Las feature flags se definen en el código de Sentry (busca `SENTRY_FEATURES` en
[`server.py`](https://github.com/getsentry/sentry/blob/master/src/sentry/conf/server.py)).
Para usuarios con despliegues self-hosted, esas flags se configuran mediante `sentry.conf.py`.
En el despliegue SaaS de Sentry, se usa Options Automator para configurar las flags en producción.

Puedes encontrar una lista de las funcionalidades disponibles en estos dos archivos:

* `sentry/features/permanent.py` - Funcionalidades normalmente gestionadas por suscripciones de sentry.io
* `sentry/features/temporary.py` - Funcionalidades usadas durante el desarrollo con la intención de ser eliminadas

Se definen en el `FeatureManager` de la siguiente manera:

```python
# pasa FeatureHandlerStrategy.FLAGPOLE para usar nuestro sistema de feature flags basado en opciones:
manager.add("organizations:onboarding", OrganizationFeature, FeatureHandlerStrategy.FLAGPOLE)

# pasa FeatureHandlerStrategy.INTERNAL si no planeas usar el automatizador de opciones:
manager.add("organizations:onboarding", OrganizationFeature, FeatureHandlerStrategy.INTERNAL)
```

La función puede habilitarse con lo siguiente en tu `sentry.conf.py`, generalmente ubicado en `~/.sentry/`:

```python
SENTRY_FEATURES["organizations:onboarding"] = True
```

Puedes modificar el estado de los [feature flags en las pruebas](/es/development/testing/#setting-options-and-feature-flags) usando un gestor de contexto.

En general, conviene que los nombres de tus funcionalidades sean únicos para facilitar su
[eliminación](#after-launch-graduation). Por ejemplo, un feature flag como `trends`
puede ser difícil de encontrar porque `trends` puede aparecer en todo el código.
En cambio, un nombre como `performance-trends-view` es más probable que sea único y más fácil
de eliminar más adelante

<div id="creating-a-new-feature-flag">
  ## Creación de un nuevo feature flag
</div>

<div id="determine-what-scope-the-feature-should-have">
  ### Determina el alcance que debería tener la función
</div>

Las funciones pueden tener alcance a nivel de organización y de proyecto. Si no estás seguro
de querer una función a nivel de proyecto, crea una a nivel de organización. En este ejemplo,
crearemos una función llamada `test-feature` con alcance a nivel de *organización*.

<div id="determine-the-permanency-of-your-feature">
  ### Determina la permanencia de tu funcionalidad
</div>

Normalmente usamos flags de funcionalidades para el desarrollo. Por lo general, [están pensadas para retirarse](#after-launch-graduation). Las únicas excepciones son los flags permanentes que controlan
[funcionalidades específicas del plan de suscripción](#plan-specific-features)
en GetSentry.

La mayoría de los flags de funcionalidades de Sentry se colocan en `temporary.py`, mientras que los flags permanentes de Sentry están en
`permanent.py`.

Los flags exclusivos de GetSentry normalmente se colocan en [`features.py`](https://github.com/getsentry/getsentry/blob/master/getsentry/features.py).

<div id="determine-whether-your-feature-needs-to-be-exposed-in-the-api">
  ### Determina si tu feature necesita exponerse en la API
</div>

Si planeas usar tu feature en el frontend, debes establecer
`api_expose=True` al agregarla. Los features que tengan `api_expose`
se incluirán en los resultados de la respuesta de detalles de la organización.

<div id="add-your-feature-to-the-featuremanager">
  ### Agrega tu funcionalidad a FeatureManager
</div>

Si quieres gestionar tu feature flag mediante opciones, puedes hacerlo con la biblioteca [Flagpole](/es/backend/feature-flags/flagpole/)
añadiendo la funcionalidad a `FeatureManager` y estableciendo el enum `FLAGPOLE` como la estrategia de la funcionalidad:

```python
default_manager.add('organizations:test-feature', OrganizationFeature, FeatureHandlerStrategy.FLAGPOLE, api_expose=True)
```

Al definir una funcionalidad, también puedes establecer el estado predeterminado del feature flag.
Si no se proporciona un valor predeterminado, se usará `False`.

```python
# Ejemplo de un conjunto de características con un valor predeterminado de True
default_manager.add('organizations:test-feature', OrganizationFeature, FeatureHandlerStrategy.FLAGPOLE, default=True, api_expose=True)
```

Si no piensas usar Flagpole, utiliza `FeatureHandlerStrategy.INTERNAL` con un manejador de funciones personalizado; por ejemplo:

```python
default_manager.add('organizations:test-feature', OrganizationFeature, FeatureHandlerStrategy.INTERNAL)
```

<div id="add-it-to-the-organization-model-serializer">
  ### Añádelo al serializador del modelo Organization
</div>

El serializador del modelo Organization
(`src/sentry/api/serializers/models/organization.py`) construye una lista
llamada `feature_list` que se entrega al front‑end. De forma predeterminada, se revisan todas las funciones de la organización y las que están disponibles se agregan a la lista. Si tu función requiere lógica personalizada adicional, tendrás que actualizar el serializador de la organización para comprobarla e incluirla manualmente.

<div id="using-model-flags-less-common">
  ### Uso de flags del modelo (menos común)
</div>

A veces se usa un flag en el modelo para indicar un feature flag, como se muestra
a continuación. Esto no se recomienda a menos que exista una razón específica para hacer
cambios en el modelo. Por ejemplo, el flag `require_2fa` afecta el comportamiento del
backend para exigir la autenticación de dos factores.

```python
feature_list = []

if getattr(obj.flags, 'allow_joinleave'):
    feature_list.append('open-membership')
if not getattr(obj.flags, 'disable_shared_issues'):
    feature_list.append('shared-issues')
if getattr(obj.flags, 'require_2fa'):
    feature_list.append('require-2fa')
```

<div id="checking-your-feature">
  ## Comprobando tu función
</div>

<div id="in-python-code">
  ### En código Python
</div>

El método `has` de FeatureManager comprueba si la característica existe. El método `has`
recibe el nombre de la característica, los objetos que corresponden al alcance de
la característica *(es decir, una organización para una característica a nivel de organización o
un proyecto para una característica a nivel de proyecto)* y el actor (también llamado usuario). Aquí tienes un ejemplo
de comprobación de característica de Organization:

```python
if features.has('organizations:test-feature', obj, actor=user):
    feature_list.append('test-feature')
```

El código de ejemplo solo añade la función a `feature_list` si esa función está habilitada para
la organización y el tipo de usuario indicado. Ten en cuenta que cuando pasamos la función
al frontend, quitamos el prefijo de alcance y
`'organizations:test-feature'` se convierte en `'test-feature'`.

<div id="in-javascript">
  ### En JavaScript
</div>

Para verificar una bandera de características en JavaScript, esta debe tener
`api_expose=True`.

<div id="declarative-features-with-the-feature-component">
  ### Funcionalidades declarativas con el componente Feature
</div>

React utiliza un paradigma de programación declarativo. Por ello, contamos con un componente de utilidad
que usamos para ocultar componentes en función de las flags de funcionalidades disponibles para
una organización o proyecto

```jsx
import Feature from 'sentry/components/acl/feature';

const toRender = (
  <Feature features={['test-feature']}>
    <MyComponentToFlag />
  </Feature>
);
```

<div id="imperative-feature-flag-checks">
  ### Comprobaciones imperativas de feature flags
</div>

Hay algunas excepciones cuando los componentes de React se generan de forma imperativa (p. ej., encabezados/columnas para tablas). En casos como este, los objetos `Organization` y `Project` incluyen un array de feature flags que puedes usar de la siguiente manera:

```jsx
const {organization} = this.props;

// Method 2
organization.features.includes('test-feature'); // evalúa a Verdadero/Falso
```

<div id="enabling-features-in-development">
  ## Habilitar funciones en desarrollo
</div>

En Sentry puedes ejecutar `sentry devserver` para ver tus cambios en modo de
desarrollo. Si quieres ver un cambio controlado por un feature flag, tendrás que
abrir el archivo `~/.sentry/sentry.conf.py` en tu máquina local. Este archivo
contiene tu configuración local de la aplicación Sentry y puede verse y
editarse. Si quieres activar o desactivar un flag, agrega esto a tu archivo
de configuración:

```python
SENTRY_FEATURES['organizations:test-feature'] = True
```

Como alternativa, puedes probar las funcionalidades de Flagpole configurando opciones personalizadas de manera local.
Consulta la documentación de [Flagpole Local Development](/es/backend/feature-flags/flagpole/#testing-a-flagpole-feature-locally) para obtener más información.

<div id="enabling-your-feature-in-production">
  ## Activar tu funcionalidad en producción
</div>

Las flags de funcionalidades (feature flags) se declaran en el repositorio de código de Sentry. Para los usuarios autogestionados (self-hosted), esas flags se configuran a través de `sentry.conf.py`. En el despliegue SaaS de Sentry,
puedes elegir entre usar un despliegue controlado por opciones mediante Options Automator con Flagpole
o escribir un controlador de feature flags personalizado.

[Flagpole](/es/backend/feature-flags/flagpole/) es la biblioteca interna de gestión de feature flags de Sentry, que permite definir en YAML, dentro de Options Automator, una funcionalidad con múltiples segmentos objetivo y filtros de condición.

<div id="after-launch-graduation">
  ## Después del lanzamiento (graduación)
</div>

Una vez que tu funcionalidad se haya incorporado a la rama principal y esté disponible para todos los clientes en
sentry.io, tienes algunas posibles opciones:

* Si la funcionalidad no se puede desactivar, o no necesitas desactivarla de forma condicional,
  elimina el feature flag y todas las comprobaciones relacionadas del código base de Sentry.
  Si es necesario, también elimina las referencias a la funcionalidad en los repositorios
  [self-hosted](https://github.com/getsentry/self-hosted), getsentry y
  options-automator.
* Si la funcionalidad solo estará disponible para clientes SaaS en planes específicos,
  debes agregar tu feature flag a los planes correspondientes y actualizar los
  manejadores de funcionalidades (ver abajo). También deberías mover el feature flag de
  `temporary.py` a `permanent.py` y actualizar el valor predeterminado para habilitar la
  funcionalidad en instancias self-hosted.

<div id="getsentry-feature-handlers">
  ## Manejadores de funciones de Getsentry
</div>

Getsentry incluye una variedad de manejadores de funciones que reemplazan el mapa `SENTRY_FEATURES`, definidos en el archivo [`features.py`](https://github.com/getsentry/getsentry/blob/master/getsentry/features.py).

<div id="plan-specific-features">
  ### Funcionalidades específicas del plan
</div>

Si tu funcionalidad está disponible para un subconjunto de planes (p. ej., solo en planes Business),
debes:

1. Deshabilitar la funcionalidad en `getsentry/conf/settings/defaults.py` actualizando `SENTRY_FEATURES`.
2. Agregar la funcionalidad a la lista de funcionalidades del plan correspondiente.
3. Actualizar `SubscriptionPlanFeatureHandler` para gestionar la funcionalidad.

<div id="custom-handlers">
  ### Controladores personalizados
</div>

Si tu función requiere lógica adicional para activarse, también puedes
implementar un controlador de función en getsentry. Por ejemplo, puedes crear un feature flag respaldado por [options](/es/backend/options/). Sigue estos pasos:

1. Desactiva la función en `getsentry/conf/settings/defaults.py` actualizando `SENTRY_FEATURES`.
2. Agrega una nueva clase de controlador de función en `getsentry/features.py` que determine la disponibilidad de la función según la organización o el actor.
3. Registra el controlador al final de `getsentry/features.py`.
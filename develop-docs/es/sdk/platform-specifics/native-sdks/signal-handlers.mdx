---
title: Manejadores de señales
sidebar_order: 40
---

Los SDK nativos de Sentry, como [sentry-native](https://github.com/getsentry/sentry-native) y [sentry-cocoa](https://github.com/getsentry/sentry-cocoa/), tienen que trabajar con manejadores de señales para interceptar los procesos antes de que fallen.
Esto se aplica tanto a los SDK móviles como al SDK nativo. Dado que los manejadores de señales son notoriamente difíciles de manejar y las restricciones que tenemos son bastante limitantes, tenemos que doblar parcialmente las reglas de lo aceptable.

<div id="general-risks">
  ## Riesgos generales
</div>

Los riesgos generales con los manejadores de señales provienen de su naturaleza interruptiva:

* interrumpen código que ya se está ejecutando, lo que significa que el estado del
  entorno no es seguro.
* necesitan algo de espacio de pila para operar, pero podrían invocarse cuando nos
  estamos quedando sin pila.
* puede que otro código también dependa de ese manejador de señales y probablemente queramos invocar
  esos también.

En POSIX, los manejadores de señales están muy restringidos en cuanto a lo que es aceptable. En
teoría solo puedes llamar a [funciones seguras para ejecución asíncrona](https://man7.org/linux/man-pages/man7/signal-safety.7.html),
lo que por desgracia impone muchas limitaciones. En particular, ni siquiera
son posibles las asignaciones de memoria, y mucho menos la mayoría de las funciones relacionadas con hilos.

<div id="basic-recommendations">
  ## Recomendaciones básicas
</div>

Queremos optimizar nuestros resultados para obtener buenos informes de fallos y, en general, para obtener informes de fallos. No necesariamente optimizamos para evitar fallos si fallamos después de haber conseguido registrar un informe. Esto significa que consideramos aceptable que nuestro código de gestión de fallos falle después de haber creado correctamente un informe en disco, aunque queremos evitarlo cuando no sea necesario.

Así, el mayor riesgo es crear una situación de bloqueo en la que impidamos que la aplicación se cierre correctamente y quede colgada tras el fallo. Esto es menos preocupante en móviles, donde el sistema operativo terminará una aplicación colgada, pero sí es una preocupación en otros contextos como entornos de escritorio o de servidor.

Los informes de fallos, por lo general, deben persistirse en disco y subirse más adelante. Esto puede suceder desde un hilo ya en ejecución, como intentamos en Android, o al reiniciar la aplicación.

Esto implica que el controlador asíncrono debería priorizar volcar los datos del fallo a disco con prioridad reducida. Si, por ejemplo, solo podemos recopilar información auxiliar asumiendo el riesgo de fallar en el propio controlador de fallos, esa información debería extraerse y volcarse después de que se haya creado el rastro de pila.

<div id="memory-allocation">
  ## Asignación de memoria
</div>

Se recomienda que las bibliotecas utilicen funciones de asignación personalizadas que, en condiciones normales, usen `malloc`, pero que, una vez que se haya entrado en una situación de fallo y se esté en el controlador de señales, cambien a un asignador de tipo bump. Esto es necesario porque `malloc` puede (¡y de hecho lo hará!) mantener un bloqueo al entrar en un controlador de señales, lo que puede llevar a un interbloqueo o a un bloqueo del proceso.

<div id="locks-and-signal-handler-marking">
  ## Bloqueos y marcado del manejador de señales
</div>

Otro problema es que, por lo general, no podemos usar correctamente los bloqueos una vez dentro de los manejadores de señales. La forma en que el SDK nativo aborda esta situación es usar un spinlock y marcar cuándo estamos en el manejador de señales. De ese modo, el código genérico que quiera esperar a un bloqueo real puede, o bien bloquearse adicionalmente en el spinlock, o bien continuar en silencio si está en el mismo hilo que el manejador de señales.

<div id="writing-files">
  ## Escritura de archivos
</div>

Para escribir archivos no se debe usar la familia de funciones `fwrite`, ya que
no son seguras en contextos asíncronos. En su lugar, usa las funciones subyacentes `write` y `open`.
---
title: Trazas en el navegador
description: >-
  Aspectos interesantes del trazado y la instrumentación de rendimiento en los
  SDK para navegadores.
sidebar_order: 10
og_image: /og-images/sdk-platform-specifics-javascript-sdks-browser-tracing.png
---

El comportamiento de trazado en nuestros SDK para navegadores es algo particular y difiere significativamente del trazado en el backend. Esta página reúne los aspectos más importantes.

<Alert>
  Los aspectos descritos en este documento se aplican a todos los SDK para
  navegadores. Esto incluye `@sentry/browser` y todos los SDK basados en él,
  como `@sentry/react`, `@sentry/angular` o `@sentry/vue`, así como las partes
  del lado del cliente de meta‑frameworks como `@sentry/nextjs`.
</Alert>

Ten en cuenta que cualquier tipo de instrumentación de trazado automática en el navegador requiere añadir `browserTracingIntegration()` a la configuración del SDK.
La configuración predeterminada del SDK no incluye instrumentación de rendimiento ni de trazado para ahorrar [tamaño de bundle](../bundle-size) a los usuarios que solo registran errores.

<div id="pageload-and-navigation-spans">
  ## Spans de carga de página y navegación
</div>

Los SDK de navegador crean automáticamente spans para la carga inicial de la página y para las [navegaciones suaves](#navigation-spans) posteriores.

Sin embargo, estos spans no se comportan como los convencionales. Los llamamos **spans inactivos** porque se inician en algún momento (más sobre esto más adelante), pero no se terminan explícitamente.
En su lugar, usamos varias heurísticas y parámetros para aplicar un mecanismo de “debounce” y finalizar los spans automáticamente.
Por ejemplo, finalizamos un span inactivo tras un periodo de inactividad, es decir, cuando no se agregan nuevos spans al árbol de spans.
Además, existen parámetros de tiempo de espera máximo.
Este mecanismo de inactividad es necesario porque ni en la carga de página ni en la navegación hay un punto final claro o un evento para finalizar explícitamente el span.

Es importante entender cómo termina un span inactivo para interpretar su duración de forma sensata:

- Al finalizar el span inactivo, acortamos su duración hasta el último span hijo que haya terminado.
- A veces, los spans hijo que intuitivamente no asociarías con la carga inicial pueden iniciarse lo bastante cerca del final esperado del span inactivo como para retrasar su finalización con el “debounce”.
- En algunos casos, el final del span inactivo puede posponerse tantas veces que se alcanza su duración máxima.
  En ese punto se finaliza de forma “forzada”.

Por lo tanto, la duración del span inactivo no representa de manera fiable el tiempo real que tomó una carga de página o una navegación.
También es importante tener presente esta limitación en la interfaz del producto para evitar calcular puntuaciones de rendimiento o alertas basadas en la duración del span inactivo.

Tanto los spans de carga de página como los de navegación **siempre se inician como spans raíz**.

<div id="pageload-spans">
  ### Spans de carga de página
</div>

El span de carga de página se inicia cuando se inicializa el SDK; más específicamente, cuando se invoca el hook `afterAllSetup` de `browserTracingIntegration`. Esto garantiza que iniciemos el span de carga de página lo antes posible. Sin embargo, esto sigue significando que el span solo se inicia una vez que el código del SDK llega al navegador. En realidad, la carga de la página comienza cuando el navegador hace la solicitud de la URL al servidor. Para tenerlo en cuenta, retroactivamente antedatamos la hora de inicio del span de carga de página a la hora de inicio de la solicitud del navegador. Podemos antedatar la hora de inicio porque el navegador proporciona esta información de temporización.

El span de carga de página termina, como muy pronto, cuando el navegador emite `'interactive'` o `'complete'` en `WINDOW.document.readyState`. Puede prolongarse considerablemente por nuestra instrumentación al agregar spans secundarios adicionales al span raíz de carga de página.

![Pageload Span](pageload-span.png)

Un span de carga de página:

- Siempre tiene el atributo `sentry.op: 'pageload'`
- Siempre es un span raíz
- [Continúa un trace](#trace-continuation) capturado de etiquetas `<meta>` en la respuesta HTML inicial o, si no se detectan etiquetas, inicia un trace nuevo.
- Contiene varios spans con operaciones específicas que creamos retroactivamente a partir de entradas de la Performance API del navegador (ver imagen para spans de ejemplo):
  1. `browser` - información sobre el ciclo de vida de la solicitud de carga de página (tipo de entrada `navigation`).
  2. `resource.*` - información de temporización de recursos que indica cuánto tardaron en cargarse imágenes, archivos CSS, JS, etc.
  3. `measure` - mediciones de tiempo personalizadas. Algunas las establece nuestro SDK, otras los usuarios del SDK o terceros y algunas el navegador.
  4. `mark` - marcadores de tiempo personalizados. Algunos los establece nuestro SDK, otros los usuarios del SDK o terceros y algunos el navegador.
  5. `paint` - información de temporización de renderizado.
  6. `ui.long-animation-frame` - un span que muestra la duración de un evento de fotograma de animación largo detectado por el navegador.
- Contiene [web vitals](#web-vitals) como mediciones.
- Puede contener spans secundarios creados por otras instrumentaciones (p. ej., spans `http.client`) o spans creados manualmente.

Dado que el span de carga de página se inicia automáticamente al inicializar el SDK, **solo hay un span de carga de página** durante el ciclo de vida del SDK.

<div id="navigation-spans">
  ### Intervalos de navegación
</div>

Los intervalos de navegación se inician cuando ocurre una "navegación suave".
Una "navegación suave" significa que la URL o el estado del historial de la página cambian **sin** recargar la página completa.
Un ejemplo típico de navegación suave es una aplicación de una sola página (SPA) que usa un enrutador del lado del cliente (por ejemplo, React Router o el router de Angular).
Aunque las navegaciones en las SPA pueden parecer una navegación de página normal para los usuarios, no desencadenan una carga completa de la página.
En su lugar, normalmente actualizan dinámicamente el estado del historial del navegador, la URL y el contenido de la página.

De forma predeterminada, en `@sentry/browser` el SDK escucha la API `History` del navegador para detectar dichas navegaciones.
[SDK específicos de frameworks e instrumentaciones de enrutadores](#router-instrumentations-and-route-parameterization) pueden usar otros mecanismos para detectarlas.

Al igual que un intervalo de carga de página, los intervalos de navegación son intervalos inactivos y finalizan por sí mismos tras un cierto tiempo de inactividad o al alcanzar una duración máxima.

A diferencia de los intervalos de carga de página, los intervalos de navegación no incluyen mediciones de Web Vitals. Más información sobre el motivo [aquí](#web-vitals).

<div id="router-instrumentations-and-route-parameterization">
  ### Instrumentaciones del router y parametrización de rutas
</div>

Algunos frameworks como React, Angular o Vue tienen sus propias soluciones de enrutamiento en el navegador (p. ej., Angular Router).
Por ello, la mayoría de nuestros SDK de frameworks proporcionan su propia `browserTracingIntegration`, que instrumenta este router para mejorar la calidad de los spans de carga de página y de navegación.

La instrumentación del router nos permite:

1. Conectarnos directamente al router para detectar navegaciones e iniciar spans de navegación. Según el framework, esto es más versátil que escuchar la API de history.
2. Extraer nombres de rutas parametrizadas; es decir, podemos mostrar y agrupar spans por la ruta real en lugar de URLs sin procesar individuales (p. ej., `/users/[id]` en lugar de `/users/12345`).
3. Según la instrumentación, extraer parámetros de ruta o redirecciones y añadirlos de forma controlada a los datos del span.

<div id="web-vitals">
  ## Web Vitals
</div>

Los SDK del navegador capturan automáticamente las Web Vitals durante la carga inicial de la aplicación web.
Este documento no explicará qué son las Web Vitals, pero puedes encontrar más información en el [sitio web de Web Vitals](https://web.dev/vitals/).

Nuestro objetivo es capturar las Web Vitals de la misma manera que, por ejemplo, Google Analytics, los indexadores del buscador de Google, Lighthouse o la extensión de Chrome de Web Vitals.
A veces hay discrepancias entre los valores que capturamos y los que capturan otras herramientas porque estas no están sujetas a las mismas restricciones que nosotros a la hora de definir el final de la carga de una página.

En términos generales, la mayoría de las Web Vitals se acumulan mientras el span de carga de página está activo y se capturan cuando _finalizamos_ ese span. Esto funciona bien para las métricas que se estabilizan muy temprano en el ciclo de vida, pero
provoca discrepancias en las métricas que siguen cambiando después de que termina el span de carga de página. Este es el caso de `LCP` y `CLS` en particular.

<Alert>
  En el momento de escribir esto, estamos pasando a una [técnica de
  captura de `LCP` y `CLS` más
  sofisticada](https://github.com/getsentry/sentry-javascript/issues/12714) que
  debería mejorar la precisión de estas métricas. Básicamente funcionará como
  funciona hoy la recopilación de `INP`.
</Alert>

<div id="interaction-to-next-paint-inp">
  ### Interaction To Next Paint (INP)
</div>

La métrica web vital Interaction To Next Paint (INP) se maneja de forma un poco diferente.
No está vinculada al span de carga de la página.
En su lugar, escuchamos cuando el navegador emite eventos de INP (por ejemplo, al ocultar la página al cambiar de pestaña) y los capturamos como spans independientes.

<div id="tracing-model">
  ## Modelo de trazas
</div>

Con la versión 8 de los SDK de JS, los SDK del navegador adoptaron un nuevo modelo de vida útil de las trazas.
Con este nuevo modelo, las trazas abarcan toda la duración de una página o ruta.
Esto significa que se crea un id de traza en la carga inicial de la página y se utiliza para todos los eventos posteriores hasta que el usuario navega a otra página o recarga.
En las aplicaciones de una sola página (SPA) que usan algún tipo de enrutamiento, el id de traza se utiliza durante toda la duración de una ruta y cambia en una navegación suave.

![Vida útil de la traza](page-based-traces.png)

Este modelo de trazas tiene un par de consecuencias importantes de entender:

- **Más contexto**: Empecemos por lo bueno: dado que el id de traza se mantiene constante para todos los eventos en una página o ruta, todos los eventos dentro de una página o ruta pertenecen a la misma traza.
  Esto facilita entender qué ocurrió antes del error o del evento de span que los usuarios están viendo.
- **Múltiples spans raíz**: Una traza puede tener múltiples spans o eventos raíz. Por ejemplo, si los usuarios habilitan spans de interacción o crean spans manualmente, se asociarán con el mismo id de traza de la carga de página o navegación previa.
- **Gestión de cuota**: Dado que el estado de la traza no cambia a lo largo de una sola página o ruta, la decisión de muestreo del span inicial se mantiene para todos los eventos posteriores. Esto significa que la decisión de muestreo solo se toma una vez por página o ruta y no se reevalúa para cada evento. Además, las solicitudes HTTP posteriores (`fetch` o `XMLHttpRequest`) también propagan esta decisión de muestreo a posibles servicios downstream. Esto puede dar lugar a que se envíe un mayor número de eventos a Sentry que antes.
- **Trazas de larga duración**: No todas las aplicaciones web incluyen navegaciones (duras o suaves). En páginas donde los usuarios simplemente permanecen en una sola página sin navegar (p. ej., una aplicación de chat), el id de traza permanecerá constante durante todo el recorrido del usuario. Esto puede dar lugar a trazas de muy larga duración que potencialmente pueden crecer mucho.

<Alert>

Como se describió arriba, algunas de las consecuencias tienen implicaciones negativas para el producto o la UX.
Es un problema conocido y estamos trabajando en una actualización del modelo de vida útil de la traza para abordar estas cuestiones.
Sin embargo, es un tema complejo y aún estamos evaluando la mejor solución.

</Alert>

<div id="trace-propagation">
  ## Propagación de trazas
</div>

Los SDK de JS para navegador propagan las trazas como otros SDK, añadiendo encabezados a las solicitudes salientes realizadas con las API `fetch` o `XmlHttpRequest`.
Sin embargo, no podemos añadir estos encabezados a todas las solicitudes por defecto, ya que los servicios de destino podrían devolver errores si sus políticas de CORS no permiten encabezados arbitrarios.
Por lo tanto, los SDK de navegador solo añaden encabezados a solicitudes del mismo origen de forma predeterminada. Para habilitar el rastreo entre orígenes, los usuarios deben configurar la opción `tracePropagationTargets` en la configuración del SDK.

<div id="trace-continuation">
  ## Continuación de la traza
</div>

Los SDK del navegador pueden continuar una traza que se inició en el servidor cuando se entrega la respuesta de la página HTML inicial.
Para que esto funcione, el SDK del lado del servidor debe insertar etiquetas `<meta>` que contengan los datos de trazado `sentry-trace` y `baggage` en la respuesta HTML.
Estas etiquetas meta son detectadas por los SDK del navegador durante la inicialización (`Sentry.init`).

<div id="tracing-without-performance">
  ## Trazas sin rendimiento
</div>

Los SDK del navegador admiten trazas sin rendimiento (TwP).
TwP significa que el SDK añade encabezados de trazado a las solicitudes salientes, pero no inicia ni envía ningún span.
Esta función permite vincular errores del frontend con el backend en la interfaz sin agotar la cuota de spans de los usuarios.

Mientras que en otros SDK, TwP se activa de forma predeterminada cuando no se configuran `tracesSampleRate` ni `tracesSampler`, en el navegador los usuarios aún deben agregar `browserTracingIntegration`.
La razón es que nuestra instrumentación de fetch y XHR no está incluida en el paquete predeterminado del SDK para ahorrar [tamaño de paquete](../bundle-size).
Así que la única configuración para habilitar TwP es registrar `browserTracingIntegration` pero omitir por completo las opciones de muestreo (o establecerlas en `undefined`).

El modo TwP utiliza el mismo [modelo de trazado](#tracing-model) que los SDK configurados para el trazado normal.
---
title: Descripción general
description: A continuación encontrarás una guía para implementar un nuevo SDK de Sentry. Incluye el protocolo para el envío de eventos y pautas sobre cómo deberían verse y comportarse normalmente los clientes.
sidebar_order: 1
---

<div id="writing-an-sdk">
  ## Escribir un SDK
</div>

En esencia, un SDK es un conjunto de utilidades para capturar datos sobre un estado excepcional en una aplicación. Con estos datos, construye y envía una carga útil JSON al servidor de Sentry.

Se espera lo siguiente de los SDK listos para producción:

* Configuración de DSN
* Fallos controlados (p. ej., el servidor de Sentry no es accesible)
* Configuración de atributos (p. ej., etiquetas y datos adicionales)
* Compatibilidad con Linux, Windows y OS X (cuando corresponda)

Se requiere compatibilidad basada en características para lo siguiente:

* Si hay datos de cookies disponibles, no se envían de forma predeterminada
* Si hay datos de POST disponibles, no se envían de forma predeterminada

Además, se recomiendan encarecidamente las siguientes características:

* Captura automática de errores (p. ej., controladores de excepciones no capturadas)
* Integración con frameworks de logging
* Envío de eventos no bloqueante
* Utilidades de datos de contexto (p. ej., establecer el usuario actual, registrar breadcrumbs)
* Muestreo de eventos
* Respetar las cabeceras HTTP de <Link to="/sdk/expected-features/rate-limiting/">limitación de velocidad</Link> de Sentry
* Hooks de envío de eventos previos y posteriores
* Valores de variables locales en el rastreo de pila (en plataformas donde sea posible)
* Enviar un `environment` en cada evento. Si no se detectó ninguno o no fue establecido por el usuario, se debe usar `production`.

Consulta la <Link to="/sdk/expected-features#features">página de funciones esperadas</Link> para descripciones de funciones comunes de los SDK de Sentry.

<div id="usage-for-end-users">
  ## Uso para usuarios finales
</div>

En general, el uso de un SDK consta de tres pasos para el usuario final, que deberían verse casi idénticos sin importar el lenguaje:

1. Inicialización del SDK (a veces esto está oculto para el usuario):

   ```javascript
   Sentry.init({dsn: '___PROJECT.DSN___'});
   ```

   ```python
   sentry_sdk.init('___PROJECT.DSN___')
   ```

2. Captura de un evento:

   ```javascript
   var resultId = Sentry.captureException(myException);
   ```

   ```python
   result_id = sentry_sdk.capture_exception(my_exception);
   ```

3. Uso del resultado de la captura del evento:

   ```javascript
   alert(`Your exception was recorded as ${resultId}`);
   ```

   ```python
   print('Your exception was recorded as %s', result_id);
   ```

Idealmente, `init` permite varios métodos de configuración. El primer argumento siempre debe ser el valor del DSN (si es posible):

```javascript
Sentry.init({
    'dsn': '___PROJECT.DSN___',
    'foo': 'bar'
})
```

<Alert title="Nota">
  Los SDK deben aceptar un DSN vacío como configuración válida.

  Si un SDK no se inicializa o si se inicializa con un DSN vacío, no debe enviar ningún dato por la red, como excepciones capturadas.
  Según la plataforma, el SDK puede evitar realizar trabajo de inicialización innecesario y reducir su huella en tiempo de ejecución al mínimo.
</Alert>

Además, deberías proporcionar funciones globales que permitan capturar
un mensaje básico o una excepción:

* `Sentry.captureMessage(message)`
* `Sentry.captureException(exception)`

<div id="parsing-the-dsn">
  ## Análisis del DSN
</div>

Se recomienda que los SDK permitan opciones arbitrarias a través del constructor, pero deben aceptar que el primer argumento sea una cadena DSN. Esta cadena contiene lo siguiente:

```
'{PROTOCOL}://{PUBLIC_KEY}:{SECRET_KEY}@{HOST}{PATH}/{PROJECT_ID}'
```

El endpoint final al que enviarás solicitudes se construye de la siguiente manera:

```
 {BASE_URI} = '{PROTOCOL}://{HOST}{PATH}'

'{BASE_URI}/api/{PROJECT_ID}/{ENDPOINT}/'
```

Dentro del segmento `HOST` encontrarás el dominio de ingesta de tu organización.
Para una instancia autogestionada, este será el host base de tu instancia, y para
sentry.io contendrá un host con el patrón
`o{orgid}.ingest.{region}.sentry.io`. Para cuentas en Estados Unidos,
`o{orgid}.ingest.sentry.io` también funcionará.

<Alert title="Nota" level="warning">
  Todos los segmentos, incluido PROJECT&#95;ID, son de tipo String.
</Alert>

Sentry proporciona los siguientes endpoints:

* <Link to="/sdk/data-model/envelopes">/envelope/</Link> para cualquier envío que use Envelopes.
* [`/minidump/`](https://docs.sentry.io/platforms/native/minidump/) para solicitudes multiparte que contienen minidumps.
* [`/unreal/`](https://docs.sentry.io/platforms/unreal/configuration/setup-crashreporter/) para informes de fallos de
  Unreal Engine 4.
* [`/playstation/`](https://docs.sentry.io/platforms/playstation/) para informes de fallos de PlayStation.
  <Alert title="Nota" level="info">
    El endpoint de PlayStation tiene acceso limitado y requiere allowlisting. La asistencia implica componentes que forman parte de una colaboración con Sony que no pueden hacerse públicos ni redistribuirse. Este endpoint solo está disponible en SaaS.
  </Alert>
* [`/security/`](https://docs.sentry.io/error-reporting/security-policy-reporting/) para informes
  CSP del navegador, que normalmente se configuran en el navegador en lugar de un SDK.

Consulta los endpoints correspondientes para obtener información sobre cómo crear cargas útiles de solicitud correctas.

Por ejemplo, dado el siguiente constructor:

```javascript
Sentry.init({dsn: 'https://public@sentry.example.com/1'})
```

Debes analizar los siguientes ajustes:

* URI = `https://sentry.example.com`
* Public Key = `public`
* Project ID = `1`

La solicitud POST resultante para una carga útil JSON simple se enviaría a:

```
'https://sentry.example.com/api/1/store/'
```

<Alert title="Nota" level="warning">
  La parte secreta del DSN es opcional y, en la práctica, está obsoleta a estas alturas. Aunque se espera que los clientes
  la sigan respetando si se proporciona, las futuras versiones de Sentry la ignorarán por completo. El código de análisis del DSN
  no debe requerir que se establezca la clave secreta.
</Alert>

<div id="authentication">
  ## Autenticación
</div>

Se espera que se envíe un encabezado de autenticación junto con el cuerpo del mensaje,
que actúa como identificador de propiedad:

```
X-Sentry-Auth: Sentry sentry_version=7,
  sentry_client=<versión del cliente, arbitraria>,
  sentry_key=<clave pública de API>,
  sentry_secret=<clave secreta de API>
```

El `sentry_secret` solo debe incluirse si el DSN contenía una parte de clave secreta. Las versiones futuras del protocolo retirarán por completo la clave secreta.

<Alert title="Nota">
  Debes incluir la cadena de versión del SDK en la sección User-Agent del encabezado; se usará si `sentry_client` no se envía en el encabezado de autenticación.
</Alert>

En situaciones en las que no sea posible enviar el encabezado personalizado `X-Sentry-Auth`,
puedes enviar estos valores mediante la query string:

```
?sentry_version=7&sentry_key=<clave de API pública>&sentry_secret=<clave de API secreta>...
```

`sentry_key`

: **Obligatorio.** La clave pública que debe proporcionarse como parte de la configuración del SDK.

`sentry_version`

: **Obligatorio.** La versión del protocolo. La versión actual del protocolo es
`7`.

`sentry_client`

: **Recomendado.** Una cadena arbitraria que identifica tu SDK, incluida su versión. El patrón típico es `client_name/client_version`.
Por ejemplo, el SDK de Python podría enviar esto como `sentry.python/1.0`.

`sentry_timestamp`

: La marca de tiempo Unix que representa el momento en que se generó este evento.
*Esta clave está prácticamente en desuso y se ignora en el lado receptor. Usa en su lugar el [encabezado de sobre `sent_at`](/es/sdk/data-model/envelopes/#envelope-headers).*

`sentry_secret`

: La clave secreta que debe proporcionarse como parte de la configuración del SDK.
*Esta clave está prácticamente en desuso y ya no es necesario configurarla. Sin embargo, dado que fue obligatoria en versiones anteriores, todavía debe permitirse y pasarse a Sentry si se establece.*

<div id="http-headers">
  ## Encabezados HTTP
</div>

Recomendamos enviar siempre los siguientes encabezados:

* `content-type`
* `content-length`
* `user-agent`

Los siguientes encabezados adicionales están permitidos según la política de CORS:

* `x-sentry-auth`
* `x-requested-with`
* `x-forwarded-for`
* `origin`
* `referer`
* `accept`
* `authentication`
* `authorization`
* `content-encoding`
* `transfer-encoding`

<div id="user-agent">
  ### Agente de usuario
</div>

Se espera que todos los SDK informen su nombre y versión mediante el encabezado `user-agent`.
Debe usarse el siguiente formato (a menos que la plataforma exija o recomiende algo distinto,
por ejemplo, para SDK de navegador, donde el encabezado de user-agent debe establecerlo el propio navegador):

`{sdk-name}/{sdk-version}`

Por ejemplo:

* `sentry.python/1.45.0`
* `sentry.php/4.7.0`
* `sentry-ruby/5.17.3`
* `sentry.cocoa/8.24.0`

Información adicional sobre el entorno de ejecución, el sistema operativo y otros se puede
añadir como comentarios entre paréntesis, separados por `; ` (punto y coma y espacio), de la siguiente manera:

`{sdk-name}/{sdk-version} ({runtime-name} {runtime-version}; {os-name} {os-version})`

No hay ningún requisito respecto a la presencia ni al orden de los campos. El user-agent
no debe contener PII ni otros datos sensibles. En general, no debería incluir
ninguna información que no esté ya presente en el payload.

<div id="request-compression">
  ## Compresión de solicitudes
</div>

Se recomienda encarecidamente que los SDK compriman el cuerpo de la solicitud antes de enviarlo al servidor para reducir el tamaño de los datos. El método preferido para ello es enviar un encabezado `content-encoding`. Relay y Sentry aceptan las siguientes codificaciones de contenido:

* `gzip`: Con el algoritmo de compresión [LZ77](http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77).
* `deflate`: Con la estructura [zlib](http://tools.ietf.org/html/rfc1950) y el algoritmo de compresión [deflate](http://tools.ietf.org/html/rfc1951).
* `br`: Con el algoritmo [Brotli](https://en.wikipedia.org/wiki/Brotli).
* `zstd`: Con el algoritmo [zstd](https://datatracker.ietf.org/doc/html/rfc8878).

<div id="transfer-encoding">
  ## Codificación de transferencia
</div>

La codificación de transferencia se recomienda solo para solicitudes muy grandes. Configura el encabezado en
`transfer-encoding: chunked`, lo que permite omitir el encabezado `content-length`
y requiere que el cuerpo de la solicitud se envuelva en encabezados de fragmentos.

Consulta
[MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding)
para más detalles.

<div id="reading-the-response">
  ## Lectura de la respuesta
</div>

Si todo sale bien, recibirá una respuesta HTTP del servidor que incluye un objeto JSON con información sobre la carga enviada:

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": "fc6d8c0c43fc4630ad850ee518f1b9d0"
}
```

Toma nota del código de respuesta que usará Sentry. **Siempre** verifica que sea `200`,
lo que confirma que el mensaje se entregó. Se realiza una validación inmediata
que puede dar como resultado un código de respuesta (y mensaje) diferente.

<div id="handling-errors">
  ## Gestión de errores
</div>

<div id="server-errors">
  ### Errores del servidor
</div>

Recomendamos encarecidamente que tu SDK maneje correctamente los fallos del servidor de Sentry. En concreto, los SDK deben respetar el código de estado `429` y no intentar enviar hasta que entre en vigor `Retry-After`. Los SDK deberían descartar los eventos si Sentry no está disponible en lugar de reintentarlo.

Para depurar un error durante el desarrollo, inspecciona los encabezados y el cuerpo de la respuesta. Por ejemplo, podrías recibir una respuesta similar a:

```http
HTTP/1.1 400 Bad Request
Content-Type: application/json
X-Sentry-Error: no se pudo leer el cuerpo de la solicitud

{
  "detail":"no se pudo leer el cuerpo de la solicitud",
  "causes":[
    "no se pudo decodificar la carga zlib",
    "flujo deflate corrupto"
  ]
}
```

El encabezado `X-Sentry-Error` y el cuerpo de la respuesta no siempre contendrán un mensaje,
pero aun así pueden ser útiles para depurar clientes. Cuando se emitan, contendrán
un mensaje de error específico, lo cual ayuda a identificar la causa raíz.

<Alert title="Nota">
  No recomendamos que los SDK reintenten automáticamente el envío de eventos en caso de error,
  ni siquiera si `Retry-After` figura en los encabezados de la respuesta. Si una
  solicitud falla una vez, es muy probable que falle de nuevo en el siguiente intento.
  Reintentar con demasiada frecuencia puede provocar más limitaciones de tasa o bloqueos por parte del servidor de Sentry.
</Alert>

<div id="sdk-errors">
  ### Errores del SDK
</div>

Hacemos todo lo posible para que nuestros SDK estén libres de errores. Al fin y al cabo, somos un servicio de monitorización de excepciones y lanzar nuestras propias excepciones es incómodo. Sin embargo, si nuestros SDK lanzan excepciones, tenemos que asegurarnos de gestionarlas de forma adecuada y emitir un log de nivel de error que describa el fallo.

Como **principio de diseño**, nunca capturamos eventos de Sentry por excepciones que ocurran dentro de nuestros SDK, incluidas las de callbacks y hooks definidos por el usuario como `before_send` o `traces_sampler`.

El motivo por el que evitamos capturar excepciones internas del SDK es que ya estamos en un flujo de captura de eventos en el que se ha aplicado el scope, y capturar otro evento en ese punto del ciclo de vida conduciría a un comportamiento indefinido. En el peor de los casos, podríamos crear un bucle ocupado que cree y envíe eventos repetidamente hasta que el sistema se bloquee.

En los SDK móviles, los fallos no controlados seguirán llegando a Sentry a través de los crash handlers. Consulta [SDK Crash Detection](https://github.com/getsentry/sentry/tree/master/src/sentry/utils/sdk_crashes#sdk-crash-detection) para más detalles.

<div id="concurrency-scope-and-hubs">
  ## Concurrencia (Scopes y Hubs)
</div>

Los SDK proporcionan un manejo de concurrencia estandarizado mediante el
concepto de hubs y scopes. Esto se explica con más detalle en el capítulo de
<Link to="/sdk/miscellaneous/unified-api#concurrency">Concurrencia</Link> de la documentación de la API unificada.

<div id="layer-of-integration">
  ## Capa de integración
</div>

Cuando es posible, los SDK deben integrarse a bajo nivel para capturar la mayor parte posible del tiempo de ejecución.
Esto significa que, si un SDK puede engancharse directamente al runtime o a un framework, se prefiere eso
a requerir que los usuarios hereden de clases base específicas (o mezclen utilidades). Por ejemplo, el SDK de Python
aplicará monkey patching a funcionalidades básicas en los frameworks para detectar errores automáticamente e integrar
el manejo del scope.
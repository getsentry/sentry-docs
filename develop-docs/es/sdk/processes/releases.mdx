---
title: Lanzamientos
description: Aprende a publicar un nuevo SDK o nuevas versiones de un SDK.
sidebar_order: 3
---

Esta guía cubre la configuración mínima necesaria para publicar algo mediante
[`publish`] y [`craft`]. Este ejemplo usará un paquete de PyPI.

[`publish`]: https://github.com/getsentry/publish

[`craft`]: https://github.com/getsentry/craft

<div id="the-first-release">
  ## La primera versión
</div>

Esta guía asume que esto nunca se ha publicado antes y que no tiene
etiquetas. Si no es el caso, puedes saltarte esta sección.

Debe existir una etiqueta para el “inicio” del repositorio debido a [una limitación] --
se recomienda etiquetar el primer commit del repositorio antes de cualquier
historial significativo, de modo que el primer changelog incluya contexto útil.

```bash
git tag 0.0.0 "$(git log -1 --reverse --format=%h)"
git push origin --tags
```

[una limitación]: https://github.com/getsentry/craft/issues/342

<div id="ci-requirements">
  ## Requisitos de CI
</div>

Primero debemos asegurarnos de que tu repositorio responda a las ramas `release/**`
y genere un artefacto con el nombre correcto.

En nuestro repositorio de ejemplo, eso se hace usando [`push: branches`] y una
[instrucción de artefacto].

[`push: branches`]: https://github.com/getsentry/uwsgi-dogstatsd-plugin/blob/5057cba0104827c226094f153ffba7ade1a4331d/.github/workflows/build.yml#L5

[instrucción de artefacto]: https://github.com/getsentry/uwsgi-dogstatsd-plugin/blob/5057cba0104827c226094f153ffba7ade1a4331d/.github/workflows/build.yml#L81-L84

<div id="setting-up-craft">
  ## Configuración de Craft
</div>

<div id="craftyml">
  ### `.craft.yml`
</div>

Solo nos interesa publicar una versión en GitHub y otra en PyPI, así que nuestra configuración de `craft` queda así:

```yaml
minVersion: 0.28.1
targets:
  - name: pypi
  - name: github
```

<div id="scriptsbump-versionsh">
  ### `scripts/bump-version.sh`
</div>

Este script lo invoca `craft` de forma predeterminada al actualizar la versión.

Como especificamos la versión en `setup.cfg`, es bastante sencillo hacerlo con
`sed` (ignoramos `$1`, que contiene la versión anterior):

```bash
#!/usr/bin/env bash
set -euxo pipefail

sed -i "s/^version =.*/version = $2/" setup.cfg
```

Prueba el script (pero no confirmes los cambios):

```console
$ ./scripts/bump-version.sh 0.0.0 1.0.0
+ sed -i 's/^version =.*/version = 1.0.0/' setup.cfg
$ git diff | grep '^[-+]'
--- a/setup.cfg
+++ b/setup.cfg
-version = 0.0.0
+version = 1.0.0
$ git checkout -- .
```

¡Qué bien!

<div id="githubworkflowsreleaseyml">
  ### `.github/workflows/release.yml`
</div>

Este archivo se usa para activar la publicación desde la interfaz de GitHub.

Verás que utiliza `vars.SENTRY_RELEASE_BOT_CLIENT_ID` y `secrets.SENTRY_RELEASE_BOT_PRIVATE_KEY`; ¡deberían estar disponibles automáticamente en tu repositorio!

```yaml
name: Lanzamiento

on:
  workflow_dispatch:
    inputs:
      version:
        description: Versión a lanzar
        required: true
      force:
        description: Forzar un lanzamiento incluso cuando haya bloqueadores de lanzamiento (opcional)
        required: false

jobs:
  release:
    runs-on: ubuntu-latest
    name: "Lanzar una nueva versión"
    steps:
      - name: Obtener token de autenticación
        id: token
        uses: actions/create-github-app-token@5d869da34e18e7287c1daad50e0b8ea0f506ce69 # v1.11.0
        with:
          app-id: ${{ vars.SENTRY_RELEASE_BOT_CLIENT_ID }}
          private-key: ${{ secrets.SENTRY_RELEASE_BOT_PRIVATE_KEY }}
      - uses: actions/checkout@v3
        with:
          token: ${{ steps.token.outputs.token }}
          fetch-depth: 0
      - name: Preparar lanzamiento
        uses: getsentry/action-prepare-release@v1
        env:
          GITHUB_TOKEN: ${{ steps.token.outputs.token }}
        with:
          version: ${{ github.event.inputs.version }}
          force: ${{ github.event.inputs.force }}
```

<div id="commit-pr">
  ### Commit + PR
</div>

**Haz commit de esos tres archivos y abre un pull request.**

Aquí tienes [un PR de ejemplo] y el [seguimiento para corregir `fetch-depth`].

[un PR de ejemplo]: https://github.com/getsentry/uwsgi-dogstatsd-plugin/pull/2

[seguimiento para corregir `fetch-depth`]: https://github.com/getsentry/uwsgi-dogstatsd-plugin/pull/3

<div id="setting-up-permissions">
  ## Configuración de permisos
</div>

Concede acceso a los siguientes equipos en tu repositorio:

* `engineering` -&gt; `write`

Puedes hacerlo tú mismo desde la página de configuración de tu repositorio:
`https://github.com/getsentry/REPONAME_HERE/settings/access`

<div id="create-ruleset-for-the-repo">
  ## Crear un conjunto de reglas para el repositorio
</div>

Descarga y guarda la [plantilla de conjunto de reglas predeterminada](/es/json/Default_ruleset.json) como archivo JSON.

Visita la página de configuración de conjuntos de reglas de tu repositorio: `https://github.com/getsentry/REPONAME_HERE/settings/rules`, haz clic en el botón verde **New ruleset**, elige **Import a ruleset** y selecciona el archivo JSON que acabas de descargar. Puedes ajustar la configuración del conjunto de reglas, pero no elimines la app de la Bypass List.

<div id="making-your-first-release">
  ## ¡Publica tu primera versión!
</div>

Ve a la pestaña Actions de tu repositorio, busca el workflow de releases
y crea la primera versión. Yo usé `1.0.0` como la primera versión.

Esto creará un [issue en `publish`] al que necesitarás que un aprobador
le agregue una etiqueta.

[issue en `publish`]: https://github.com/getsentry/publish/issues

<div id="version-name-conventions">
  ## Convenciones para nombres de versiones
</div>

Para mantener un versionado coherente entre SDK, generalmente seguimos el [versionado semántico (semver)](https://semver.org/), con convenciones específicas del idioma o la plataforma en torno a semver (si aplica).
Craft incluye algunas comprobaciones para garantizar que solo publiquemos versiones válidas, similares a semver.
En concreto, Craft espera versiones que sigan este formato:

```txt
<major>.<minor>.<patch>(-<prerelease>)?(-<build>)?
```

Si bien los números de versión mayor, menor y de parche son obligatorios, las propiedades de prelanzamiento y compilación son opcionales, pero también pueden combinarse.

<div id="pre-releases-prerelease">
  ### Pre-releases (`<prerelease>`)
</div>

Si quieres crear una versión de vista previa o prerelease de tu SDK, puedes añadir un identificador de prerelease y, de forma opcional, un número incremental de prerelease a tu versión.
Esto garantizará que varios targets de publicación de Craft traten la versión como prerelease; por ejemplo, no se le asignará la etiqueta `latest` en los repositorios de paquetes.
Asimismo, las prereleases no se insertarán en nuestro registro interno de lanzamientos, que utiliza el producto Sentry, así como nuestra documentación y otras herramientas para consultar las versiones más recientes o específicas de nuestros paquetes.

Es importante: tenemos reglas estrictas sobre qué identificadores aceptamos como prerelease, lo que significa que la parte `<prerelease>` de tu versión debe ser una de las siguientes: `preview|pre|rc|dev|alpha|beta|unstable|a|b`.
Por lo tanto, **no aceptamos** cadenas arbitrarias como identificadores de prerelease. Usar cualquier otro identificador hará que la versión se considere estable. Esto significa que se le asignará la etiqueta `latest` en los repositorios de paquetes y se insertará en nuestro registro de lanzamientos.

Ejemplos:

```txt
// válido
1.0.0-preview
1.0.0-alpha.0
1.0.0-beta.1
1.0.0-rc.20
1.0.0-a

// inválido o mal interpretado
1.0.0-foo
1.0.0-canary.0
```

<div id="special-case-post-releases">
  #### Caso especial: versiones posteriores
</div>

Python tiene el concepto de versiones posteriores, que Craft gestiona implícitamente. Una versión posterior se indica con un sufijo `-\d+` en la versión semver, por ejemplo: `1.0.0-1`.
Dado que solo consideramos ciertos identificadores como [identificadores de prerelease válidos](#pre-releases-prerelease), las versiones posteriores se consideran versiones estables.

<div id="build-identifiers-build">
  ### Identificadores de compilación (`<build>`)
</div>

En algunos casos, puedes añadir un identificador de compilación a tu versión; por ejemplo, si publicas la misma versión del paquete para distintas plataformas o arquitecturas.
También puedes combinar identificadores de compilación y de pre-lanzamiento, pero en ese caso el identificador de pre-lanzamiento debe ir primero.

Ejemplos:

```txt
// válido
1.0.0+x86_64
1.0.0-rc.1+x86_64

// no válido o tratado de forma incorrecta
1.0.0+rc.1+x86_64
1.0.0+x86_64-beta.0
```

<div id="optional-using-multiple-craft-configs-in-a-repo">
  ## [Opcional] Usar múltiples configuraciones de Craft en un repositorio
</div>

En algunos casos, necesitamos mantener varias configuraciones de publicación, incluso divergentes, en un repositorio.
Por ejemplo, cuando debemos mantener varias versiones principales de un paquete que publicamos (p. ej., Sentry JavaScript SDK v7 y v8), en las que se han añadido o eliminado artefactos o destinos de publicación.

De forma predeterminada, nuestro proceso de publicación está configurado para tomar la configuración `craft.yml` de la rama predeterminada del repositorio como la única fuente confiable para la publicación.

Puedes hacer que tu repositorio use la configuración de una rama de destino de merge específica (puede configurarse al activar la acción Prepare Release) en dos pasos:

<div id="1-release-preparation">
  ### 1. Preparación de la versión:
</div>

Añade `craft_config_from_merge_target: true` al invocar `getsentry/action-prepare-release` en el flujo de trabajo de lanzamientos de tu repositorio:

```yml
# ...
jobs:
  release:
    runs-on: ubuntu-latest
    name: "Lanzar una nueva versión"
    steps:
      # ...
      - name: Preparar el lanzamiento
        uses: getsentry/action-prepare-release@v1
        with:
          # ...
          craft_config_from_merge_target: true
```

<div id="2-publish-configuration">
  ### 2. Configuración de publicación
</div>

Agrega las ramas de las que quieres tomar la configuración al flujo de trabajo `publish.yml` en `getsentry/publish`:

```yml
# ...
- name: Establecer la rama de checkout del repositorio objetivo
  if: |
    fromJSON(steps.inputs.outputs.result).repo == 'sentry-javascript' && fromJSON(steps.inputs.outputs.result).merge_target == 'v7'
```

Nota: Las ramas registradas en este paso **DEBEN** estar protegidas en el repositorio de destino.
Inhabilita los envíos directos a la rama y requiere aprobaciones para los PR antes de poder fusionarlos.

¡Buen trabajo! Ahora puedes dejar que tus configuraciones de Craft diverjan entre las distintas ramas de destino de fusión, y el proceso de publicación tomará la configuración correcta según la rama que establezcas como destino de fusión.

---
title: Sesiones
sidebar_order: 6
og_image: /og-images/sdk-telemetry-sessions.png
---

<Alert>
  ¿Buscas **Session Replay** de Sentry? Haz clic <a class href="https://docs.sentry.io/product/session-replay/">aquí</a> para obtener más información.
</Alert>

Para un seguimiento básico del estado, Sentry acepta <Link to="/sdk/data-model/envelopes/">envelopes</Link>
que contienen eventos de actualización de sesión. Estos eventos pueden usarse para
informar a Sentry sobre la salud de la versión y del proyecto.

**Nota:** Cuando trabajes con Sessions localmente, asegúrate de actualizar tu archivo de configuración `~/.sentry/sentry.config.py`
con la variable de entorno necesaria:

```python
SENTRY_EVENTSTREAM = 'sentry.eventstream.kafka.KafkaEventStream'
```


<div id="basic-operation">
  ## Operación básica
</div>

- Las sesiones están completamente controladas por el cliente. El cliente determina cuándo una sesión
  comienza, termina o pasa a un estado no saludable.
  - El cliente puede finalizar explícitamente una sesión para registrar el tiempo o la condición de salida (crash, etc.).
  - Los clientes deberían finalizar explícitamente las sesiones al reiniciar si es necesario, pero es aceptable
    que una sesión no termine.
- Las sesiones se actualizan mediante eventos de cambio de sesión que contienen todo el estado de la sesión.
- Las sesiones se actualizan a partir de eventos enviados. El evento más reciente contiene
  todo el estado de la sesión. El evento de sesión inicial que se envía al servidor se
  marca explícitamente.
- Las actualizaciones de sesión no deben cambiar los atributos ni corromper los datos al materializarse.
  Consulta la sección a continuación sobre <Link to="#attribute-immutability">Inmutabilidad de atributos</Link>.
- Las sesiones solo se pueden actualizar durante un período de 5 días. Si una sesión no
  recibe un segundo evento en 5 días, se considera permanentemente correcta.
- No es necesario que una sesión se inicie para que se produzca un crash. Basta con informar un crash.

<div id="server-model">
  ## Modelo del servidor
</div>

En la actualidad, el sistema de sesiones de Sentry está optimizado para facilitar la escalabilidad y
reducir los costos operativos. Esto significa que el protocolo está fuertemente orientado a
lograr este objetivo. Algunas de estas optimizaciones se reflejan en el protocolo y es
importante que el cliente lo siga con precisión para evitar generar
datos erróneos en el servidor.

El servidor utiliza compartimentos horarios con datos de sesión prematerializados. A medida que llega un evento
de actualización de sesión, el servidor materializa inmediatamente los datos en el
compartimento correspondiente. Esto implica que el protocolo está limitado a ser “aditivo”.
Esto también implica que el cliente debe almacenar el estado completo de la sesión
en su lado.

<div id="session-update-payload">
  ## Carga útil de actualización de sesión
</div>

Una actualización de sesión es un elemento dentro de un sobre llamado `session`. Consta de una carga útil JSON que luce aproximadamente así:

```json
{
  "sid": "7c7b6585-f901-4351-bf8d-02711b721929",
  "did": "id de usuario único opcional",
  "init": true,
  "started": "2020-02-07T14:16:00Z",
  "duration": 60,
  "status": "exited",
  "attrs": {
    "release": "my-project-name@1.0.0",
    "environment": "nombre del entorno",
    "ip_address": "dirección IP opcional del usuario para filtrado",
    "user_agent": "agente de usuario opcional para filtrado"
  }
}
```

Ten en cuenta que esto debe ir dentro de un “envelope”. Así, el evento completo queda
más o menos así:

```json
{}
{"type":"session"}
{"sid":"..."}
```

Los siguientes campos existen:

`sid`

: *String, opcional*. ID de sesión (único y generado por el cliente).
Los clientes pueden omitirlo si el estado inicial de la sesión es `exited`.

`did`

: *String, opcional*. ID distintivo. Debe ser un ID de dispositivo o de usuario.
El sistema aplica un hash automáticamente a este ID antes de almacenarlo.

`seq`

: *Number, opcional*. Un reloj lógico. De forma predeterminada es la marca de tiempo UNIX actual
en milisegundos durante la ingesta. El valor `0` está reservado en el sentido de que
una sesión con `init` establecido en `true` tendrá automáticamente `seq` forzado a `0`.

`timestamp`

: *String, opcional*. La marca de tiempo de cuándo llegó el evento de cambio de sesión.
Debe ser una cadena DateTime ISO. Si no se envía, el servidor asumirá la marca de tiempo
UTC actual. En el modelo de datos, esto se denomina `received`.

`started`

: **String, obligatorio**. Marca de tiempo cuando comenzó la sesión.
Debe ser una cadena DateTime ISO.

`init`

: *Boolean, opcional, predeterminado `false`*.
Si se establece en `true`, significa que este fue el primer evento de la sesión.
Esto permite al servidor optimizar el conteo de sesiones porque no se necesita
desduplicación (el cliente es autoritativo de todos modos). Internamente, cuando este indicador está establecido,
`seq` se cambia a `0` durante el procesamiento.

`duration`

: *Number, opcional*. Un campo opcional que puede transmitir la duración de la sesión
cuando se recibió el evento. Esto puede estar controlado por el cliente, de modo que, por ejemplo,
se pueda restar el tiempo inactivo (segundos en coma flotante).

`status`

: *String, opcional, predeterminado `ok`*. El estado actual de la sesión.
Una sesión solo puede estar efectivamente en dos estados: `ok`, que significa que la sesión
está activa, o uno de los estados terminales. Cuando una sesión sale de `ok`,
ya no debe actualizarse.

* `ok`: La sesión está en curso y en buen estado. Este puede ser el estado terminal de una sesión.
* `exited`: La sesión finalizó normalmente.
* `crashed`: La sesión finalizó por un bloqueo.
* `abnormal`: La sesión terminó con una salida anormal no relacionada con un bloqueo.

`errors`

: *Number, opcional, predeterminado `0`*. Un contador acumulado de errores encontrados
mientras esta sesión estaba en curso. Es importante que este contador también
se incremente cuando una sesión pasa a `crashed`.
(p. ej., el propio bloqueo siempre cuenta como un error).
La ingesta debe forzar `errors` a 1 si no está establecido o es 0.

`abnormal_mechanism`

: *String, opcional, predeterminado `none`*. El mecanismo que provocó que la sesión finalizara con
estado `abnormal`. Esta propiedad meta es útil para determinar la tasa de sesiones anormales en casos específicos;
por ejemplo, en plataformas como Android se usa para calcular la tasa de ANR percibida por el usuario.

`attrs`

: **Object, obligatorio** *todas las claves excepto `release` son opcionales*. Objeto con los siguientes atributos:

* `release`: El ID de release de Sentry (`release`), formato sugerido `my-project-name@1.0.0`.
* `environment`: El entorno de Sentry (`environment`).
* `ip_address`: La dirección IP principal a considerar. Normalmente es la
  IP del usuario. Estos datos no se persisten, sino que se usan para filtrado. Si no
  se establece, la IP se completa automáticamente.
* `user_agent`: El agente de usuario a considerar. Normalmente es el agente de usuario
  del usuario que originó la sesión. Estos datos no se persisten, sino que
  se usan para filtrado.


<div id="session-aggregates-payload">
  ## Carga útil de agregados de sesión
</div>

Especialmente para las sesiones en *request-mode*
(<Link to="#sdk-considerations">ver más abajo</Link>), es común tener
miles de solicitudes (y, por tanto, sesiones) por segundo.

Suponiendo que estas sesiones sean de corta duración y que no se quiera
medir su duración, pueden agregarse en el lado del
SDK antes de enviarlas a Sentry.

Un SDK debe agregar las sesiones cerradas y agruparlas por su `started`,
`distinct_id` y sus `attrs`. Estos grupos se enviarán como un elemento de sobre `sessions`.
Consiste en una carga útil JSON que se ve aproximadamente así:

```json
{
  "aggregates": [
    {
      "started": "2020-02-07T14:16:00Z",
      "exited": 123
    },
    {
      "started": "2020-02-07T14:16:00Z",
      "did": "id de usuario único opcional",
      "exited": 12,
      "errored": 3
    }
  ],
  "attrs": {
    "release": "my-project-name@1.0.0",
    "environment": "development"
  }
}
```

Ten en cuenta que esto debe ir dentro de un “envelope”. Así, el “envelope” completo se ve
más o menos así:

```json
{}
{"type": "sessions"}
{"aggregates": [...], "attrs": {...}}
```

`aggregates`

: **Arreglo, obligatorio**. Un arreglo de agregados agrupados por su marca de tiempo `started` y un id distinto (did).

* `started`: **Obligatorio**. Marca de tiempo del grupo, redondeada hacia abajo al minuto. Debe ser una cadena de fecha y hora ISO (ISO DateTime).
* `did`: *Opcional*. El id de usuario distinto del grupo.
* `exited`: *Opcional*. El número de sesiones con estado `"exited"` *sin* ningún error.
* `abnormal`: *Opcional*. El número de sesiones con estado `"abnormal"`.
* `crashed`: *Opcional*. El número de sesiones con estado `"crashed"`.
* `errored`: *Opcional*. El número de sesiones con estado `"exited"` que tuvieron un conteo de `errors` distinto de cero.

`attrs`

: **Objeto, obligatorio**. Ver arriba.


<div id="crashes-vs-sessions">
  ## Bloqueos vs. sesiones
</div>

Las sesiones y los eventos de error son dos sistemas distintos dentro de Sentry. Las actualizaciones de sesión pueden realizarse sin enviar eventos de error y, del mismo modo, se pueden enviar errores sin actualizaciones de sesión.

Esto le da al cliente control total sobre cómo realizar las actualizaciones de sesión. La motivación es que el servidor puede rechazar eventos de error en algunas situaciones en las que sigue siendo útil registrar la información de sesión. Por ejemplo, si a un proyecto se le aplica un límite de tasa en los eventos de error, los datos de sesión aún pueden enviarse al proyecto, omitiendo ese límite.

Sin embargo, se recomienda encarecidamente enviar las actualizaciones de sesión en el mismo sobre que el evento de bloqueo en caso de que la sesión cambie al estado bloqueado. Esto garantizará que los eventos lleguen al sistema al mismo tiempo si la red no es confiable.

<div id="important-client-behavior">
  ## Comportamiento importante del cliente
</div>

Estas son reglas importantes que los clientes deben seguir:

<div id="attribute-immutability">
  ### Inmutabilidad de atributos
</div>

Actualmente no se permite que una sesión cambie ninguno de sus atributos
en actualizaciones posteriores, incluidos `did`, `started` u otros atributos.
Los únicos atributos que pueden cambiar son el estado de la sesión, la duración
o el recuento de errores. Si el usuario no se conoce al principio, se debe
retrasar el inicio de la sesión o reiniciarla una vez que se conozca la identidad del usuario.

<div id="session-counting-init">
  ### Recuento de sesiones / init
</div>

Es fundamental que la actualización inicial de la sesión enviada al sistema tenga `init` establecido en `true`. Esto es necesario porque el servidor actualmente no realiza la desduplicación del recuento total de sesiones como optimización. Si falta el indicador inicial `init: true`, es posible que Sentry no procese correctamente la sesión.

<div id="terminal-session-states">
  ### Estados de la sesión
</div>

Una sesión puede estar en uno de dos estados: en curso o finalizada. Una sesión
finalizada no debe recibir más actualizaciones. `exited`, `crashed` y `abnormal`
son estados terminales. Cuando una sesión alcanza este estado, el cliente no debe
enviar más actualizaciones de la sesión ni iniciar una nueva sesión.

Se recomienda que los SDK distingan entre distintas formas de finalizar una sesión:

- `exited`: significa que la sesión terminó correctamente. Es lo mismo que la
  sesión permaneciendo en `ok` desde el punto de vista de los reportes de éxito. Sin embargo, solo
  las sesiones que terminan en `exited` se tendrán en cuenta para las duraciones de sesión.
  Se permite que una sesión pase a `exited` incluso si se produjeron errores.

- `crashed`: una sesión debe reportarse como con bloqueo en los siguientes casos:

  - ocurrió un error no controlado y hay un final natural de la sesión (p. ej., fin de una solicitud HTTP)
  - ocurrió un bloqueo completo de la aplicación (crash al escritorio, terminación)
  - se muestra un cuadro de diálogo de comentarios del usuario. Después de esto, el SDK debe iniciar una nueva sesión como si hubiera fallado por completo.

- `abnormal`: se recomienda que los SDK siempre cambien una sesión a `exited` o
  `crashed` si pueden hacerlo. Para los SDK que son capaces de finalizar sesiones en todo momento, deben finalizar una
  sesión en `abnormal` si no pudieron detectar que la aplicación se cerró
  correctamente. Ejemplos de sesiones anómalas:

  - se apagó la computadora o se perdió la energía
  - el usuario forzó el cierre de una aplicación mediante `kill -9` o el administrador de tareas

  Las finalizaciones de sesión anómalas normalmente se registran al reiniciar la aplicación.

<div id="crashed-abnormal-vs-errored">
  ### Fallida, Anormal vs Con errores
</div>

Se supone que una sesión debe pasar a `crashed` cuando se encuentra con un error no controlado, como un bloqueo total de la aplicación. En aplicaciones que no pueden bloquearse por completo, como un sitio web, es aceptable pasar al estado de bloqueo si el usuario ve un cuadro de diálogo de error. En entornos de servidor donde creamos sesiones para cada solicitud entrante, `crashed` es básicamente equivalente al código de estado `500` (error interno del servidor). Así que, si ocurre un error no controlado durante la solicitud, la sesión debe quedar como `crashed`.

Las sesiones anormales son aquellas cuyo destino es desconocido. En aplicaciones de escritorio, por ejemplo, tiene sentido marcar una sesión como anormal si se guardó, pero no se observó la salida de la aplicación y tampoco se bloqueó. Esto ocurre cuando el usuario fuerza el cierre de la app desde el administrador de tareas, la máquina pierde energía u otras situaciones similares. Una sesión puede quedar _almacenada_ si se persiste en disco de forma anticipada. Este archivo guardado puede detectarse al reiniciar la aplicación para cerrar la sesión como `abnormal`.

Las sesiones con errores se determinan por un contador de `errors` mayor que cero. El cliente debe contar los eventos considerados errores y enviar ese conteo junto con las actualizaciones de sesión. Una sesión que está `ok` y tiene un conteo de errores mayor que cero se considera una sesión con errores. Todas las sesiones fallidas y anormales también se consideran en todo momento con errores, pero se restan del conteo final de sesiones con errores.

Solo los eventos que provienen de `captureException`, `captureError` o `captureEvent` deben incrementar el contador de `errors` cuando su nivel es `error` o superior. Como los SDK establecen el nivel predeterminado en `error` para estos métodos, un nivel inferior a `error` significa que los usuarios lo cambiaron manualmente. Esto les da la posibilidad de capturar eventos de error sin marcar las sesiones como con errores. Se incluye `captureEvent` porque los usuarios podrían crear manualmente eventos de excepción con él. Los eventos provenientes de `captureMessage` no deben afectar el conteo de errores de la sesión, independientemente de su nivel de registro. Para todos los métodos, no importa si el evento tiene una traza de pila o no. La siguiente tabla resume el comportamiento de los métodos:

| method | level  | increments `errors` counter |
| --- | --- | --- |
| captureException / captureError | `fatal` | `yes` |
| captureException / captureError | `error` | `yes` |
| captureException / captureError | `warning` | `no` |
| captureEvent  | `fatal` | `yes` |
| captureEvent  | `error` | `yes` |
| captureEvent  | `warning` | `no` |
| captureMessage | `fatal` | `no` |
| captureMessage | `error` | `no` |
| captureMessage | `warning` | `no` |

<div id="exited">
  ### Finalizado
</div>

Una sesión puede pasar a `exited`, que es exactamente el mismo estado que `ok`,
con una diferencia: las sesiones que pasan a `exited` tienen su duración
promediada. Esto permite que Sentry te muestre la duración de las sesiones
que no se bloquearon a lo largo del tiempo.

<div id="alerts">
  ## Alertas
</div>

Activa una alerta cuando un problema afecte a un porcentaje específico de sesiones.
Crea una nueva [alerta de problemas](https://docs.sentry.io/product/alerts/alert-types/#issue-alerts) y selecciona la condición «When»
«An issue affects more than \{X} percent of sessions». Consulta más opciones de alertas de problemas en la documentación de
[Configuración de alertas de problemas](https://docs.sentry.io/product/alerts/create-alerts/issue-alert-config/).

![Alerta de problema de sesión](sessionsAlert.png)

<div id="sdk-considerations">
  ## Consideraciones del SDK
</div>

En términos generales, hay dos modos distintos para el reporte de estado que los SDK
pueden usar. Uno son las sesiones de muy corta duración y el otro, las sesiones atendidas por el usuario.

**Sesiones de corta duración** _(server-mode / request-mode)_

Estas sesiones se corresponden aproximadamente con solicitudes HTTP o llamadas RPC en un
entorno de servidor.

- alto volumen, normalmente una sesión por cada solicitud
- el número de sesiones suele ser mayor que el número de eventos de Sentry
- las sesiones están asociadas a un único hub / unidad de concurrencia
- la información temporal suele ser inútil porque la duración de la sesión se mide en milisegundos

**Sesiones atendidas por el usuario** _(user-mode / application-mode)_

Estas sesiones se corresponden más con una sesión real de usuario o
una ejecución de la aplicación. Esto es lo que verías en un navegador web, en el mundo móvil,
en una aplicación de línea de comandos o similar.

- normalmente una sola sesión desde el inicio de la aplicación hasta su cierre
- cuando corresponda, las sesiones pueden finalizar una vez que la app pasa a segundo plano por más de 30 segundos (SDK móviles)
- por lo general hay menos sesiones que eventos de Sentry
- las sesiones abarcan múltiples hubs / hilos
- la duración de la sesión suele ser de minutos; la información temporal es útil

Ambos casos se ven similares desde el punto de vista de la API, pero se aplican
recomendaciones diferentes para los SDK.

<div id="choosing-the-session-mode">
  ### Elegir el modo de sesión
</div>

Aunque en teoría es posible usar ambos modos de sesión en una misma aplicación,
se recomienda que el SDK establezca como predeterminado un único modo que resulte el más
adecuado para el caso de uso principal del ecosistema del lenguaje. Esto es similar a
un _modo de Hub global_ que ciertos SDKs admiten y puede usarse de la misma manera.

Cuando el SDK está configurado para usar sesiones en _modo usuario_ o en modo de Hub global,
debe iniciarse una sola sesión al comienzo de la aplicación y
mantenerse durante todo el tiempo de ejecución de la aplicación. Según la
implementación interna del SDK, esta única sesión puede compartirse entre todos los hilos de la
aplicación y los Hubs locales a cada hilo.

Al usar sesiones en _modo servidor_, no se iniciará ninguna sesión a nivel de aplicación,
y corresponderá a las integraciones o al usuario iniciar la sesión cuando se reciba la
solicitud y finalizarla cuando se devuelva una respuesta.

<div id="unified-api-implications">
  ### Implicaciones del Unified API
</div>

El <Link to="/sdk/miscellaneous/unified-api/">Unified API</Link> al que los SDK deben
atenerse define los conceptos de `Hub`, `Scope` y `Client`.

Conceptualmente, la sesión es una responsabilidad del `Hub` y, a diferencia de los scopes,
las sesiones no deben anidarse. Cuando ocurre cualquier tipo de evento, debería haber
solo una sesión inequívoca que lleve el conteo de errores.

Al considerar el flujo de eventos a través del SDK, desde la función estática
`capture_event`, pasando por el `Hub` local al hilo y llegando al método
`Client::capture_event(event, scope)`, dependiendo de los detalles de implementación
interna del SDK, podría tener sentido adjuntar la sesión al `Scope`, lo que haría posible
que el `Client` agrupe un evento y una actualización de sesión en un único sobre para
enviarlo a Sentry.

<div id="session-updates-and-when-to-send-updates-upstream">
  ### Actualizaciones de la sesión y cuándo enviar actualizaciones upstream
</div>

Para todos los SDK, la sesión actual se actualizará automáticamente cada vez que se capturen datos en un punto similar a donde se llama a `apply_to_scope` para incrementar el contador de `error`, o para actualizar la sesión según el ID único/ID de usuario.

Los SDK, en general, deberían intentar reducir la cantidad de envelopes enviados upstream.

Los SDK en _server-mode_ que registran un gran número de sesiones deberían considerar usar un vaciador de sesiones periódico (cada 60 segundos) que preagregue las sesiones en un único elemento de envelope `session_aggregates`.

Los SDK en _user-mode_ pueden optar por enviar actualizaciones de sesión junto con los eventos capturados en el mismo envelope. La actualización final de la sesión que la cierra puede agruparse de forma similar a las sesiones en _server-mode_.

En cualquier caso, la marca `init` debe configurarse correctamente para la _primera transmisión_ de la sesión, y los metadatos de la sesión, como el ID único, deben ser inmutables después de la transmisión inicial.

<div id="pre-aggregation-of-sessions">
  ### Preagregación de sesiones
</div>

Si un SDK está configurado para usar sesiones en _server-mode_, debe agrupar y
preagregar los conteos de sesiones antes de enviarlos a Sentry. Cada vez que se
cierra una sesión (transiciona a un estado terminal) y no se había enviado
previamente upstream (su indicador `init` sería `true`), es elegible para
agregación, que se realiza de la siguiente manera:

- La marca de tiempo `started` de la sesión debe redondearse hacia abajo a minutos.
- La sesión debe agregarse al bucket identificado por esa marca de tiempo
  redondeada y por el id único de la sesión (`did`).
- En el bucket correspondiente, incrementa el conteo de sesiones correspondiente
  al estado de la sesión. A diferencia de las actualizaciones de sesiones individuales,
  se usa el estado `"errored"` para marcar las sesiones que tienen el
  estado `"exited"` y un conteo de `errors` distinto de cero.

<div id="exposed-api">
  ### API expuesta
</div>

La API más básica expuesta está a nivel del hub y te permite iniciar y detener el registro de sesiones:

**API:**

`Hub.start_session()`

> Guarda una sesión en el scope actual y comienza a rastrearla. Normalmente adjunta una sesión completamente nueva al scope
> y finaliza implícitamente cualquier sesión ya existente.

`Hub.end_session()`

> Finaliza la sesión, establece un `status` y `duration` adecuados y la pone en cola para enviarla a Sentry.

`Hub.start_auto_session_tracking()` / `Hub.stop_auto_session_tracking()`

> Detiene y vuelve a activar el seguimiento automático de sesiones.

**Opciones de inicialización:**

`auto_session_tracking`

> Habilita o deshabilita el seguimiento automático de sesiones mediante integraciones.

<div id="sdk-implementation-guideline">
  ## Directrices de implementación del SDK
</div>

<Alert title="WIP">
  Antes de ponerte a implementar esta función en un SDK, ponte en contacto con
  el equipo. https://github.com/getsentry/develop/pull/323
</Alert>

Hacemos seguimiento del estado de cada versión de los proyectos en Sentry enviando cargas de sesión desde los SDK.
La carga de sesión proporciona datos como la duración de la sesión y la presencia o ausencia de errores/fallos.

Los SDK realizan el seguimiento de sesiones de dos formas:

- Sesión única
- Agregados de sesiones

La sesión única es el caso general y encaja bien con aplicaciones (relativamente de corta duración) que normalmente involucran a un solo usuario. Ejemplos:

- una utilidad de línea de comandos como [`craft`](https://github.com/getsentry/craft); <dfn title="Nota: esto es solo un ejemplo, suponiendo que craft estuviera instrumentado con un SDK de Sentry que admitiera sesiones">cada ejecución de un subcomando de `craft`</dfn> reporta una sola sesión a Sentry
- un usuario interactuando con una app móvil
- un usuario cargando un sitio web con su navegador favorito

Los agregados de sesiones se utilizan cuando enviar sesiones individuales sería indeseable o poco práctico. Para limitar el uso de recursos (concretamente memoria y red), los SDK registran información resumida sobre un lote de sesiones que ocurrieron en el pasado reciente, sin tener que manejar objetos de sesión que representen las sesiones individuales que componen el agregado. Este modo es la opción para aplicaciones que se ejecutan durante un tiempo arbitrariamente largo y manejan volúmenes más altos, potencialmente para múltiples usuarios, como servidores web, workers de tareas en segundo plano, etc. Ten en cuenta que, para ese tipo de aplicaciones, una mejor definición de sesión se corresponde con la ejecución de una sola solicitud HTTP o tarea, en lugar de una única ejecución de todo el proceso de la aplicación.

En cualquier caso, los SDK deben crear y reportar sesiones de forma predeterminada, eligiendo reportarlas individualmente o como agregados según el tipo de aplicación.

Si un SDK puede detectar que una aplicación se beneficia más de los agregados de sesiones, entonces no debe reportar una sesión a nivel de aplicación. La sesión a nivel de aplicación puede crearse durante la inicialización del SDK, pero debe abortarse y nunca enviarse a Sentry. Por ejemplo, en el SDK de Node.js, podemos detectar que probablemente se trata de un servidor web si utiliza la integración `requestHandler` proporcionada.

<div id="individual-session-functionality">
  ### Funcionalidad de sesiones individuales
</div>

<div id="configuration">
  #### Configuración
</div>

- Activado de forma predeterminada para la API global/estática;
  el usuario debería poder desactivar las sesiones si no quiere hacerles seguimiento.

Los requisitos previos para reportar sesiones y determinar la salud de la versión (Release Health) de los proyectos en Sentry, como que la release se detecte automáticamente por el SDK, deberían resolverse, por ejemplo, consultando variables de entorno.

(Quizá, requiere discusión) si no se puede detectar un requisito previo (por ejemplo, no hay una forma fiable de determinar la versión de la release), entonces establecemos un valor predeterminado para que siempre podamos reportar sesiones por defecto (según lo que se decida, esto podría no ser un cambio en el código del SDK, sino en Relay, básicamente eliminando requisitos estrictos en el payload de la sesión).

<div id="lifetime-of-a-session">
  #### Duración de una sesión
</div>

Las sesiones deben estar habilitadas de forma predeterminada solo para el hub/cliente global que se inicializa con Sentry.init y deshabilitadas de forma predeterminada para cualquier otro cliente creado manualmente.
Una sesión se inicia cuando se inicializa el SDK (idealmente, cuando el cliente predeterminado se vincula al hub global) y finaliza cuando ocurre una de estas condiciones:
Se llama explícitamente al método Hub.endSession(), o
el programa termina sin errores, o
el programa termina con una excepción no controlada, o
el programa termina con un rechazo de promesa no controlado.

Debe evitarse intentar enviar nuevas cargas de sesión a Sentry para una sesión que ya haya finalizado. Por ejemplo, si el usuario finaliza manualmente la sesión con Hub.endSession(), no debería haber nuevas actualizaciones de la sesión cuando el programa termine.

<div id="session-atrributes-and-mutability">
  #### Atributos de sesión y mutabilidad
</div>

<div id="sending-session-to-sentry">
  #### Envío de la sesión a Sentry
</div>

La sesión se envía primero tras un breve retraso (inicialmente codificado; menos configuración es mejor), algo entre 1 s y 30 s por definir, y luego se actualiza con la duración, el estado final y el recuento de errores cuando el programa termina. Ten en cuenta que, como optimización, los programas de corta duración no enviarán dos solicitudes de sesión a Relay, sino solo la final con estado y duración.

<div id="session-aggregates-functionality">
  ### Funcionalidad de agregación de sesiones
</div>

<div id="configuration">
  #### Configuración
</div>

Las sesiones deberían estar habilitadas de forma predeterminada; una sesión comienza en cuanto el servidor web recibe una solicitud y finaliza cuando la respuesta se ha enviado por completo.

<div id="lifetime-of-a-session">
  #### Duración de una sesión
</div>

Las sesiones nunca se rastrean ni se envían de forma individual; en su lugar, se agregan y esos agregados se envían cada 30 s y una última vez cuando el servidor web se está apagando.
Como sugerencia de implementación del punto anterior: cuando se cierre o se vacíe un "Client", también se deberá vaciar el "Session Flusher" asociado y enviar los agregados actuales al transporte, antes de vaciar/cerrar el transporte.
Asegúrate de que esto funcione razonablemente en entornos Serverless: allí no debemos usar "request mode" ni "Session Flusher" porque no podemos realizar trabajo fuera del flujo de solicitud-respuesta.
Ofrece una forma sencilla de integrarse con frameworks existentes de Node (Express, Next.js, Koa).

<div id="session-update-filtering">
  ### Filtrado de actualización de sesión
</div>

Nuestros mecanismos de filtrado (tasa de muestreo, limitación de velocidad, beforeSend, procesadores de eventos o tipos de excepciones ignoradas) pueden descartar eventos. Solo los eventos descartados por muestreo o limitación de velocidad deberían actualizar la sesión a pesar de ser descartados, ya que asumimos que se descartaron para ahorrar cuota, pero serían algo relevante para el desarrollador. Los eventos descartados por otras razones no deberían actualizar la sesión, ya que asumimos que es más probable que se descarten porque el propio desarrollador elige ignorarlos.

<div id="filter-order">
  #### Orden de filtrado
</div>

El SDK de Python servirá de referencia aquí. El orden para filtrar eventos de error es:

1. Comprobar tipos de excepciones ignoradas (también llamado `ignore_errors`)
2. Aplicar el `event_processor` con alcance (también llamado `error_processor`)
3. Aplicar el `event_processor` global
4. Aplicar `before_send`
5. Actualizar la sesión si el evento ha llegado hasta aquí
6. Aplicar la tasa de muestreo

<div id="sending-the-session-update">
  #### Envío de la actualización de la sesión
</div>

Si el evento se ha descartado y la sesión se ha actualizado, la actualización de la sesión debe enviarse al servidor sin el evento, en caso de que la sesión haya pasado de estado correcto a con errores, o de cualquier estado a bloqueada, en sesiones atendidas por el usuario.
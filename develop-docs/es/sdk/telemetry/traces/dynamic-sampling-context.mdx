---
title: Contexto de Muestreo Dinámico (DSC)
---

Todos los datos enviados a Sentry acabarán en un [trace](https://docs.sentry.io/concepts/key-terms/tracing/distributed-tracing/#traces-transactions-and-spans). Los traces se pueden muestrear con las opciones <Link to="/sdk/performance/#tracessamplerate">`tracesSampleRate`</Link> o <Link to="/sdk/performance/#tracessampler">`tracesSampler`</Link> de los SDK.

Cambiar esas opciones tiene varias consecuencias para quienes usan los SDK de Sentry:

* Cambiar la tasa de muestreo implicaba volver a desplegar las aplicaciones (lo cual es problemático en aplicaciones que no se actualizan automáticamente, como las móviles o el software distribuido físicamente) o crear sistemas complejos para obtener dinámicamente una tasa de muestreo.
* La estrategia de muestreo utiliza muestreo aleatorio simple basado en el inicio del trace (head-based).
* Definir reglas de muestreo, por ejemplo, basadas en parámetros del evento, es muy complejo. A veces incluso requiere que los usuarios comprendan en detalle el esquema del evento.
* Aunque es posible escribir reglas para **transacciones** individuales, hacerlas cumplir en **traces** completos es inviable.

La solución para esto es el **muestreo dinámico**. El muestreo dinámico permite que Sentry ajuste automáticamente la cantidad de datos retenidos según el valor de esos datos. Para más información, consulta [Dynamic Sampling](/es/dynamic-sampling/).

<div id="high-level-problem-statement">
  ## Planteamiento del problema a alto nivel
</div>

<div id="ingest">
  ### Ingesta
</div>

Implementar Dynamic Sampling conlleva desafíos, especialmente en la parte de ingesta.
Con Dynamic Sampling, queremos tomar decisiones de muestreo para trazas completas.
Sin embargo, para mantener la ingesta ágil, Relay solo observa transacciones individuales de forma aislada (en lugar de analizar trazas completas).
Esto significa que necesitamos exactamente la misma base de decisión para todas las transacciones que pertenecen a una traza.
En otras palabras, todas las transacciones de una traza deben contener toda la información necesaria para tomar una decisión de muestreo, y esa **información debe ser la misma en todas las transacciones de la traza**.
Llamamos a la información en la que basamos las decisiones de muestreo **“Dynamic Sampling Context”** o **“DSC”**.

Actualmente, podemos hacer muestreo dinámico de dos maneras. Primero, podemos hacer muestreo dinámico en transacciones individuales. Para este proceso, Relay revisa la carga útil del evento entrante para tomar decisiones. Segundo, podemos hacer muestreo dinámico a lo largo de una traza completa. Para este proceso, Relay depende de un **Dynamic Sampling Context**.

Como modelo mental:
La transacción inicial de una traza determina el Dynamic Sampling Context para todas las transacciones siguientes de esa traza.
No se puede cambiar, agregar ni eliminar información después de la primera propagación.
El Dynamic Sampling Context está vinculado a una única traza en particular y a todas las transacciones que forman parte de esa traza.
Varias trazas distintas pueden y deben tener diferentes Dynamic Sampling Contexts.

<div id="sdks">
  ### SDKs
</div>

Los SDKs son responsables de propagar un **&quot;Dynamic Sampling Context&quot;** o **&quot;DSC&quot;** en todas las aplicaciones que forman parte de un trazo.
Esto implica:

1. Si hay una solicitud entrante, extraer el DSC de las solicitudes entrantes.
2. Si no hay una solicitud entrante, crear un nuevo DSC recopilando los datos que lo componen.
3. Propagar el DSC a los SDKs posteriores (a través del encabezado `baggage`).
4. Enviar el DSC a Sentry (a través del encabezado `trace` del envelope).

Para alinear la propagación del DSC en todos nuestros SDKs, definimos un [mecanismo de propagación unificado](#unified-propagation-mechanism) (instrucciones paso a paso) que todas las implementaciones de SDK deberían poder seguir.

<div id="dsc-specification">
  ## Especificación de DSC
</div>

Todos los atributos de la tabla a continuación son necesarios (no opcionales) en el sentido de que, cuando un SDK los conoce en el momento de enviar a Sentry un sobre con un evento (transacción o error), o en el momento de propagar un encabezado baggage, también deben incluirse en dicho sobre o baggage.

Por el momento, solo `release`, `environment` y `transaction` los utiliza el producto para la funcionalidad de muestreo dinámico.
El resto de los atributos de contexto, `trace_id`, `public_key`, `sampled` y `sample_rate`, los utiliza Relay para decisiones internas y para extrapolación en el producto.
Entradas adicionales como `replay_id`, `org_id` y `sample_rand` solo usan el DSC como medio de transporte.

| Atributo                    | Tipo   | Descripción                                                                                                                  | Ejemplo                              | Nivel requerido                      |
| --------------------------- | ------ | ---------------------------------------------------------------------------------------------------------------------------- | ------------------------------------ | ------------------------------------ |
| `trace_id`                  | string | El ID de traza original generado por el SDK. Debe coincidir con el ID de traza del elemento de transacción enviado. [1]     | `771a43a4192642f0b136d5159a501700`   | estrictamente requerido [0]          |
| `public_key`                | string | Clave pública del DSN utilizada por el SDK. [2]                                                                              | `49d0f7386ad645858ae85020e393bef3`   | estrictamente requerido [0]          |
| `sample_rate`               | string | La tasa de muestreo definida por el usuario en el SDK. [3] [4]                                                               | `0.7`                                | estrictamente requerido [0]          |
| `sample_rand`               | string | Número aleatorio generado al inicio de una traza por la cabeza de la traza del SDK. [4]                                      | `0.5`                                | requerido                            |
| `sampled`                   | string | `"true"` si la traza está muestreada; `"false"` en caso contrario. Esto lo establece la cabeza de la traza del SDK. [4]      | `true`                               | requerido                            |
| `release`                   | string | El nombre de la release según se especifica en las opciones del cliente.                                                     | `myapp@1.2.3`, `1.2.3`, `2025.4.107` | requerido                            |
| `environment`               | string | El nombre del entorno según se especifica en las opciones del cliente.                                                       | `production`, `staging`              | requerido                            |
| `transaction`               | string | El nombre de la transacción establecido en el scope. **Incluir solo** si el nombre tiene [buena calidad](#note-on-good-quality-transaction-names). | `/login`, `myApp.myController.login` | requerido (si se conoce y es de buena calidad) |
| `org_id`                    | string | El ID de la organización obtenido del DSN o recibido por un SDK descendente.                                                 | `1`                                  | requerido                            |
| `user_segment` [DEPRECATED] | string | Segmento de usuario establecido por el usuario con `scope.set_user()`.                                                       |                                      | obsoleto                             |

0: En cualquier caso, `trace_id`, `public_key` y `sample_rate` siempre deberían ser conocidos por un SDK, por lo que estos valores son estrictamente requeridos.

1: UUID v4 codificado como una secuencia hexadecimal sin guiones, es decir, una secuencia de 32 dígitos hexadecimales.

2: Permite a Sentry muestrear trazas que abarcan múltiples proyectos, resolviendo el mismo conjunto de reglas según el proyecto inicial.

3: Esta cadena siempre debe ser un número entre 0 y 1 (inclusive) en una notación compatible con la [especificación JSON](https://www.json.org/json-en.html). Si se utilizó un callback `tracesSampler` para la decisión de muestreo, su resultado debe usarse para `sample_rate` en lugar de `tracesSampleRate` de `SentryOptions`. En caso de que `tracesSampler` devuelva `True`, debe enviarse como `1.0`; `False` debe enviarse como `0.0`.

4: Estos atributos deben cumplir el invariante `sample_rand < sample_rate <=> sampled`.

<Alert level="warning">
  ### Nota sobre nombres de transacción de buena calidad

  Desde la perspectiva de UX del producto Dynamic Sampling, dependemos de que los nombres de transacción (es decir, el atributo `transaction` del DSC) sean de buena calidad.
  Los nombres de transacción de buena calidad son descriptivos, se agrupan correctamente en Sentry, tienen baja cardinalidad y no contienen PII ni otros identificadores.

  Por este motivo: **Solo si un nombre de transacción es de buena calidad debe incluirse en el DSC. De lo contrario, ¡no puede incluirse!**

  ❌ Ejemplos de nombres de transacción de **baja calidad**:

  * `"/organization/601242c3-8f49-4158-aef4-c9e42cb1422c/user/601242c3-8f49-4158-aef4-c9e42cb1422c"`
  * `"UIComponentWithHash_7sd8x823f48_x7b26"`

  ✅ Ejemplos de nombres de transacción de **buena calidad**:

  * `"/organization/:organizationId/user/:userId"`
  * `"UserListUIComponent"`

  Los SDK pueden aprovechar las <Link to="/sdk/data-model/event-payloads/transaction/#transaction-annotations">anotaciones de transacción</Link> (en particular, el `source` del nombre de la transacción) para determinar qué nombres de transacción son de buena calidad.
</Alert>

<div id="dsc-propagation">
  ## Propagación del DSC
</div>

El DSC se envía a dos destinos:

* a Sentry mediante el encabezado de sobre `trace` y
* a los servicios posteriores mediante el encabezado `baggage`.

<div id="envelope-header">
  ### Encabezado de envelope
</div>

El contexto de muestreo dinámico se transfiere a Sentry a través del encabezado de envelope `trace`.
El valor de este encabezado de envelope es un objeto JSON que contiene los campos especificados en la [especificación de DSC](#dsc-specification).

<div id="baggage-header">
  ### Encabezado Baggage
</div>

Elegimos `baggage` como mecanismo de propagación para el DSC. ([Especificación de baggage del W3C](https://www.w3.org/TR/baggage/)).
Baggage es un encabezado HTTP estándar con pares clave-valor codificados como URI.

Para la propagación del DSC, los SDK primero leen el DSC del encabezado `baggage` de las solicitudes/mensajes entrantes.

Para propagar el DSC a SDK/servicios downstream, creamos un encabezado `baggage` (o modificamos uno existente) mediante la instrumentación de solicitudes HTTP.

El encabezado `baggage` solo debe adjuntarse a una solicitud saliente si la URL de la solicitud coincide con al menos una entrada de la opción del SDK [`tracePropagationTargets`](/es/sdk/performance/#tracepropagationtargets), o si esta opción está establecida en `null` o no está configurada.

Los SDK deben establecer todas las claves con el formato &quot;`sentry-[name]`&quot;, donde `[name]` es el atributo en la [Especificación de DSC](#dsc-specification). El prefijo &quot;`sentry-`&quot; sirve para identificar los pares clave-valor establecidos por los SDK de Sentry.

A continuación se muestra un ejemplo de cómo podría ser un encabezado baggage que contenga el Dynamic Sampling Context:

```
baggage: other-vendor-value-1=foo;bar;baz, sentry-trace_id=771a43a4192642f0b136d5159a501700, sentry-public_key=49d0f7386ad645858ae85020e393bef3, sentry-sample_rate=0.01337, sentry-user_id=Am%C3%A9lie, other-vendor-value-2=foo;bar;
```

El prefijo `sentry-` permite que los SDK coloquen directamente todos los pares clave–valor de Sentry del `baggage` en el encabezado del envelope, tras eliminar el prefijo `sentry-`.

Poder copiar sin más los pares clave–valor del encabezado `baggage` al encabezado del envelope `trace` nos da la flexibilidad de ofrecer métodos de API específicos para propagar valores adicionales usando Dynamic Sampling Context.
Esto, a su vez, permite que los usuarios definan sus propios valores en el Dynamic Sampling Context para poder muestrear en función de ellos en la interfaz de Sentry.

<Alert>
  #### Nota sobre encabezados `baggage` de otros proveedores

  Otros proveedores también podrían estar usando el encabezado `baggage`.
  Si ya existe un encabezado `baggage` en una solicitud saliente, los SDK deben procurar ser buenos ciudadanos y solo **agregar** valores de Sentry al encabezado.

  En los casos en que no podamos acceder a los encabezados de la solicitud saliente, es válido añadir un encabezado `baggage` separado solo para Sentry y confiar en que los servidores posteriores los unan eventualmente ([RFC 2616](https://www.rfc-editor.org/rfc/rfc2616#section-4.2)).

  Si otro proveedor añadió valores de Sentry a una solicitud saliente, los SDK pueden sobrescribir esos valores.

  Los SDK no deben añadir el baggage de otros proveedores de solicitudes entrantes a solicitudes salientes.
  Los SDK de Sentry solo se ocupan del baggage de Sentry.

  En el SDK de Java ([1](https://github.com/getsentry/sentry-java/blob/725a1edc2b1c713f4d91fef6985e9c98ef2bd873/sentry/src/main/java/io/sentry/Span.java#L149-L150) [2](https://github.com/getsentry/sentry-java/blob/725a1edc2b1c713f4d91fef6985e9c98ef2bd873/sentry/src/main/java/io/sentry/BaggageHeader.java#L15-L26)) optamos por un parámetro explícito para pasar encabezados preexistentes en la solicitud saliente (`span.toBaggageHeader(preExistingBaggageHeaders)`), ya que son necesarios para generar un nuevo encabezado que respete los límites y solo contenga valores de Sentry una vez. Como alternativa, se puede usar alguna función utilitaria que haga la fusión (como se hace, por ejemplo, en el [SDK de Dart](https://github.com/getsentry/sentry-dart/blob/c2653112519fb98ceecaf3eeb8106c5ecf38fe40/dart/lib/src/utils/tracing_utils.dart#L9-L41)).
</Alert>

<div id="freezing-dynamic-sampling-context">
  ### Congelación del Contexto de Muestreo Dinámico
</div>

Como se mencionó arriba, para poder tomar decisiones de muestreo para trazas completas, el Contexto de Muestreo Dinámico debe ser el mismo en todas las transacciones de una traza.

**¿Qué significa esto para los SDK?**

Al iniciar una nueva traza, los SDK ya no pueden alterar el DSC para esa traza en cuanto este salga por primera vez de los límites del SDK.
El DSC se considera entonces &quot;congelado&quot;.
El DSC sale de los SDK en dos situaciones:

* Cuando se realiza una solicitud saliente con un encabezado `baggage` que contiene el DSC.
* Cuando se envía a Sentry un sobre de transacción que contiene el DSC.

Cuando un SDK recibe una solicitud HTTP que fue “instrumentada” o “trazada” por un SDK de Sentry, el SDK receptor debe considerar el DSC entrante como congelado de inmediato.
Cualquier valor del DSC debe propagarse tal cual; esto incluye valores como “environment” o “release”.

Los SDK deben reconocer las solicitudes entrantes como “instrumentadas” o “trazadas” cuando se cumple al menos una de las siguientes condiciones:

* La solicitud entrante tiene un encabezado `sentry-trace`.
* La solicitud entrante tiene un encabezado `sentry-trace` y un encabezado `baggage` que contiene una o más claves que empiezan con `sentry-`.

Una vez que el DSC de una traza determinada se haya congelado, llamadas de API como `set_user` no deben tener efecto sobre el DSC.

<div id="unified-propagation-mechanism">
  ### Mecanismo de propagación unificado
</div>

Los SDK deben seguir estos pasos para cualquier petición entrante y saliente (en seudocódigo de Python con fines ilustrativos):

```python
def collect_dynamic_sampling_context():
  # Función placeholder que recopila tantos valores como sea posible para el Contexto de Muestreo Dinámico
  # y devuelve un diccionario

def has_sentry_value_in_baggage_header(request):
  # Función placeholder que devuelve True cuando hay al menos un par clave-valor en el encabezado baggage
  # de `request`, cuya clave comienza con "sentry-". De lo contrario, devuelve False.

def on_incoming_request(request):
  if request.has_header("sentry-trace") and (not request.has_header("baggage") or not has_sentry_value_in_baggage_header(request)):
    # La solicitud proviene de un SDK antiguo que aún no soporta el Contexto de Muestreo Dinámico
    # --> no propagamos baggage para este trace
    current_transaction.dynamic_sampling_context_frozen = True
  elif request.has_header("sentry-trace") and request.has_header("baggage") and has_sentry_value_in_baggage_header(request):
    current_transaction.dynamic_sampling_context_frozen = True
    current_transaction.dynamic_sampling_context = baggage_header_to_dict(request.headers.baggage)

def on_outgoing_request(request):
  if not current_transaction.dynamic_sampling_context_frozen:
    current_transaction.dynamic_sampling_context_frozen = True
    current_transaction.dynamic_sampling_context = merge_dicts(collect_dynamic_sampling_context(), current_transaction.dynamic_sampling_context)

  if not current_transaction.dynamic_sampling_context:
    # Asegurarse de que haya al menos un DSC vacío establecido en la transacción
    # Esto es independiente de si está bloqueado o no
    current_transaction.dynamic_sampling_context = {}

  if request.has_header("baggage"):
    outgoing_baggage_dict = baggage_header_to_dict(request.headers.baggage)
    merged_baggage_dict = merge_dicts(outgoing_baggage_dict, current_transaction.dynamic_sampling_context)
    request.set_header("baggage", dict_to_baggage_header(merged_baggage_dict))
  else:
    request.set_header("baggage", dict_to_baggage_header(current_transaction.dynamic_sampling_context))
```

Si bien aún no es estrictamente necesario el indicador `current_transaction.dynamic_sampling_context_frozen`, existe un caso de uso futuro en el que lo necesitaremos:
Podríamos querer permitir que los usuarios establezcan por sí mismos los valores del Dynamic Sampling Context.
El indicador cobra relevancia después de la primera propagación, cuando el Dynamic Sampling Context se vuelve inmutable.
Cuando los usuarios intenten establecer el DSC después de eso, nuestros SDK deberían convertir esta operación en un no-op.

<div id="considerations-and-challenges">
  ## Consideraciones y desafíos
</div>

Esta sección detalla algunas preguntas abiertas y consideraciones que deben abordarse en torno al muestreo dinámico y al uso del mecanismo de propagación de baggage.
Estas no son barreras para la adopción de la especificación, sino que están aquí como contexto para futuros desarrollos del producto y la especificación de muestreo dinámico.

<div id="the-temporal-problem">
  ### El problema temporal
</div>

A diferencia de `environment` o `release`, que siempre deberían conocerse por un SDK en el momento de la inicialización, `user_segment` y `transaction` (name) solo se conocen después de inicializar el SDK.
Esto significa que, si se propaga un trace desde una transacción en ejecución ANTES de que se establezcan los atributos de usuario/transacción, obtendrás algunas transacciones dentro de un mismo trace con un Dynamic Sampling Context distinto al de otras, lo que provoca que el muestreo dinámico a lo largo de un trace no funcione como los usuarios esperarían.

Supongamos que queremos hacer muestreo dinámico en una aplicación de navegador basado en `user_segment`.
En una aplicación de una sola página (SPA) típica, la información del usuario debe solicitarse a algún servicio de backend antes de poder establecerla con `Sentry.setUser` en el frontend.

Aquí tienes un ejemplo de ese flujo:

* La página empieza a cargarse
* Sentry se inicializa y comienza la transacción `pageload`
* La página hace una solicitud HTTP al servicio de usuario para obtener al usuario (propaga sentry-trace/baggage al servicio de usuario)
  * el servicio de usuario continúa el trace creando automáticamente una transacción de muestreo
  * el servicio de usuario consulta al servicio de base de datos (propaga sentry-trace/baggage al servicio de base de datos)
  * el servicio de base de datos continúa el trace creando automáticamente una transacción de muestreo
* La página obtiene datos del servicio de usuario, llama a `Sentry.setUser` y establece `user_segment`
* La página hace solicitudes HTTP al servicio A, servicio B y servicio C (propaga sentry-trace/baggage a los servicios A, B y C)
  * El DSC se propaga con baggage a los servicios A, B y C, por lo que hay 3 transacciones hijas
* La página termina de cargar, finalizando la transacción `pageload`, que se envía a Sentry

En este caso, el baggage que se propaga al servicio de usuario y al servicio de base de datos downstream no incluye el valor de `user_segment`, porque aún no se había establecido en el SDK del navegador.
Por lo tanto, cuando Relay intenta muestrear dinámicamente las transacciones de los servicios de usuario y de base de datos basándose en `user_segment`, no podrá hacerlo.
Además, dado que el DSC se congela después de enviarse, el DSC enviado a los servicios A, B y C tampoco incluirá `user_segment`. Esto significa que tampoco se muestreará correctamente si hay una regla de DS a nivel de trace basada en `user_segment`.

Para el nombre de `transaction`, el problema es similar, pero se debe a la parametrización.
En la medida de lo posible, los SDK intentarán parametrizar los nombres de transacción (p. ej., convertir `/teams/123/user/456` en `/teams/:id/user/:id`) para que transacciones similares se agrupen en la interfaz.
Esto mejora tanto las estadísticas agregadas de transacciones como la experiencia general de uso del producto (configurar alertas, revisar métricas como Web Vitals, etc.).
En algunos frameworks, por ejemplo React Router v4 - v6, parametrizamos el nombre de la transacción después de que la transacción haya comenzado debido a limitaciones del propio framework.
Para ilustrarlo, veamos otro ejemplo:

* La página empieza a cargarse
* Sentry se inicializa y comienza la transacción `pageload` (con nombre de transacción `/teams/123/user/456`, basado en la URL de la ventana)
* La página hace una solicitud HTTP al servicio A (propaga sentry-trace/baggage al servicio de usuario)
* La página se renderiza con React Router, lo que desencadena la parametrización del nombre de la transacción (`/teams/123/user/456` -&gt; `/teams/:id/user/:id`)
* La página termina de cargar, finalizando la transacción `pageload`, que se envía a Sentry

Cuando la transacción `pageload` aparezca en Sentry, se llamará `/teams/:id/user/:id`, pero el Dynamic Sampling Context habrá propagado `/teams/123/user/456`, lo que significa que la transacción del servicio A no se verá afectada por ninguna regla de muestreo dinámico a nivel de trace aplicada al nombre de la transacción.
Esto será muy confuso para los usuarios, ya que, en la práctica, el nombre de la transacción que creen que funciona no lo hará.

<div id="choosing-baggage-as-the-propagation-mechanism">
  ### Elegir Baggage como mecanismo de propagación
</div>

Para más información, consulta el [DACI sobre el uso de Baggage](https://www.notion.so/sentry/Trace-Context-vs-Baggage-f541525012344111921b6aa7bfd78dc4) (solo empleados de Sentry).

Antes usábamos la [especificación W3C Trace Context](https://www.w3.org/TR/trace-context/) como mecanismo para propagar el contexto de muestreo dinámico entre SDK.
Sin embargo, cambiamos a la [especificación W3C Baggage](https://www.w3.org/TR/baggage) porque era más fácil de usar, requería menos código del lado del SDK y tenía límites de tamaño mucho más amplios que la especificación de Trace Context.
Para evitar colisiones con claves definidas por el usuario —dado que Baggage es un estándar abierto— decidimos anteponer el prefijo `sentry-` a todas las claves relacionadas con Sentry como espacio de nombres.
Esto nos permitió usar Baggage como estándar abierto ocupándonos únicamente de los datos de Sentry.

Consulta también los [límites de tamaño de Baggage](https://www.w3.org/TR/baggage/#limits) para más detalles.
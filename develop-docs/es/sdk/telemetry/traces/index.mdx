---
title: Trazas
sidebar_order: 7
---

Este documento explica cómo los SDK deben añadir compatibilidad con el monitoreo de rendimiento mediante [Distributed
Tracing](https://docs.sentry.io/product/performance/distributed-tracing/).

Ofrece una visión general de las API que los SDK necesitan implementar, sin
imponer detalles de implementación interna.

Implementaciones de referencia:

* [JavaScript SDK](https://github.com/getsentry/sentry-javascript/tree/master/packages/core/src/tracing)
* [Python SDK](https://github.com/getsentry/sentry-python/blob/master/sentry_sdk/tracing.py)

<Alert>
  Este documento utiliza la notación estándar de intervalos, donde `[` y `]` indican intervalos cerrados, que incluyen los extremos, mientras que `(` y `)` indican intervalos abiertos, que excluyen los extremos. Un intervalo `[x, y)` abarca todos los valores desde `x` hasta, pero sin incluir, `y`.
</Alert>

<div id="sdk-configuration">
  ## Configuración del SDK
</div>

Esta sección describe las opciones que los SDK deberían exponer para configurar el rastreo y el monitoreo del rendimiento.

El rastreo se habilita definiendo `tracesSampleRate` o `tracesSampler`. Si no se establecen, estas opciones usan por defecto `undefined` o `null`, por lo que el rastreo pasa a ser opcional.

<div id="enabletracing">
  ### `enableTracing`
</div>

Esta opción está **en desuso** y debe retirarse de todos los SDK.

<div id="tracessamplerate">
  ### `tracesSampleRate`
</div>

Debe ser un número de coma flotante en el rango `[0, 1]` y representa la probabilidad (en porcentaje) de que cualquier transacción se envíe a Sentry. Así que, salvo [influencias externas](#sampling), `0.0` garantiza un 0% de probabilidad (no se enviará ninguna) y `1.0` garantiza un 100% (se enviarán todas). Esta tasa se aplica por igual a todas las transacciones; en otras palabras, cada transacción tiene la misma probabilidad de marcarse como `sampled = true`, según el `tracesSampleRate`.

Consulta más sobre cómo debe realizarse el muestreo [más abajo](#sampling).

<div id="tracessampler">
  ### `tracesSampler`
</div>

Debe ser una función de callback que se activa cuando se inicia una transacción. Debe recibir un objeto `samplingContext` y devolver una tasa de muestreo en el rango `[0, 1]` para *la transacción en cuestión*. Esta tasa de muestreo debe comportarse igual que `tracesSampleRate` de arriba. La única diferencia es que solo se aplica a la transacción recién creada y que distintas transacciones pueden muestrearse a diferentes tasas. Devolver `0.0` debe forzar que la transacción se descarte (estableciendo `sampled = false`) y devolver `1.0` debe forzar que la transacción se envíe (estableciendo `sampled = true`).

Históricamente, el callback `tracesSampler` también podía devolver un booleano para forzar una decisión de muestreo (con `false` equivalente a `0.0` y `true` equivalente a `1.0`). Este comportamiento ahora está **en desuso** y debe eliminarse de todos los SDK.

Consulta más información sobre cómo realizar el muestreo [más abajo](#sampling).

<div id="tracepropagationtargets">
  ### `tracePropagationTargets`
</div>

Los SDK de Sentry propagan la información de trazas a SDK aguas abajo mediante encabezados en las solicitudes HTTP salientes. La opción `tracePropagationTargets` ofrece a los usuarios un mecanismo para controlar a qué solicitudes HTTP salientes se les deben adjuntar estos encabezados. Por ejemplo, los usuarios pueden especificar esta propiedad para mantener la propagación de trazas dentro de su infraestructura y así evitar que los datos de los encabezados se envíen a servicios de terceros.

Esta opción acepta una matriz de cadenas y/o expresiones regulares. Los SDK solo deben agregar encabezados de traza a una solicitud saliente si la URL de la solicitud coincide con la expresión regular o, en el caso de literales de cadena, contiene al menos uno de los elementos de la matriz. Los literales de cadena no tienen que ser coincidencias exactas; es decir, la URL de una solicitud se considera coincidente cuando contiene una cadena proporcionada mediante la opción.

Los SDK pueden elegir un valor predeterminado que tenga sentido para su caso de uso. La mayoría de los SDK usan por defecto la expresión regular `.*` (lo que significa que adjuntan encabezados a todas las solicitudes salientes), pero se permite desviarse si es necesario. Por ejemplo, por CORS, los SDK basados en navegador usan por defecto agregar encabezados solo a solicitudes internas del dominio.

Consulta [`sentry-trace`](#header-sentry-trace) y [`baggage`](/es/sdk/performance/dynamic-sampling-context/#baggage-header) para obtener más detalles sobre los encabezados individuales que se adjuntan a las solicitudes salientes.

<div id="example">
  #### Ejemplo
</div>

El siguiente ejemplo muestra qué URL de las solicitudes salientes sí (o no) coincidirían con un array `tracePropagationTargets` dado:

```JS
// Las entradas pueden ser cadenas o expresiones regulares
tracePropagationTargets: ['localhost', /^\// ,/myApi.com\/v[2-4]/]

URLs que coinciden: 'localhost:8443/api/users', 'mylocalhost:8080/api/users', '/api/envelopes', 'myApi.com/v2/projects'
URLs que no coinciden: 'someHost.com/data', 'myApi.com/v1/projects'
```

<Alert title="Desuso de tracingOrigins">
  Esta opción sustituye la opción no estandarizada `tracingOrigins` que antes se usaba en algunos SDK. Se recomienda que los SDK que admiten `tracingOrigins` la deprecen y, eventualmente, eliminen `tracingOrigins` en favor de `tracePropagationTargets`. Si los usuarios especifican ambas opciones, los SDK deben basarse únicamente en el array `tracePropagationTargets`.
</Alert>

<div id="stricttracecontinuation">
  ### `strictTraceContinuation`
</div>

Debe ser un valor booleano. El valor predeterminado es `false`. Esta opción controla la continuación de trazas desde servicios de terceros desconocidos que casualmente estén instrumentados con un SDK de Sentry.

Si el SDK puede extraer un ID de organización del DSN configurado, debe propagarse como una entrada de baggage con la clave `sentry-org_id`. Dado un DSN como `https://1234@o1.ingest.us.sentry.io/1`, el ID de organización es `1`, derivado de `o1`.

Además, el SDK debe poder configurarse con la opción opcional `orgId: <org-id>`, que tiene prioridad sobre el valor obtenido del DSN. Esta opción debe establecerse al ejecutar una versión autogestionada (self-hosted) de Sentry o si se usa un DSN no estándar de Sentry, como al usar un Relay local.

En las trazas entrantes, el SDK debe comparar el valor de `sentry-org_id` en el baggage con su propio valor derivado del DSN o de la configuración de la organización. Solo si ambos coinciden, se continúa la traza. Si no coinciden, ni el ID de traza, ni la decisión de muestreo del padre ni el baggage deben tenerse en cuenta.
En ese caso, el SDK debe comportarse como si fuera el inicio de la traza y no considerar ningún valor propagado.

Este comportamiento puede desactivarse estableciendo `strictTraceContinuation: false` en la llamada de inicialización del SDK.
Inicialmente, los SDK deben introducir esta opción con el valor predeterminado `false`.
Una vez que la mayoría de los SDK hayan incorporado esta opción, cambiaremos el valor predeterminado a `true` (en una versión principal), convirtiéndolo en opt‑out.

Independientemente de que `strictTraceContinuation` esté establecida en `true` o `false`, si el SDK está configurado con una `org` o pudo obtener el valor del DSN, las trazas entrantes que contengan un valor de `org` en el baggage que no coincida con el del SDK receptor no se continuarán.

Ejemplos:

* baggage: `sentry-org: 1`, SDK config: `org: 1, strictTraceContinuation: false` -&gt; continuar traza

* baggage: `sentry-org: none`, SDK config: `org: 1, strictTraceContinuation: false` -&gt; continuar traza

* baggage: `sentry-org: 1`, SDK config: `org: none, strictTraceContinuation: false` -&gt; continuar traza

* baggage: `sentry-org: none`, SDK config: `org: none, strictTraceContinuation: false` -&gt; continuar traza

* baggage: `sentry-org: 1`, SDK config: `org: 2, strictTraceContinuation: false` -&gt; iniciar nueva traza

* baggage: `sentry-org: 1`, SDK config: `org: 1, strictTraceContinuation: true` -&gt; continuar traza

* baggage: `sentry-org: none`, SDK config: `org: 1, strictTraceContinuation: true` -&gt; iniciar nueva traza

* baggage: `sentry-org: 1`, SDK config: `org: none, strictTraceContinuation: true` -&gt; iniciar nueva traza

* baggage: `sentry-org: none`, SDK config: `org: none, strictTraceContinuation: true` -&gt; continuar traza

* baggage: `sentry-org: 1`, SDK config: `org: 2, strictTraceContinuation: true` -&gt; iniciar nueva traza

<div id="traceoptionsrequests">
  ### `traceOptionsRequests`
</div>

Debe ser un valor booleano. El valor predeterminado es `false`. Si se establece en `true`, se crearán transacciones para las solicitudes HTTP `OPTIONS`. Si se establece en `false`, NO se crearán transacciones para las solicitudes HTTP `OPTIONS`. Esta configuración es especialmente útil en los SDK de servidores backend. Si no aplica para un SDK, se puede omitir.

<div id="maxspans">
  ### `maxSpans`
</div>

Dado que las cargas útiles de transacciones tienen un tamaño máximo impuesto en el lado de ingesta, los SDK deberían limitar la cantidad de spans que se adjuntan a una transacción. Esto es similar a cómo se limitan las migas de pan (breadcrumbs) y otras listas de tamaño arbitrario para prevenir usos indebidos accidentales. Si se agregan nuevos spans una vez alcanzado el máximo, el SDK debería descartarlos e idealmente usar el registro interno para ayudar en la depuración.

`maxSpans` debería implementarse como una constante interna no configurable cuyo valor predeterminado sea 1000. Podría volverse configurable si hubiera justificación para ello en una plataforma determinada.

El límite de `maxSpans` también puede ayudar a evitar transacciones que nunca terminan (en plataformas que mantienen una transacción abierta mientras haya spans abiertos), prevenir errores de falta de memoria (OOM) y, en general, evitar la degradación del rendimiento de la aplicación.

<div id="propagatetraceparent">
  ### `propagateTraceparent`
</div>

Debe ser un valor booleano. El valor predeterminado es `false`. Esta opción habilita la propagación del encabezado HTTP del W3C Trace Context `traceparent` en las solicitudes HTTP salientes. Es útil cuando los servicios receptores solo admiten la propagación OTel/W3C.

El encabezado `traceparent` solo se envía cuando `propagateTraceparent` es `true` y la solicitud coincide con `tracePropagationTargets` (misma condición que para `sentry-trace`/`baggage`).

Formato del encabezado:

* Clave: `traceparent`
* Valor: `00-<traceId>-<spanId>-<sampled>`, donde `<sampled>` es `01` si está muestreado; en caso contrario, `00`.

La especificación completa está disponible en [W3C Trace Context](https://www.w3.org/TR/trace-context/).

<div id="traceignorestatuscodes">
  ### `traceIgnoreStatusCodes`
</div>

DEBE ser una colección de enteros que representen códigos de estado HTTP.
Si la plataforma lo permite, la colección TAMBIÉN PUEDE admitir pares de enteros que representen rangos inclusivos de códigos de estado HTTP.

Esta opción aplica exclusivamente a solicitudes entrantes y, por lo tanto, SOLO DEBE implementarse en SDKs de servidor.

El SDK DEBE respetar esta opción inspeccionando el atributo [`http.response.status_code`](https://opentelemetry.io/docs/specs/semconv/registry/attributes/http/#:~:text=1437-,http.response.status_code,-int) en cada transacción/span raíz antes de finalizarla.
Si el valor de este atributo coincide con uno de los códigos de estado en `traceIgnoreStatusCodes`, el SDK DEBE establecer la [decisión de muestreo](https://develop.sentry.dev/sdk/telemetry/traces/#sampling) de la transacción en `not sampled`.

Ten en cuenta que un requisito previo para implementar esta opción es que todas las integraciones de servidor HTTP DEBEN registrar el atributo [`http.response.status_code`](https://opentelemetry.io/docs/specs/semconv/registry/attributes/http/#:~:text=1437-,http.response.status_code,-int) según lo definido en la especificación de OTEL.

El SDK DEBE emitir un registro de depuración indicando por qué se descartó la transacción.
Si el SDK implementa informes del cliente, DEBE registrar la transacción descartada con el motivo de descarte `event_processor`.

Esta opción DEBE tener como valor predeterminado una colección vacía si se introduce en una versión con un incremento menor de SemVer.
Los SDKs DEBERÍAN establecer el valor predeterminado de esta opción al siguiente valor (o equivalente si la implementación no admite pares de enteros)

```
[[301, 303], [305, 399], [401, 404]]
```

en la primera versión posterior con un aumento mayor de SemVer tras su introducción.

La razón de esta opción y su valor predeterminado es no consumir la cuota de spans de un usuario para rastrear solicitudes que no aportan nada a la depuración (y que a menudo pueden ser activadas por bots de escaneo).

Ejemplos:
`[403, 404]`: no muestres transacciones correspondientes a solicitudes con código de estado 403 o 404
`[[300, 399], [401, 404]]`: no muestres transacciones correspondientes a solicitudes con códigos de estado entre 300 y 399 (ambos incluidos) o entre 401 y 404 (ambos incluidos)

<div id="enabledbquerysource">
  ### `enableDbQuerySource`
</div>

ESTE DEBE ser un valor booleano cuyo valor predeterminado es `true`.

Esta opción controla si se establecen atributos con información de origen del código en los spans de consultas a la base de datos cuando la duración de la consulta supera un umbral determinado.

Los siguientes atributos, o un subconjunto de ellos, DEBERÍAN establecerse en los spans de consultas a la base de datos si se supera el umbral.
Es posible que los valores de algunos de los atributos a continuación no estén disponibles para el SDK en ciertas situaciones y, en esos casos, SE PUEDE proporcionar un subconjunto.

Los atributos se describen en la <Link to="https://getsentry.github.io/sentry-conventions/generated/attributes/code.html">documentación sobre convenciones de spans de Sentry</Link>.

* code.file.path
* code.function.name
* code.line.number

<div id="dbquerysourcethresholdms">
  ### `dbQuerySourceThresholdMs`
</div>

Un umbral de duración, que DEBE ser un valor de punto flotante o entero.
El valor especifica, en milisegundos, el tiempo de una consulta a la base de datos a partir del cual se agrega la información del origen del código.

El valor predeterminado depende de la plataforma y DEBERÍA equilibrar la sobrecarga de agregar esta información con su utilidad para las consultas que superen el umbral para los usuarios del SDK.
En Python y en PHP (Laravel), el umbral predeterminado es de 100 milisegundos.

<div id="enablehttprequestsource">
  ### `enableHttpRequestSource`
</div>

DEBE ser un valor booleano cuyo valor predeterminado es `true`.

Esta opción controla si se establecen atributos con información de origen del código en las solicitudes HTTP salientes.
Cuando está habilitada, los atributos SOLO DEBERÍAN adjuntarse cuando el tiempo de respuesta desde el envío de la solicitud supere un umbral determinado.

Los siguientes atributos, o un subconjunto de ellos, DEBERÍAN establecerse si se supera el umbral.
Es posible que los valores de algunos de los atributos siguientes no estén disponibles para el SDK en ciertas situaciones; en esos casos, SE PUEDE proporcionar un subconjunto.

Los atributos se describen en la <Link to="https://getsentry.github.io/sentry-conventions/generated/attributes/code.html">documentación de la convención de spans de Sentry</Link>.

* code.file.path
* code.function.name
* code.line.number

<div id="httprequestsourcethresholdms">
  ### `httpRequestSourceThresholdMs`
</div>

Una duración umbral, que DEBE ser un valor de punto flotante o entero.
El valor especifica, en milisegundos, el tiempo transcurrido entre enviar una solicitud HTTP y recibir su respuesta, a partir del cual se añade información sobre el origen del código.

El valor predeterminado depende de la plataforma y DEBERÍA equilibrar la sobrecarga de añadir esa información con su utilidad para ciclos de solicitud-respuesta que superen la duración umbral para los usuarios del SDK.

<div id="event-changes">
  ## Cambios en `Event`
</div>

Al momento de escribir esto, las transacciones se implementan como una extensión del modelo `Event`.

La característica distintiva de una `Transaction` es `type: "transaction"`.

Además, `Event` incorpora nuevos campos: `spans`, `contexts.TraceContext`.

<div id="new-span-and-transaction-classes">
  ## Nuevas clases `Span` y `Transaction`
</div>

En memoria, los spans conforman un árbol conceptual de operaciones temporizadas. Llamamos transacción a todo el árbol de spans. A veces usamos el término &quot;transacción&quot; para referirnos al árbol de spans en su conjunto y, otras, específicamente al span raíz del árbol.

Por la red, las transacciones se serializan a JSON como un `Event` ampliado y se envían como envelopes. Los distintos tipos de envelope sirven para optimizar la ingesta (así podemos enrutar los &quot;transaction events&quot; de forma diferente a otros eventos, sobre todo los &quot;error events&quot;).

En la interfaz de Sentry, puedes usar Discover para ver todos los eventos sin importar el tipo, y las secciones Issues y Performance para profundizar en errores y transacciones, respectivamente. La [documentación de tracing para usuarios](https://docs.sentry.io/product/performance/distributed-tracing/#traces-transactions-and-spans) explica más conceptos a nivel de producto.

La clase [Span](/es/sdk/data-model/event-payloads/span/) almacena cada span individual en un
trace.

La clase [Transaction](/es/sdk/data-model/event-payloads/transaction/) es como un span, con unas
pocas diferencias clave:

* Las transacciones tienen `name`; los spans, no.
* Las transacciones deben especificar la [source](/es/sdk/data-model/event-payloads/transaction/#transaction-annotations) de su `name` para indicar cómo se generó el nombre de la transacción.
* Llamar al método `finish` en spans registra la marca de tiempo de finalización del span. En el caso de las
  transacciones, el método `finish` además envía un evento a Sentry.

La clase `Transaction` puede heredar de `Span`, pero eso es un detalle de implementación. Semánticamente, las transacciones representan tanto el span de nivel superior de un árbol de spans como la unidad de reporte a Sentry.

* Interfaz `Span`

  * Cuando se crea un `Span`, establece `startTimestamp` en la hora actual
  * `SpanContext` es la colección de atributos de un `Span` (puede ser un detalle de implementación). Cuando sea posible, `SpanContext` debería ser inmutable.
  * `Span` debería tener un método `startChild` que cree un nuevo span con el id del span actual como `parentSpanId` del nuevo span y con el valor de `sampled` del span actual copiado en la propiedad `sampled` del nuevo span
  * El método `startChild` debe respetar el límite `maxSpans`, y una vez alcanzado el límite, el SDK no debe crear nuevos spans hijo para la transacción dada.
  * `Span` debería tener un método llamado `toSentryTrace` que devuelva una cadena que pueda enviarse como un encabezado llamado `sentry-trace`.
  * `Span` debería tener un método llamado `iterHeaders` (adaptar a las convenciones de nomenclatura de la plataforma) que devuelva un iterable o mapa de nombres de encabezados y valores. Es un contenedor ligero que por ahora simplemente hace `return {"sentry-trace": toSentryTrace()}`. Consulta `continueFromHeaders` para entender por qué existe y por qué debería preferirse al escribir integraciones.

* Interfaz `Transaction`

  * `Transaction` mantiene internamente una lista plana de spans hijo (no una estructura en árbol)
  * `Transaction` además tiene un método `setName` que establece el nombre de la transacción
  * `Transaction` recibe un `TransactionContext` al crearse (la propiedad nueva vs. en `SpanContext` es `name`)
  * Dado que un `Transaction` hereda de un `Span`, tiene todas las funciones disponibles y se puede interactuar con él como si fuera un `Span`
  * Una transacción está muestreada (`sampled = true`) o no muestreada (`sampled = false`), decisión que se hereda o se establece una sola vez durante la vida de la transacción y, en cualquier caso, se propaga a todos los hijos. Las transacciones no muestreadas no deben enviarse a Sentry.
  * `TransactionContext` debería tener un método estático/ctor llamado `fromSentryTrace` que precomplete un `TransactionContext` con datos recibidos de un valor de encabezado `sentry-trace`
  * `TransactionContext` debería tener un método estático/ctor llamado `continueFromHeaders(headerMap)` que, por ahora, es solo un contenedor ligero alrededor de `fromSentryTrace(headerMap.get("sentry-trace"))`. Esto debería preferirse por parte de autores de integraciones/framework-sdk frente a `fromSentryTrace`, ya que oculta los nombres exactos de los encabezados usados más profundamente en el SDK central y deja margen para usar encabezados adicionales (del W3C) en el futuro sin cambiar todas las integraciones.

* `Span.finish()`

  * Acepta un `endTimestamp` opcional para permitir que los usuarios establezcan un `endTimestamp` personalizado en el span finalizado
  * Si no se proporciona un valor de `endTimestamp`, establece `endTimestamp` en la hora actual (en la carga `timestamp`)

* `Transaction.finish()`
  * `super.finish()` (llamar a finish en Span)
  * Enviarlo a Sentry solo si `sampled == true`
  * Al igual que los spans, se le puede dar un valor opcional `endTimestamp` que debe pasarse en la llamada a `span.finish()`
  * Un `Transaction` debe empaquetarse en un `Envelope` y enviarse al [Endpoint de Envelope](/es/sdk/data-model/envelopes/)
  * El `Transport` debe usar la misma cola interna para `Transactions` / `Events`
  * El `Transport` debe implementar limitación de frecuencia basada en categorías →
  * El `Transport` debe encargarse internamente de empaquetar un `Transaction` en un `Envelope`

<div id="sampling">
  ## Muestreo
</div>

Cada transacción tiene una *decisión de muestreo*, es decir, un valor booleano que indica si debe enviarse o no a Sentry. Esto debe definirse exactamente una vez durante la vida de la transacción y almacenarse en un booleano interno `sampled`.

Hay varias formas en que una transacción puede tener una decisión de muestreo:

* Muestreo aleatorio según una tasa de muestreo estática establecida en `tracesSampleRate`
* Muestreo aleatorio según una tasa de muestreo dinámica devuelta por `tracesSampler`
* Decisión absoluta (probabilidad del 100% o del 0%) devuelta por `tracesSampler`
* Si la transacción tiene un padre, heredando la decisión de muestreo del padre
* Decisión absoluta pasada a `startTransaction`

Si más de una opción pudiera aplicar, las siguientes reglas determinan cuál tiene prioridad:

1. Si se pasa una decisión de muestreo a `startTransaction` (`startTransaction({name: "my transaction", sampled: true})`), se usará esa decisión, independientemente de cualquier otra cosa.
2. Si `tracesSampler` está definido, se usará su decisión. Puede optar por mantener o ignorar cualquier decisión de muestreo del padre, o usar los datos del contexto de muestreo para tomar su propia decisión o elegir una tasa de muestreo para la transacción.
3. Si `tracesSampler` no está definido, pero existe una decisión de muestreo del padre, se usará la decisión de muestreo del padre.
4. Si `tracesSampler` no está definido y no hay una decisión de muestreo del padre, se usará `tracesSampleRate`.

<Alert title="Nota">
  <markdown>
    Las transacciones deben muestrearse solo mediante `tracesSampleRate` o `tracesSampler`. La configuración `sampleRate` se usa para eventos de error y no debe aplicarse a las transacciones.
  </markdown>
</Alert>

<div id="sampling-context">
  ### Contexto de muestreo
</div>

Si está definido, el callback `tracesSampler` debe recibir un objeto `samplingContext`, que debe incluir, como mínimo:

* El `transactionContext` con el que se creó la transacción
* Un `parentSampleRate` de tipo float/double que contiene la tasa de muestreo heredada del elemento padre
* Un booleano `parentSampled` que contiene la decisión de muestreo heredada del elemento padre, si la hay
* Datos de un objeto opcional `customSamplingContext` pasado a `startTransaction` cuando se invoca manualmente

Según la plataforma, se pueden incluir otros datos predeterminados. (Por ejemplo, en frameworks de servidor, tiene sentido incluir el objeto `request` correspondiente a la solicitud que la transacción está midiendo).

<div id="propagation">
  ### Propagación
</div>

La decisión de muestreo de una transacción debe propagarse a todos sus descendientes, incluso a través de límites entre servicios. Esto puede hacerse en el método `startChild` para descendientes dentro del mismo servicio y usando el header `sentry-trace` para los que están en un servicio diferente.

<div id="propagated-random-value">
  ### Valor aleatorio propagado
</div>

Para aumentar la probabilidad de capturar trazas completas cuando los servicios de backend usan una tasa de muestreo personalizada mediante `tracesSampler`, el SDK propaga el mismo valor aleatorio utilizado para las decisiones de muestreo a todos los servicios de una traza. Esto garantiza decisiones de muestreo coherentes a lo largo de la traza en lugar de generar un nuevo valor aleatorio para cada servicio.

El valor aleatorio (`sample_rand`) se establece según las siguientes reglas:

1. Un `sample_rand` es un número de punto flotante (notación `0.123456`) en el rango `[0, 1)` (incluye 0.0 y excluye 1.0), con seis dígitos después del punto decimal.
2. Cuando el tracing está habilitado y se inicia una nueva traza, el SDK genera un valor `sample_rand` para el contexto de ejecución actual.
3. Esto también aplica al tracing sin Performance, donde simplemente queremos generar `sample_rand` cada vez que se inicia una nueva traza. Este valor `sample_rand` puede almacenarse luego en `PropagationContext`.
4. Se *recomienda* generar el número aleatorio de forma determinista utilizando el ID de la traza como semilla o fuente de aleatoriedad (asegúrate de hacer esto de forma atómica para que varios hilos que acceden a la misma instancia de aleatoriedad no mezclen sus semillas). El método exacto por el que se crea el número aleatorio depende de la implementación y puede variar entre implementaciones del SDK.
5. El `sample_rand` forma parte del DSC (Dynamic Sampling Context) y, como con otros valores del encabezado `baggage`, el `sample_rand` del contexto de ejecución actual debe propagarse a los SDK descendentes. También debe enviarse a otros sistemas como parte del encabezado `baggage` si Performance está deshabilitado y la decisión de muestreo se difiere.
6. En trazas entrantes, un SDK toma el valor `sentry-sample_rand` del encabezado `baggage` y lo usa para el resto del contexto de ejecución actual (por ejemplo, una solicitud) almacenándolo en el `PropagationContext`.
7. Si falta `sample_rand` en una traza entrante, el SDK crea uno nuevo aplicando **reglas especiales** y lo usa para el contexto de ejecución actual:
   1. Si `sample_rate` (dentro de `baggage`) y la decisión de muestreo (el `-1` o `-0` final del encabezado `sentry-trace`) están presentes en la traza entrante, crea un `sample_rand` tal que, al compararlo con el `sample_rate` entrante, conduzca a la misma decisión de muestreo indicada en el encabezado `sentry-trace`. Es decir, para una decisión `True`, genera un número aleatorio en el rango semiabierto `[0, rate)` y, para una decisión `False`, genera un número aleatorio en el rango `[rate, 1)`.
   2. Si falta la decisión de muestreo en la traza entrante, genera un número aleatorio en el rango `[0, 1)` (incluye 0.0 y excluye 1.0), como para una traza nueva.

El SDK siempre debe usar el número aleatorio almacenado (`sentry-sample_rand`) para las decisiones de muestreo y no debe depender directamente de `math.random()` al decidir si muestrear o no:

1. Cuando se invoca `tracesSampler`, el valor devuelto debe compararse con `sample_rand`: `trace["sentry-sample_rand"] < tracesSampler(context)`
2. Cuando hay una traza entrante, el SDK hereda por completo las decisiones de muestreo del encabezado `sentry-trace`.
3. De lo contrario, cuando el SDK es el inicio de una traza (y `tracesSampleRate` está definido), el muestreo se realiza comparando `tracesSampleRate` con `sample_rand`: `trace["sentry-sample_rand"] < config.tracesSampleRate`

Algo que debería documentarse para cada SDK es la forma recomendada de usar un `tracesSampler` para heredar la decisión de muestreo del padre usando `parentSampleRate`. De este modo, Sentry aún puede extrapolar los conteos correctamente:

```js
tracesSampler: ({ name, parentSampleRate }) => {
  // Hereda la tasa de muestreo del trace padre si existe. El muestreo es determinístico
  // para un trace, es decir, si el padre fue muestreado, también lo seremos a la misma
  // tasa.
  if (typeof parentSampleRate === "number") {
    return parentSampleRate;
  }

  // Si no, usa la tasa de muestreo predeterminada (reemplazando tracesSampleRate).
  return 0.5;
},
```

<div id="backpressure">
  ### Contrapresión
</div>

Si el SDK admite la gestión de contrapresión, la tasa de muestreo global debe dividirse por el `downsamplingFactor` del monitor de contrapresión. Consulta [la especificación de contrapresión](/es/sdk/performance/backpressure/#downsampling) para obtener más detalles.

<div id="header-sentry-trace">
  ## Header `sentry-trace`
</div>

El header se usa para la propagación de trazas. Los SDK usan el header para continuar las trazas desde servicios upstream (solicitudes HTTP entrantes) y para propagar información de trazado a servicios downstream (solicitudes HTTP salientes).

`sentry-trace = traceid-spanid-sampled`

`sampled` es opcional. Por lo tanto, como mínimo, se espera:

`sentry-trace = traceid-spanid`

Para ofrecer una compatibilidad mínima con el [header W3C `traceparent`](https://www.w3.org/TR/trace-context/#traceparent-header) (sin el prefijo de versión) y los [headers `b3` de Zipkin](https://zipkin.io/pages/instrumenting#communicating-trace-information) (que consideran válidos tanto 64 como 128 bits para `traceId`), el header `sentry-trace` debe tener un `traceId` de 128 bits codificado en 32 caracteres hexadecimales y un `spanId` de 64 bits codificado en 16 caracteres hexadecimales.
Para evitar confusiones con el header W3C `traceparent` (al que nuestro header es similar pero no idéntico), lo llamamos simplemente `sentry-trace`.
No se define ninguna versión en el header.

El header `sentry-trace` solo debe agregarse a una solicitud saliente si la URL de la solicitud coincide con al menos una entrada de la opción del SDK [`tracePropagationTargets`](#tracepropagationtargets) o si esta opción se establece en `null`.

<div id="the-sampled-value">
  ### El valor `sampled`
</div>

Para simplificar el procesamiento, el valor consta de un único carácter (opcional). Los valores posibles son:

```
  - Sin valor significa diferir

0 - No muestrear

1 - Muestreado
```

A diferencia de los encabezados `b3`, un encabezado `sentry-trace` nunca debe consistir únicamente en una decisión de muestreo, sin valores `traceid` ni `spanid`. Hay [buenas razones](https://github.com/apache/incubator-zipkin-b3-propagation/blob/bc937b6854ea30e46b3e85fbf147d8f4de685dd5/README.md#why-send-trace-ids-with-a-reject-sampling-decision) para incluir siempre `traceid` y `spanid` independientemente de la decisión de muestreo, y hacerlo también simplifica la implementación.

Además de las [razones habituales para usar *defer*](https://github.com/apache/incubator-zipkin-b3-propagation/blob/bc937b6854ea30e46b3e85fbf147d8f4de685dd5/README.md#why-defer-a-sampling-decision), en el caso de Sentry, una razón sería si un sistema posterior captura un evento de error con Sentry. La decisión podría tomarse en ese momento para muestrear ese trace y así disponer de datos de trazabilidad para el fallo reportado.

`sentry-trace = sampled`

Lo cual en realidad es útil para que los proxies lo configuren en `0` y se excluyan del tracing.

<div id="static-api-changes">
  ## Cambios en la API estática
</div>

La función `Sentry.startTransaction` debe aceptar dos argumentos: el `transactionContext` pasado al constructor de `Transaction` y un objeto opcional `customSamplingContext` que contiene datos para pasar a `tracesSampler` (si está definido).
Crea una `Transaction` vinculada al hub actual y devuelve la instancia.
Los usuarios interactúan con la instancia para crear spans secundarios y, por lo tanto, deben
llevar su propio seguimiento.

Con `Sentry.span`, los usuarios pueden adjuntar spans a una transacción ya en curso.
Esta propiedad devuelve un `SpanProtocol` si hay una transacción en ejecución vinculada al
scope; de lo contrario, devuelve nil. Aunque recomendamos que los usuarios lleven el seguimiento
de sus propias transacciones, los SDK deberían ofrecer una forma de exponer transacciones generadas automáticamente.
Los SDK deben vincular las transacciones generadas automáticamente al scope, haciéndolas
accesibles con `Sentry.span`.
Si el SDK tiene habilitado el modo global, que especifica si se debe usar el modo de gestión de scope global y debería ser `true` para aplicaciones cliente y `false` para aplicaciones de servidor, `Sentry.span` devolverá la transacción activa. Si el
usuario deshabilita el modo global, `Sentry.span` devolverá el span activo más reciente (sin finalizar).

<div id="hub-changes">
  ## Cambios en `Hub`
</div>

* Introducir un método llamado `traceHeaders`

  * Esta función devuelve un encabezado (string) `sentry-trace`
  * El valor debe ser la cadena del encabezado de traza del `Span` que está actualmente en el `Scope`

* Introducir un método llamado `startTransaction`

  * Recibe los mismos dos argumentos que `Sentry.startTransaction`
  * Crea una nueva instancia de `Transaction`
  * Debe implementar el muestreo como se describe con más detalle en la sección &#39;Sampling&#39; de este documento

* Modificar el método llamado `captureEvent` o `captureTransaction`
  * No establecer `lastEventId` para las transacciones

{/*
  NOTA: podemos omitir esto como una API en desuso, reemplazada por `startTransaction` y
  `transaction.startChild`, o adoptarla como un atajo para crear un span que
  sea hijo de una transacción existente en el ámbito actual o, en su defecto, un
  span huérfano (que no se enviará a Sentry por sí solo).

  - `Hub` → Introducir un método llamado `startSpan`
    - Crea una nueva instancia de `Span`
    - Si ya hay un `Span` en el `Scope` actual, el `Span` creado
      debería ser su hijo
  */}

<div id="scope-changes">
  ## Cambios en `Scope`
</div>

`Scope` mantiene una referencia al `Span` o `Transaction` actual.

{/*
  TODO: al momento de escribir esto, la referencia en el scope solo se hace para
  transacciones y spans instrumentados automáticamente. Aún está por definirse
  si este comportamiento también aplica a la instrumentación manual.
  */}

* `Scope` Introduce `setSpan`
  * Esto puede usarse internamente para pasar un `Span`/`Transaction` para que las integraciones puedan adjuntarle elementos secundarios
  * Configurar la propiedad `transaction` en el `Scope` (legado) debería sobrescribir el nombre del `Transaction` almacenado en el `Scope`, si lo hay. Con ello damos a los usuarios la opción de cambiar el nombre de la transacción incluso si no tienen acceso directo a la instancia del `Transaction`.

<div id="interaction-with-beforesend-and-event-processors">
  ## Interacción con `beforeSend` y procesadores de eventos
</div>

La devolución de llamada `beforeSend` es un procesador de eventos especial que consideramos de uso más destacado. Los procesadores de eventos propiamente dichos suelen considerarse internos.

Las transacciones **no** deben pasar por `beforeSend`. Sin embargo, sí se procesan mediante procesadores de eventos. Esto es un compromiso entre cierta flexibilidad para tratar con la implementación actual de las transacciones como eventos y dejar espacio para distintos hooks de ciclo de vida para transacciones y spans.

Motivaciones:

1. Preparación para el futuro: si los usuarios dependen de `beforeSend` para transacciones, eso complicaría la eventual implementación de la ingesta de spans individuales sin romper el código del usuario. Al momento de escribir esto, una transacción se envía como un evento, pero eso se considera un detalle de implementación.

2. Compatibilidad de API: los usuarios tienen su implementación existente de `beforeSend` que solo tenía que tratar con eventos de error. Introdujimos las transacciones como un nuevo tipo de evento. A medida que los usuarios actualizan a una nueva versión del SDK y comienzan a usar tracing, su `beforeSend` empezaría a ver un tipo nuevo que su código no estaba pensado para manejar. Antes de las transacciones, no tenían que preocuparse por distintos tipos de eventos. Hay varias posibles consecuencias: romper aplicaciones de usuario; descartar transacciones de forma silenciosa e involuntaria; eventos de transacción modificados de maneras inesperadas.

3. En términos de usabilidad, `beforeSend` no encaja perfectamente para descartar transacciones como sí lo hace para descartar errores. Los errores son un evento puntual. Cuando ocurren errores, los usuarios tienen todo el contexto en `beforeSend` y pueden modificar o descartar el evento antes de que llegue a Sentry. Con las transacciones el flujo es diferente. Las transacciones se crean y permanecen abiertas durante un tiempo mientras se crean spans hijos y se les agregan. Mientras tanto, las solicitudes HTTP salientes incluyen la decisión de muestreo de la transacción actual con otros servicios. Después de que los spans y la transacción finalizan, descartar la transacción en un hook similar a `beforeSend` dejaría transacciones huérfanas de otros servicios en un trace. De manera similar, modificar la decisión de muestreo a &quot;sí&quot; en esta etapa tardía también produciría traces inconsistentes.
---
title: "Monitoreo del rendimiento: evolución de la API del SDK de Sentry"
---

El objetivo de este documento es contextualizar la evolución de las funciones de monitoreo del rendimiento en los SDK de Sentry. Comenzamos con un resumen de cómo se incorporó el monitoreo del rendimiento a Sentry y a los SDK, y más adelante analizamos las lecciones aprendidas en forma de problemas identificados y las iniciativas para abordarlos.

<div id="introduction">
  ## Introducción
</div>

A principios de 2019, Sentry comenzó a experimentar con la incorporación de trazas (tracing) en los SDK. Los SDK de [Python](https://github.com/getsentry/sentry-python/pull/342) y [JavaScript](https://github.com/getsentry/sentry-javascript/pull/1918) fueron el banco de pruebas donde se diseñaron y desarrollaron los primeros conceptos. Se publicó una prueba de concepto el [29 de abril de 2019](https://github.com/getsentry/sentry-python/releases/tag/0.7.13) y [se integró en Sentry](https://github.com/getsentry/sentry/pull/12952) el 7 de mayo de 2019. Python y JavaScript fueron opciones obvias porque nos permitían experimentar instrumentando el backend y el frontend de Sentry.

Cabe señalar que el trabajo mencionado fue contemporáneo a la [fusión de OpenCensus y OpenTracing para formar OpenTelemetry](https://medium.com/opentracing/a-roadmap-to-convergence-b074e5815289). La API y las implementaciones de los SDK de Sentry se inspiraron en versiones pre-1.0 de OpenTelemetry, combinadas con nuestras propias ideas. Por ejemplo, nuestra [lista de estados de span](https://github.com/getsentry/relay/blob/55127c75d4eeebf787848a05a12150ee5c59acd9/relay-common/src/constants.rs#L179-L181) coincide abiertamente con los que podían encontrarse en la especificación de OpenTelemetry hacia finales de 2019.

Después de definir una API, el soporte de monitoreo de rendimiento se amplió a otros SDK. La solución de [Performance Monitoring de Sentry](https://blog.sentry.io/2020/07/14/see-slow-faster-with-performance-monitoring) alcanzó disponibilidad general en julio de 2020. La [especificación de tracing de OpenTelemetry versión 1.0](https://medium.com/opentelemetry/opentelemetry-specification-v1-0-0-tracing-edition-72dd08936978) se publicó en febrero de 2021.

Nuestra implementación inicial reutilizó los mecanismos que teníamos para el reporte de errores:

- El [tipo Event](https://develop.sentry.dev/sdk/data-model/event-payloads/) se amplió con nuevos campos. Eso significó que, en lugar de diseñar e implementar una canalización de ingesta completamente nueva, podíamos ahorrar tiempo y empezar rápidamente a enviar “eventos” a Sentry; esta vez, en lugar de errores, un nuevo tipo de evento de “transaction”.
- Dado que solo estábamos enviando un nuevo tipo de evento, también se reutilizó la capa de transporte del SDK.
- Y dado que compartíamos la canalización de ingesta, eso significaba que compartíamos el almacenamiento y muchas partes del procesamiento que ocurre para todos los eventos.

Nuestra implementación evolucionó de tal manera que se hizo hincapié en la distinción entre Transactions y Spans. En parte, esto fue un efecto colateral de reutilizar la interfaz de Event.

Las Transactions tuvieron buena acogida entre los clientes. Permitían resaltar bloques importantes de trabajo en su código, como la carga de una página del navegador o una solicitud de servidor HTTP. Los clientes pueden ver y navegar por una lista de transactions, mientras que dentro de una transaction los spans ofrecen tiempos detallados para unidades de trabajo más granulares.

En la siguiente sección, hablaremos de algunas de las limitaciones del modelo actual.

<div id="identified-issues">
  ## Problemas identificados
</div>

Si bien la reutilización de la [arquitectura Unified SDK](https://develop.sentry.dev/sdk/miscellaneous/unified-api/) (hubs, clients, scopes) y el modelo de ingesta de transacciones tiene ventajas, la experiencia reveló algunos problemas que agrupamos en dos categorías.

El primer grupo tiene que ver con la propagación del scope, en esencia, la capacidad de determinar cuál es el “scope actual”. Esta operación es necesaria tanto para la instrumentación manual en el código del usuario como para la instrumentación automática en las integraciones del SDK.

El segundo grupo abarca problemas relacionados con el formato “wire” utilizado para enviar datos de transacciones desde los SDK a Sentry.

<div id="scope-propagation">
  ## Propagación del scope
</div>

*Este problema se rastrea en [getsentry/sentry-javascript#3751](https://github.com/getsentry/sentry-javascript/issues/3751).*

La [arquitectura unificada del SDK](https://develop.sentry.dev/sdk/miscellaneous/unified-api/) se basa fundamentalmente en la existencia de un `hub` por unidad de concurrencia, donde cada `hub` tiene una pila de pares `client` y `scope`. Un `client` mantiene la configuración y es responsable de enviar datos a Sentry mediante un `transport`, mientras que un `scope` contiene datos contextuales que se adjuntan a los eventos salientes, como etiquetas y breadcrumbs.

Cada `hub` sabe cuál es el scope actual. Siempre es el scope en la parte superior de la pila. La parte difícil es tener un `hub` “por unidad de concurrencia”.

JavaScript, por ejemplo, es de un solo hilo, con un event loop y ejecución asíncrona. No hay una forma estándar de transportar datos contextuales que funcione a través de llamadas asíncronas. Así que, para las aplicaciones JavaScript en el navegador, solo existe un `hub` global compartido para código síncrono y asíncrono.

Una situación similar aparece en los SDK móviles. Los usuarios esperan que los datos contextuales como etiquetas, el usuario actual, breadcrumbs y otra información almacenada en el `scope` estén disponibles y se puedan establecer desde cualquier hilo. Por lo tanto, en esos SDK solo existe un `hub` global.

En ambos casos, todo iba relativamente bien cuando el SDK solo tenía que informar errores. Con la responsabilidad añadida de rastrear transacciones y spans, el `scope` dejó de ser adecuado para almacenar el `span` actual, porque limita la existencia de spans concurrentes.

Para JavaScript en el navegador, una posible solución es usar [Zone.js](https://github.com/angular/angular/blob/master/packages/zone.js/README.md), parte del framework Angular. El principal desafío es que aumenta el tamaño del bundle y puede impactar inadvertidamente a las apps del usuario final, ya que aplica monkey patches a partes clave del motor de JavaScript.

El problema de la propagación del scope se hizo especialmente evidente cuando intentamos crear una API más simple para la instrumentación manual. La idea era exponer una función `Sentry.trace` que propagara implícitamente los datos de trazado y del scope, y que admitiera anidamientos profundos con código síncrono y asíncrono.

Como ejemplo, supongamos que alguien quiere medir cuánto tarda en buscar en un árbol del DOM. Rastrear esta operación se vería así:

```js
await Sentry.trace(
  {
    op: 'dom',
    description: 'Recorrer el árbol del DOM',
  },
  async () => await walkDomTree()
);
```

Con la función `Sentry.trace`, los usuarios no tendrían que preocuparse por conservar la referencia a la transacción o al span correctos al agregar datos de temporización. Los usuarios pueden crear spans secundarios dentro de la función `walkDomTree` y estos se ordenarían en la jerarquía adecuada.

La implementación de la propia función `trace` es relativamente simple (consulta [un PR con una implementación de ejemplo](https://github.com/getsentry/sentry-javascript/pull/3697/files#diff-f5bf6e0cdf7709e5675fcdc3b4ff254dd68f3c9d1a399c8751e0fa1846fa85dbR158)). Sin embargo, identificar el span actual, tanto en código asíncrono como en integraciones globales, es un desafío aún por resolver.

Los dos ejemplos siguientes ilustran los problemas de propagación del alcance.


<div id="cannot-determine-current-span">
  ### No se puede determinar el span actual
</div>

Imagina un código de autoinstrumentación que necesita obtener una referencia al `span` actual, un caso en el que la propagación de ámbito manual no está disponible.

```js
// Código del SDK
function fetchWrapper(/* ... */) {
  /*
    ... se omite parte del código por simplicidad ...
  */
  const parent = getCurrentHub().getScope().getSpan(); // <1>
  const span = parent.startChild({
    data: { type: 'fetch' },
    description: `${method} ${url}`,
    op: 'http.client',
  });
  try {
    // ...
    // return fetch(...);
  } finally {
    span.finish();
  }
}
window.fetch = fetchWrapper;

// Código del usuario
async function f1() {
  const hub = getCurrentHub();
  let t = hub.startTransaction({ name: 't1' });
  hub.getScope().setSpan(t);
  try {
    await fetch('https://example.com/f1');
  } finally {
    t.finish();
  }
}
async function f2() {
  const hub = getCurrentHub();
  let t = hub.startTransaction({ name: 't2' });
  hub.getScope().setSpan(t);
  try {
    await fetch('https://example.com/f2');
  } finally {
    t.finish();
  }
}
Promise.all([f1(), f2()]); // ejecutar f1 y f2 de forma concurrente
```

En el ejemplo anterior, varias solicitudes `fetch` concurrentes desencadenan la ejecución del helper `fetchWrapper`. La línea `<1>` debe poder observar un span distinto según el flujo de ejecución actual, lo que da lugar a dos árboles de spans como se muestra a continuación:

```
t1
\
  |- http.client GET https://example.com/f1
t2
\
  |- http.client GET https://example.com/f2
```

Eso significa que, cuando se esté ejecutando `f1`, `parent` debe referirse a `t1` y, cuando se esté ejecutando `f2`, `parent` debe ser `t2`. Lamentablemente, todo el código anterior compite por actualizar y leer de una única instancia de `hub`, por lo que los árboles de spans observados no son deterministas. Por ejemplo, el resultado podría ser, incorrectamente:

```
t1
t2
\
  |- http.client GET https://example.com/f1
  |- http.client GET https://example.com/f2
```

Como efecto secundario de no poder determinar correctamente el span actual, la implementación actual de la integración de `fetch` (y otras) en [el SDK de JavaScript para navegador opta por crear transacciones planas](https://github.com/getsentry/sentry-javascript/blob/61eda62ed5df5654f93e34a4848fc9ae3fcac0f7/packages/tracing/src/browser/request.ts#L169-L178), donde todos los spans hijos son hijos directos de la transacción (en lugar de tener una estructura de árbol multinivel adecuada).

Ten en cuenta que otras bibliotecas de tracing enfrentan el mismo tipo de desafío. Hay varios issues (abiertos en este momento) en OpenTelemetry para JavaScript relacionados con determinar el span padre y la propagación adecuada del contexto (incluido el código asíncrono):

* [Context leak if several TracerProvider instances are used #1932](https://github.com/open-telemetry/opentelemetry-js/issues/1932)
* [How to create nested spans without passing parents around #1963](https://github.com/open-telemetry/opentelemetry-js/issues/1963)
* [Nested Child spans are not getting parented correctly #1940](https://github.com/open-telemetry/opentelemetry-js/issues/1940)
* [OpenTracing shim doesn&#39;t change context #2016](https://github.com/open-telemetry/opentelemetry-js/issues/2016)
* [Http Spans are not linked / does not set parent span #2333](https://github.com/open-telemetry/opentelemetry-js/issues/2333)


<div id="conflicting-data-propagation-expectations">
  ### Expectativas en conflicto sobre la propagación de datos
</div>

Surge un conflicto de expectativas cada vez que añadimos una función `trace`, como se mencionó antes, o simplemente intentamos abordar la propagación del alcance con Zones.

El hecho de que el `span` actual se almacene en el `scope`, junto con `tags`, `breadcrumbs` y más, complica la propagación de datos, ya que algunas partes del `scope` están pensadas para propagarse solo a llamadas de funciones internas (por ejemplo, tags), mientras que se espera que otras se propaguen de vuelta a las funciones que llaman (por ejemplo, breadcrumbs), especialmente cuando ocurre un error.

Aquí tienes un ejemplo:

```js
function a() {
  trace((span, scope) => {
    scope.setTag('func', 'a');
    scope.setTag('id', '123');
    scope.addBreadcrumb('estuve en a');
    try {
      b();
    } catch(e) {
      // ¿Cómo obtener el SpanID del span en b para reportarlo?
    } finally {
      captureMessage('hola desde a');
      // tags: {func: 'a', id: '123'}
      // breadcrumbs: ['estuve en a', 'estuve en b']
    }
  })
}

function b() {
  trace((span, scope) => {
    const fail = Math.random() > 0.5;
    scope.setTag('func', 'b');
    scope.setTag('fail', fail.toString());
    scope.addBreadcrumb('estuve en b');
    captureMessage('hola desde b');
    // tags: {func: 'b', id: '123', fail: ?}
    // breadcrumbs: ['estuve en a', 'estuve en b']
    if (fail) {
      throw Error('b falló');
    }
  });
}
```

En el ejemplo anterior, si un error asciende por la pila de llamadas, queremos poder informar en qué `span` (haciendo referencia a un `SpanID`) ocurrió el error. Queremos tener breadcrumbs que describan todo lo que sucedió, sin importar qué Zones se estuvieran ejecutando, y queremos que una etiqueta definida en una Zone interna sobrescriba una etiqueta con el mismo nombre de una Zone padre, mientras hereda todas las demás etiquetas de la Zone padre. Cada Zone tiene su propio “span actual”.

Todas esas expectativas hacen difícil reutilizar, de manera comprensible, la noción actual de `scope`, cómo se registran los breadcrumbs y cómo interactúan esos conceptos.

Por último, vale la pena señalar que los cambios para reestructurar la gestión del scope probablemente no puedan realizarse sin romper las API de los SDK existentes. Los conceptos de los SDK existentes —como hubs, scopes, breadcrumbs, user, tags y contexts— tendrían que remodelarse todos.


<div id="span-ingestion-model">
  ## Modelo de ingesta de spans
</div>

Considera un trazo representado por el siguiente árbol de spans:

```
F*
├─ B*
│  ├─ B
│  ├─ B
│  ├─ B
│  │  ├─ S*
│  │  ├─ S*
│  ├─ B
│  ├─ B
│  │  ├─ S*
│  ├─ B
│  ├─ B
│  ├─ B
│  │  ├─ S*

donde
F: span creado en el servicio de frontend
B: span creado en el servicio de backend
S: span creado en el servicio de almacenamiento
```

Esta traza ilustra 3 servicios instrumentados de tal manera que, cuando una persona hace clic en un botón en una página web (`F`), un backend (`B`) realiza cierto trabajo, lo cual luego requiere hacer varias consultas a un servicio de almacenamiento (`S`). Los spans que están en el punto de entrada de un servicio determinado están marcados con un `*` para indicar que son transacciones.

Podemos usar este ejemplo para comparar y entender la diferencia entre el modelo de ingestión de spans de Sentry y el modelo usado por OpenTelemetry y otros sistemas de trazas similares.

En el modelo de ingestión de spans de Sentry, todos los spans que pertenecen a una transacción deben enviarse juntos en una sola solicitud. Eso significa que todos los spans de `B` deben mantenerse en memoria durante toda la duración de la transacción `B*`, incluido el tiempo dedicado a servicios downstream (el servicio de almacenamiento en el ejemplo).

En el modelo de OpenTelemetry, los spans se agrupan en lotes a medida que finalizan, y los lotes se envían tan pronto como a) hay cierta cantidad de spans en el lote o b) ha transcurrido cierta cantidad de tiempo. En nuestro ejemplo, podría significar que los primeros 3 spans de `B` se agruparían y enviarían mientras la primera transacción `S*` aún está en curso en el servicio de almacenamiento. Posteriormente, otros spans de `B` se agruparían y enviarían a medida que finalicen, hasta que eventualmente también se envíe el span de la transacción `B*`.

Si bien las transacciones son especialmente útiles como forma de agrupar spans y explorar operaciones de interés en Sentry, la forma en que existen actualmente impone una carga cognitiva adicional. Tanto quienes mantienen los SDK como las personas usuarias finales tienen que entender y elegir entre una transacción o un span al escribir código de instrumentación.

Los problemas que se describen en las siguientes secciones se han identificado en el modelo actual de ingestión y están todos relacionados con esta dicotomía.


<div id="complex-json-serialization-of-transactions">
  ### Serialización JSON compleja de transacciones
</div>

En el modelo de OpenTelemetry, [todas las spans siguen el mismo formato lógico](https://github.com/open-telemetry/opentelemetry-proto/blob/ebef7c999f4dea62b5b033e92a221411c49c0966/opentelemetry/proto/trace/v1/trace.proto#L56-L235). Los usuarios y las bibliotecas de instrumentación pueden aportar más significado a cualquier span adjuntándole atributos de clave-valor. El protocolo de red utiliza listas de spans para enviar datos de un sistema a otro.

El modelo de Sentry, a diferencia del de OpenTelemetry, establece una distinción clara entre dos tipos de span: las spans de transacción (a menudo llamadas “transactions”) y las spans normales.

En memoria, las spans de transacción y las spans normales se diferencian en algo: las spans de transacción tienen un atributo adicional, el `name` de la transacción.

Sin embargo, cuando se serializan como JSON, las diferencias son mayores. Los SDK de Sentry serializan las spans normales a JSON en un formato que se parece directamente a las spans en memoria. En cambio, la serialización de una span de transacción requiere mapear sus atributos de span a un `Event` de Sentry (originalmente usado para informar errores, ampliado con nuevos campos utilizados exclusivamente para transacciones), con todas las spans hijas incrustadas como una lista en el `Event`.

<div id="transaction-spans-gain-event-attributes">
  ### Los spans de transacción obtienen atributos de evento
</div>

Cuando una transacción se transforma de su representación en memoria a un `Event`, obtiene más atributos que no se pueden asignar a spans normales, como `breadcrumbs`, `extra`, `contexts`, `event_id`, `fingerprint`, `release`, `environment`, `user`, etc.

<div id="lifecycle-hooks">
  ### Ganchos del ciclo de vida
</div>

Los SDK de Sentry exponen un gancho `BeforeSend` para eventos de error, que permite a los usuarios modificar y/o descartar eventos antes de que se envíen a Sentry.

Cuando se introdujo el nuevo evento de tipo `transaction`, pronto se decidió que dichos eventos no pasarían por el gancho `BeforeSend`, básicamente por dos razones:

- Para evitar que el código del usuario dependa de la dualidad de las transacciones (a veces parecen un span, otras veces un evento, como se explicó en secciones anteriores);
- Para evitar que las funciones `BeforeSend` existentes, escritas pensando solo en errores, interfieran con las transacciones, ya sea al mutarlas accidentalmente, descartarlas por completo o causar algún otro efecto secundario inesperado.

No obstante, también estaba claro que se necesitaba algún tipo de gancho de ciclo de vida para permitir a los usuarios hacer cosas como actualizar el nombre de una transacción.

Optamos por un punto intermedio que permite mutar o descartar eventos de transacción mediante un `EventProcessor` (una forma más general de `BeforeSend`). Esto resuelve problemas al dar a los usuarios acceso inmediato a sus datos antes de que salgan del SDK, pero también tiene desventajas: es más complicado de usar que `BeforeSend` y además expone la dualidad de la transacción, que nunca se pretendió exponer.

Por el contrario, en OpenTelemetry los spans pasan por procesadores de spans, que actúan como dos ganchos de ciclo de vida: uno cuando se inicia un span y otro cuando finaliza.

<div id="nested-transactions">
  ### Transacciones anidadas
</div>

El modelo de ingesta de Sentry no se diseñó para transacciones anidadas dentro de un servicio. Las transacciones estaban pensadas para marcar transiciones entre servicios.

En la práctica, los SDK no tienen forma de impedir que las transacciones se aniden. El resultado puede sorprender a los usuarios, ya que cada transacción inicia un nuevo árbol. La única manera de relacionar esos árboles es mediante el `trace_id`.

Por ejemplo, genera confusión qué se debería ver en la interfaz en una situación como esta (pseudocódigo):

```python
# si do_a_database_query devuelve 10 resultados, ¿el usuario
#   - ve 11 transacciones en la interfaz?
#   - se le cobra por 11 transacciones?
#   - ve spans dentro de create_thumbnail solo en la transacción más interna?
with transaction("index-page"):
    results = do_a_database_query()
    for result in results:
        if result["needs_thumbnail"]:
            with transaction("create-thumbnail", {"resource": result["id"]}):
                create_thumbnail(result)
```

El modelo de facturación de Sentry es por evento, ya sea un evento de error o un evento de transacción. Esto significa que una transacción dentro de otra transacción genera dos eventos facturables.

En los SDK, tener una transacción dentro de otra hará que los spans internos sean “absorbidos” por la transacción más interna que los rodea. En estas situaciones, el código que crea los spans solo los añadirá a una de las dos transacciones, lo que ocasiona brechas de instrumentación en la otra.

Para visualizar todas las transacciones que comparten un `trace_id`, la persona usuaria puede visitar la página Trace View en **Sentry &gt; Performance**. Esta página ofrece una vista general del trace mostrando transacciones con una interfaz jerárquica y permite cargar spans hijo. Para obtener más información sobre Trace View, consulta nuestra [documentación](https://docs.sentry.io/concepts/key-terms/tracing/trace-view/).


<div id="spans-cannot-exist-outside-of-a-transaction">
  ### Los spans no pueden existir fuera de una transacción
</div>

La experiencia de tracing de Sentry se centra por completo en la parte de un trace que existe dentro de las transacciones. Esto significa que los datos no pueden existir fuera de una transacción, incluso si forman parte de un trace.

Si el SDK no tiene una transacción en curso, los spans normales creados por la instrumentación se pierden por completo. Dicho esto, esto preocupa menos en servidores web, donde las transacciones instrumentadas automáticamente se inician y finalizan con cada solicitud entrante.

La exigencia de una transacción es especialmente desafiante en los frontends (aplicaciones de navegador, móviles y de escritorio), porque en esos casos las transacciones autoinstrumentadas capturan con menos fiabilidad todos los spans, ya que solo duran un tiempo limitado antes de finalizarse automáticamente.

Otro problema surge cuando el trace comienza con una operación que solo está instrumentada como span, no como transacción. En nuestro [trace de ejemplo](#span-ingestion-model), el primer span que origina el trace se debe a un clic en un botón. Si el clic en el botón `F*` se instrumentara como un `span` normal en lugar de una transacción, lo más probable es que no se capturara ningún dato del frontend. Sin embargo, los spans `B` y `S` sí se capturarían, lo que llevaría a un trace incompleto.

En el modelo de Sentry, si un span no es una transacción y no hay un span ancestro que sea una transacción, entonces ese span no se ingerirá. Esto, a su vez, significa que hay muchas situaciones en las que a un trace le falta información crucial que puede ayudar a depurar problemas, particularmente en el frontend, donde las transacciones deben terminar en algún momento pero la ejecución puede continuar.

La instrumentación automática y manual afronta el reto de decidir si se debe iniciar un span o una transacción, y la decisión es particularmente difícil considerando que:

- Si no hay una transacción, el span se pierde.
- Si ya hay una transacción, aparece el problema de [transacciones anidadas](#nested-transactions).

<div id="missing-web-vitals-measurements">
  ### Mediciones de Web Vitals faltantes
</div>

La instrumentación del navegador de Sentry recopila mediciones de Web Vitals. Sin embargo, como esas mediciones se envían a Sentry usando la transacción instrumentada automáticamente como contenedor, las mediciones que el navegador expone después de que esa transacción automática ha finalizado se pierden.

Esto provoca que a algunas transacciones les falten ciertos Web Vitals o que tengan mediciones no definitivas para métricas como LCP.

<div id="unreliable-frontend-transaction-duration">
  ### Duración poco confiable de las transacciones en el frontend
</div>

Como todos los datos deben incluirse en una transacción, el SDK de navegador de Sentry crea una transacción por cada carga de página y cada navegación. Esas transacciones deben finalizar en algún momento.

Si la pestaña del navegador se cierra antes de que la transacción finalice y se envíe a Sentry, se pierden todos los datos recopilados. Por lo tanto, el SDK debe equilibrar el riesgo de perder todos los datos con el riesgo de recopilar datos incompletos y potencialmente inexactos.

Las transacciones se dan por finalizadas después de un periodo de inactividad definido tras observarse la última actividad (como una solicitud HTTP saliente). Esto significa que la duración de una transacción de carga de página o de navegación es un valor bastante arbitrario que no necesariamente puede mejorarse ni compararse con el de otras transacciones, ya que no representa con precisión la duración de ningún proceso concreto y comprensible.

Contrarrestamos esta limitación centrándonos en LCP (un Web Vital) como la métrica de rendimiento predeterminada para navegadores. Pero, como se mencionó arriba, el valor de LCP puede enviarse antes de ser definitivo, lo que hace que esta sea una solución menos que ideal.

<div id="in-memory-buffering-affects-servers">
  ### El almacenamiento en búfer en memoria afecta a los servidores
</div>

Como se explicó antes, el modelo de ingesta actual requiere que los SDK de Sentry observen árboles completos de spans en memoria. Las aplicaciones que operan con un flujo constante de transacciones concurrentes necesitarán recursos de sistema considerables para recopilar y procesar datos de trazabilidad. Los servidores web son el caso típico que presenta este problema.

Esto significa que registrar el 100% de los spans y el 100% de las transacciones no es viable para muchas aplicaciones del lado del servidor, porque la sobrecarga que conlleva es demasiado alta.

<div id="inability-to-batch-transactions">
  ### Imposibilidad de agrupar transacciones
</div>

El modelo de ingesta de Sentry no admite la ingesta de varios eventos a la vez. En particular, los SDK no pueden agrupar varias transacciones en una única solicitud.

Como resultado, cuando varias transacciones finalizan casi al mismo tiempo, los SDK deben realizar una solicitud por cada transacción. Este comportamiento es, como mínimo, muy ineficiente y, en el peor de los casos, un consumo significativo y problemático de recursos como el ancho de banda de red y los ciclos de CPU.

<div id="compatibility">
  ### Compatibilidad
</div>

El tratamiento especial de los spans de transacción es incompatible con OpenTelemetry. Los usuarios con aplicaciones existentes instrumentadas con los SDK de OpenTelemetry no pueden usar Sentry fácilmente para ingerir y analizar sus datos.

Sentry sí proporciona un Sentry Exporter para OpenTelemetry Collector, pero, debido al modelo de ingesta actual, [el Sentry Exporter tiene una limitación importante de correctness](https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/sentryexporter#known-limitations).

<div id="summary">
  ## Resumen
</div>

Hemos aprendido mucho al desarrollar la implementación actual de tracing en Sentry. Este documento intenta recopilar muchas de las limitaciones conocidas, para que sirvan como base para futuras mejoras.

El tracing es un tema complejo y dominar esa complejidad no es tarea fácil.

Los problemas del primer grupo —los relacionados con la **propagación del scope**— son una preocupación exclusiva de los SDK y de cómo están diseñados. Abordarlos requerirá cambios en la arquitectura interna de todos los SDK, incluido el rediseño de funciones antiguas como los breadcrumbs, pero realizar esos cambios es un requisito previo para implementar utilidades de tracing fáciles de usar, como una función `trace` que funcione en cualquier contexto y capture datos de rendimiento precisos y fiables. Ten en cuenta que tales cambios casi con seguridad implicarían publicar nuevas versiones principales de los SDK que rompan la compatibilidad con las versiones existentes.

Los problemas del segundo grupo —los relacionados con el **modelo de ingesta de spans**— son mucho más complejos, ya que cualquier cambio para resolverlos afectaría a más partes del producto y requeriría un esfuerzo coordinado de varios equipos.

Aun así, realizar cambios en el modelo de ingesta tendría un impacto positivo incalculable en el producto, ya que mejoraría la eficiencia, nos permitiría recopilar más datos y reduciría la carga cognitiva de la instrumentación.
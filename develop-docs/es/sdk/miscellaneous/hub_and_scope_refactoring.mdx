---
title: Refactorización de Hub y Scope
sidebar_order: 3
og_image: /og-images/sdk-miscellaneous-hub_and_scope_refactoring.png
---

<Alert title="Nota">
Este trabajo está en curso.

El desarrollo comenzó en JS y Python, pero aún estamos puliendo los detalles.
</Alert>

Históricamente, los SDK de Sentry implementaron los modelos de Hubs y Scopes, un aspecto clave que define la <Link to="/sdk/miscellaneous/unified-api/">API unificada</Link>. Esto introdujo mucha complejidad de cara al usuario y dejó más margen de error tanto para el usuario como para los mantenedores de los SDK. Desde que estamos considerando adoptar los “packages” de OpenTelemetry para reemplazar, o complementar, nuestros paquetes de rendimiento existentes en los SDK, hay un factor determinante. El modelo de Sentry, al ser diferente del de OpenTelemetry, nos impide dar soporte a OpenTelemetry.

<div id="a-why-are-we-doing-this">
  ## A) ¿Por qué hacemos esto?
</div>

Hay dos razones:

1. Ser compatibles con los datos de rendimiento de OpenTelemetry (OTel).
2. Hacer que la instrumentación de rendimiento de Sentry sea más fácil de entender y configurar correctamente.

<div id="being-compatible-to-opentelemetry">
  ### Compatibilidad con OpenTelemetry
</div>

Lo que Sentry llama `Scope` se denomina <Link to="https://opentelemetry.io/docs/specs/otel/context/">`Context`</Link> en OTel. Los contextos en OTel son inmutables, por lo que cada vez que se modifica un contexto en OTel se crea uno nuevo (derivado del scope activo actual).
Cada vez que se crea un span en OTel, se deriva un contexto nuevo. Esto produce muchos contextos anidados y los scopes de Sentry deberían poder reflejarlo.
Esto es necesario porque los SDK de Sentry deben poder capturar todos los spans de OTel con los datos correctos del contexto correspondiente aplicados antes de enviarlos a Sentry.

<div id="make-sentry-performance-instrumentation-easier">
  ### Facilitar la instrumentación de rendimiento de Sentry
</div>

Hubs y scopes es un sistema complejo, fácil de usar incorrectamente (consulta también [aquí](https://develop.sentry.dev/sdk/research/performance/#scope-propagation)). Nos obliga a crear nuevos hubs, lo que a su vez rompe los breadcrumbs y otras funciones. En el futuro, queremos contar con un sistema coherente, fácil de entender y usar.

---

<div id="b-what-is-the-outcome-of-the-refactoring">
  ## B) ¿Cuál es el resultado de la refactorización?
</div>

1. El modelo de bifurcación de Scope de los SDK está alineado con el de OTel, allanando el camino para poder usar las herramientas de OTel para el monitoreo del rendimiento y seguir viendo sus datos en Sentry. (Y los eventos de error de Sentry siguen conectados a los spans capturados por OTel).
2. La nueva API de Scopes está implementada y puede usarse.
3. La antigua API basada en `Hub` sigue funcionando como se espera por compatibilidad con versiones anteriores. Tras una fase de transición, el `Hub` se eliminará en una actualización mayor del SDK.

<Alert title="Nota">
La decisión de eliminar el Hub de todos los SDK de Sentry se confirmó en una reunión el 2024-05-03 con la mayoría de los ingenieros de SDK y Armin presentes. Esta decisión es definitiva.
</Alert>

Por eso iniciamos este proceso con un <Link to="https://github.com/getsentry/rfcs/pull/122">RFC</Link>.

---

<div id="c-the-new-concepts">
  ## C) Los nuevos conceptos
</div>

Se eliminará el `Hub` y solo quedarán el `Scope`, el `Client` y el `Transport` de la API unificada.

<div id="transport">
  ### Transporte
</div>

El `Transport` no se modifica. No cambiará.

<div id="client">
  ### Cliente
</div>

El `Client` se mantiene igual. La única diferencia es que siempre habrá un cliente disponible. Más sobre esto más adelante.

Antes de invocar `Sentry.init`, hay un `NoOpClient` en el ámbito global que se reemplaza por un cliente real al ejecutar `Sentry.init`. Los usuarios pueden enlazar un cliente diferente a cualquiera de los tres ámbitos.

<div id="scope">
  ### Alcance
</div>

Aquí es donde se necesita hacer la mayor parte del trabajo. El `Scope` evolucionará y asumirá parte de la funcionalidad del `Hub`.
El alcance ahora viene en tres variantes:

- Alcance global
- Alcance de aislamiento
- Alcance actual

Independientemente de la variante del alcance, puedes seguir agregándole datos (como tags, breadcrumbs, adjuntos, usuario, perfil, ..) como antes.
El alcance sigue manteniendo el contexto de propagación que contiene información de trazabilidad.

La diferencia está en cómo se aplican los datos del alcance a los eventos.

**Alcance global**

Es una simple variable global que se mantiene igual durante toda la ejecución del software. Los datos aplicados a este alcance terminarán en **todos** los eventos enviados desde el software. Es decir, lo mismo para todos los usuarios, hilos, tareas asíncronas, todo.

Este alcance probablemente solo se use para datos a nivel de proceso, como el `release`.

**Alcance de aislamiento**

Este alcance contiene datos aplicables solo a la solicitud actual (en un servidor), pestaña (en un navegador) o usuario (en un móvil). Las API de alto nivel que manipulan datos (como `sentry_sdk.set_flag()`, `sentry_sdk.set_tag()`, `sentry_sdk.set_context()` etc.) escriben en el alcance de aislamiento (al menos una vez que finalice la fase de migración; ver "Compatibilidad retroactiva").

El alcance de aislamiento se almacena en una variable de contexto, un thread local, un async local o algo similar (según la plataforma). También puede almacenarse en el `Context` de OTel para poder depender de la propagación del `Context` de OTel una vez que los SDK implementen POTEL.

El alcance de aislamiento lo bifurcan nuestras integraciones; los usuarios finales no deberían tener que pensar en alcances de aislamiento ni en bifurcarlos (ver diagrama abajo).

Los SDK no deberían bifurcar el alcance de aislamiento más de lo necesario; de lo contrario, reintroduciríamos el problema que los alcances de aislamiento pretenden resolver.

**Alcance actual**

Este alcance contiene datos para el span actualmente activo. Cada vez que se inicia un nuevo span, el alcance actual del span padre se bifurca (léase: se duplica), dando al nuevo span todos los datos del span padre y permitiendo agregar/manipular datos que se aplican solo al nuevo span (ver también "Copy-on-write").

Cambiar el alcance original después de bifurcar no modifica el alcance bifurcado.

El alcance actual se almacena en una variable de contexto, un thread local, un async local o algo similar (según la plataforma). También puede almacenarse en el `Context` de OTel para poder depender de la propagación del `Context` de OTel una vez que los SDK implementen POTEL.

El alcance actual puede ser bifurcado por el usuario final, ya sea explícitamente (p. ej., usando `Sentry.withScope()`) o implícitamente al iniciar un nuevo span. (Ver diagrama abajo.)

**Copy-on-write**

Eliminar los hubs también implica un copy-on-write \"suave\".

En nuestro sistema actual con hubs y alcances, `Scope` siempre es mutable y lo que lo vuelve algo inmutable es hacer push/pop de alcances y crear nuevos hubs. Sin embargo, esto debe hacerse manualmente.

Si se inicia una operación asíncrona a mitad del manejo de una solicitud, debe crearse un nuevo clon de hub para lograr copy-on-write. Si no creamos un nuevo clon de hub, hacer pop de un `Scope` también afecta a la ejecución original, lo que provoca pérdida de datos o, en el peor de los casos, excepciones.

Después de fusionar hubs y alcances, los alcances pueden bifurcarse en cualquier momento y el usuario ya no tiene que ocuparse de ello, ya que debería hacer lo correcto automáticamente. Con este nuevo sistema, la ejecución asíncrona puede manipular el alcance sin afectar otras ejecuciones.

Este copy-on-write \"suave\" depende de que `Scope` se bifurque en ciertos casos:

- `withScope` y API similares envuelven el callback en un `Scope` bifurcado que el SDK limpiará después de que el callback termine
- también tenemos que bifurcar cuando OTel lo haga; sin embargo, por ahora hay un área gris
	- depende de qué API esté disponible en la implementación de OTel relevante para cada SDK
	- en algunos casos, solo podremos interceptar el almacenamiento de `Context`, es decir, cuando se almacena un `Context` ya bifurcado, p. ej., en una variable ThreadLocal
	- en otros casos podemos interceptar la bifurcación de `Context`, es decir, cuando se crea una copia mutada de un `Context`
	- en algunos casos podría ser necesario una mezcla de ambos, ya que no toda la autoinstrumentación y la instrumentación de usuario pasan por un único lugar de la misma manera. p. ej., en el SDK de Java estamos a veces en la situación de recibir un `Context` con algunas propiedades ya establecidas en nuestro `ContextStorage` donde podemos envolverlo e interceptar futuras bifurcaciones de ese `Context`
	- \{open question} do we need to fork every time OTel `Context` copied or only when a new OTel span is set

Aunque aún es posible un uso incorrecto, este es un tipo de copy-on-write \"suave\" que debería proteger a la mayoría de los usuarios.

---

<div id="d-backwards-compatibility">
  ## D) Compatibilidad con versiones anteriores
</div>

<div id="migrating-from-hubs-and-scopes-to-scopes-only">
  ### Migración de Hubs y Scopes a solo Scopes
</div>

Debe haber un período en el que los usuarios puedan seguir usando la API antigua. No queremos un cambio de golpe que deje atrás a quienes no pueden actualizar fácilmente. Esto conlleva el riesgo de tener que dar soporte a versiones antiguas del SDK. Es decir, no deberíamos tener una versión principal A de un SDK que tenga hubs y que la siguiente versión, donde se fusionan, ya no admita hubs. Debe existir una fase de migración para nuestros usuarios.

Durante la fase de migración, podemos hacer que la API estática de nivel superior (como `Sentry.setTag()`) escriba tanto en el scope actual como en el de aislamiento. En una versión principal posterior, podemos cambiar esto para que solo escriba en el scope de aislamiento. La API de Hub debería implementarse con un shim y redirigir a scopes.

Para la mayoría de los casos de uso, escribir en el scope de aislamiento debería ser lo que queremos. Para otros casos de uso, los usuarios ya deberían estar usando principalmente `withScope()`, donde utilizan el `Scope` pasado al callback en lugar de la API estática. Vamos a desaprobar `configureScope` para que los usuarios sepan que deben reevaluar en qué scope quieren escribir. Los usuarios pueden entonces obtener el scope que necesitan y llamar, por ejemplo, a `setTag` en ese `Scope`. Puede haber algunos casos en los que cambiemos el comportamiento, pero el impacto debería limitarse, por ejemplo, a una solicitud entrante al servidor.

Debemos dejar muy claro en el changelog que la API de nivel superior solo escribe en el scope de aislamiento después de que hagamos el cambio.

---

<div id="e-implementation-details">
  ## E) Detalles de implementación
</div>

Combinaremos la funcionalidad del `Hub` y el `Scope` de la <Link to="/sdk/miscellaneous/unified-api/">Unified API</Link> en el `Scope` y eliminaremos el `Hub`. Añadiremos nuevas APIs que faciliten al usuario realizar instrumentación personalizada. Actualizaremos nuestra autoinstrumentación para bifurcar un scope cada vez que se cree un nuevo span. Esto nos alinea con lo que hace OTel.

TODO: añadir dónde se almacena y aplica el contexto de propagación, cómo funciona el tracing sin performance, dónde residen los spans/transacciones y otros problemas que descubrimos y resolvimos al implementar esto en los dos primeros SDKs.

<div id="how-is-scope-data-applied-to-events">
  ### ¿Cómo se aplican los datos del alcance a los eventos?
</div>

Los datos de los distintos tipos de alcance se combinan antes de aplicarse al evento.

Esto se hace en el siguiente orden:

1. tomar los datos del alcance global
2. combinar los datos del alcance de aislamiento
3. combinar los datos del alcance actual
4. opcional: combinar los datos adicionales proporcionados
5. aplicar el alcance combinado al evento

Consulta la RFC para un <Link to="https://github.com/getsentry/rfcs/blob/fn/merge-hub-scope/text/0122-sdk-hub-scope-merge.md#applying-scopes">ejemplo de código</Link>.

Consulta el diagrama a continuación para ver cómo se aplican los datos del alcance a los eventos.

<div id="what-does-the-new-api-look-like">
  ### ¿Cómo es la nueva API?
</div>

Ahora hay dos APIs nuevas para bifurcar el ámbito actual o bifurcar el ámbito de aislamiento (y al mismo tiempo el ámbito actual). Deberían llamarse `withIsolationScope(callback)` y `withScope(callback)` o algo similar.

Esta imagen ilustra el comportamiento de estas nuevas APIs y cómo se aplican los datos de ámbito a los distintos ámbitos:

![New Scopes API](new-scopes-api.png)

Para una versión ampliable, visita el <a href="https://miro.com/app/board/uXjVNtPiOfI=/?share_link_id=140058397661" target="_blank">Miro Board</a>

La imagen a continuación es una vista general simplificada de cómo funciona la bifurcación/herencia de ámbitos.
El último elemento de la línea de tiempo muestra que puede haber múltiples ámbitos activos en un servidor, pero no comparten datos (excepto el ámbito global).
Cada nueva solicitud y cada nuevo usuario obtiene su propio ámbito de aislamiento.

![Scope Inheritance](scope-inheritance.png)

A continuación se muestra, a grandes rasgos, cómo se mapean las nuevas APIs a las APIs del estilo anterior. En el caso de `configure_scope` y `push_scope`, no está claro si se debe usar el ámbito actual o el de aislamiento. La elección depende esencialmente de cuánto tiempo y en qué contexto debe estar activo el ámbito modificado/bifurcado.

<table>
	<thead>
		<tr>
			<th>API antigua</th>
			<th>API nueva</th>
			<th>Nota</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>hub = Hub(Hub.current)</code> (clon del hub)</td>
			<td><code>with isolation_scope() as scope</code></td>
			<td></td>
		</tr>
		<tr>
			<td rowspan="2" style={{verticalAlign: "middle"}}><code>with configure_scope() as scope</code></td>
			<td><code>scope = get_isolation_scope()</code></td>
			<td>Debe afectar a toda la transacción (un ciclo de solicitud/respuesta, una ejecución de una tarea, etc.).</td>
		</tr>
		<tr>
			<td><code>scope = get_current_scope()</code></td>
			<td>Debe afectar a todo el span o a una parte del código aislada mediante un ámbito actual bifurcado con <code>new_scope</code>.</td>
		</tr>
		<tr>
			<td rowspan="2" style={{verticalAlign: "middle"}}><code>with push_scope() as scope</code></td>
			<td><code>with isolation_scope() as scope</code></td>
			<td>Estamos iniciando una nueva unidad que merece su propia transacción (ciclo de solicitud/respuesta, etc.).</td>
		</tr>
		<tr>
			<td><code>with new_scope() as scope</code></td>
			<td>Debe afectar a una parte localizada del código, p. ej., si el usuario quiere agregar datos específicos a un evento concreto.</td>
		</tr>
	</tbody>
</table>

<div id="thing-we-found-while-implementing">
  ### Cosas que encontramos durante la implementación
</div>

- Necesitamos buenos valores predeterminados para los comportamientos de bifurcación para que nuestros clientes no tengan que pensar en ello. Hay integraciones en las que tiene sentido bifurcar solo el alcance actual o bifurcar tanto el de aislamiento como el actual. Deberíamos encontrar un buen valor predeterminado que funcione para la mayoría de los clientes.
- Ya no tener una pila de alcances significa que ya no deberías invocar métodos en referencias de Scopes reales (antes era Hub). Cuando se produce una bifurcación y, p. ej., se invoca `setTag` en la referencia de `Scopes` anterior, los datos no serán visibles dentro de los alcances bifurcados. Antes funcionaba, pero ya no.
- Ahora tenemos que crear el alcance global muy temprano, cuando el cliente aún no ha tenido oportunidad de especificar sus opciones. Usamos opciones predeterminadas para cosas como el límite de breadcrumbs, etc., hasta `Sentry.init`, donde reemplazamos las opciones usadas en el alcance global. Esto también significa que ahora estamos creando múltiples instancias de `SentryOptions`, por lo que necesitamos crear de forma diferida cosas costosas como ejecutores/hilos, etc.
- Si otro SDK se construye sobre el SDK que está cambiando, puede que tenga que existir algún tipo de CombinedScopeView que fusione los alcances en uno para sincronizar. Esto ya no debería ser necesario en cuanto el otro SDK también admita diferentes tipos de alcance.
- Si el orden de inserción importa para los datos, ahora necesitamos alguna forma de ordenar al fusionar datos, p. ej., para enviar un evento. Para los breadcrumbs, queremos enviarlos en orden de inserción, lo que significa que de alguna manera tenemos que registrar cuándo se añadió cada breadcrumb. Al fusionar datos los ordenamos y después aplicamos de nuevo el límite de breadcrumbs. Un problema similar existe con los procesadores de eventos en el alcance, que también deberían ejecutarse en orden de inserción.
- Parece que debería existir una API fácil de usar para bifurcar el isolation scope y para iniciar/continuar un trace (y transaction) a partir de encabezados/metadatos entrantes, lo cual actualmente no existe.
- Decidimos no desaprobar/eliminar configureScope para el SDK de Java, ya que dificulta que los clientes mantengan una referencia a un alcance (lo cual no deberían hacer). Ahora tiene una sobrecarga que permite pasar un tipo de alcance (global, isolation, current, combined). Tenemos un alcance predeterminado al que escribimos para la sobrecarga antigua. No queremos usar por defecto el alcance combinado/fusionado, ya que eso significaría que podrías manipular un alcance que no esperarías, p. ej., al usar `withScope`.
- Para el SDK de Java también mantenemos `pushScope` y añadimos `pushIsolationScope`. Marcamos como obsoleto `popScope`, ya que los usuarios ahora deben llamar a `close` en un token de ciclo de vida que devolvemos en los métodos push. El token también se puede usar como recurso de cierre automático en un bloque `try`.

---

<div id="f-use-otel-for-performance-instrumentation-potel">
  ## F) Usa OTel para la instrumentación del rendimiento (POtel)
</div>

Para más información, como los objetivos (y los no objetivos), consulta este issue de GitHub:

https://github.com/getsentry/team-sdks/issues/4

<div id="isolation-scope">
  ### Ámbito de aislamiento
</div>

Sin un ámbito de aislamiento, escribir en el `Scope` actual puede producir resultados inesperados. Las escrituras pueden ir a un ámbito que no se aplica como el usuario esperaría. Aunque esto ya es un problema hoy, se agrava al pasar a OTel, ya que la autoinstrumentación de OTel puede provocar mucha bifurcación de contexto, dando lugar a ámbitos muy anidados. Algunos hooks son envueltos automáticamente en un nuevo span por OTel, lo que hace que también tengan un `Scope` independiente, por lo que no se puede manipular el `Scope` externo.

Con un ámbito de aislamiento, tenemos un lugar donde, por ejemplo, los hooks pueden escribir y que debería afectar, p. ej., a toda la solicitud.

Cuando se bifurca el ámbito de aislamiento, el SDK también debería bifurcar el ámbito actual al mismo tiempo. De lo contrario, los usuarios tendrían que, por ejemplo, llamar tanto a `withScope` como a `withIsolationScope`, lo que daría como resultado un código menos legible.

<div id="implementation-details">
  ### Detalles de implementación
</div>

<div id="otel-context">
  #### OTel `Context`
</div>

OTel almacena spans y otra información en un `Context` y se encarga de propagar ese `Context` a través de bibliotecas e hilos. Queremos apoyarnos en esta propagación, ya que nos permite olvidarnos de hacerlo manualmente: simplemente guardamos nuestros scopes en el `Context` y confiamos en que OTel lo propagará correctamente.

**¿No podríamos simplemente propagar nuestros `Scopes` nosotros mismos e ignorar el `Context` de OTel?**
Si no quisiéramos depender de la propagación del `Context` de OTel, tendríamos que ofrecer un equivalente para cada mecanismo de propagación de OTel. Ya no podríamos limitarnos a confiar en OTel para las instrumentaciones, sino que tendríamos que replicar parte de lo que hacen. Además, habría que mantenerlo actualizado. Cada vez que OTel cambie algo sobre cómo propagan el `Context`, tendríamos que adaptarnos. Mantener sincronizados el `Context` y los `Scopes` sería difícil y también complicado de detectar. La compatibilidad de versiones entre Sentry y OTel podría volverse problemática.

Ejemplos de casos en los que, antes de POTel, tuvimos que encargarnos nosotros de la propagación:

- Bibliotecas reactivas ([implementación actual de Sentry](https://github.com/getsentry/sentry-java/blob/8c08ad9170b5549ddbc469a5c9ee6804aa6577a5/sentry-spring-jakarta/src/main/java/io/sentry/spring/jakarta/webflux/ReactorUtils.java) vs [OTel](https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/instrumentation/reactor/reactor-3.1/library/src/main/java/io/opentelemetry/instrumentation/reactor/v3_1/TracingSubscriber.java?rgh-link-date=2024-02-28T11%3A58%3A57Z))
- Bibliotecas de ejecutores, donde puedes programar una tarea para que se ejecute en otro hilo ([implementación actual de Sentry](https://github.com/getsentry/sentry-java/blob/39e3ed71814ad6ec3406a344aa341c68ed1b98d4/sentry/src/main/java/io/sentry/SentryWrapper.java))

<div id="hook">
  #### Hook
</div>

Para bifurcar nuestros scopes, cuando OTel lo requiera, necesitamos algún tipo de hook. Aún no estamos del todo seguros de cuándo es realmente necesario bifurcar. En teoría, debería bastar con bifurcar scopes siempre que se cree un nuevo span de OTel, o quizá incluso solo cuando se guarde el span. Los hooks disponibles en OTel dependen del lenguaje, por lo que esto probablemente variará de un SDK a otro.

- Bifurcación de Context: Cada vez que se cree una copia modificada de un `Context` de OTel usando `context.with(...)`.
- Almacenamiento de Context: Cada vez que se almacene un `Context` de OTel usando `context.makeCurrent()`.
- Creación de Span: Cada vez que se cree un nuevo span de OTel, independientemente de que se almacene en algún `Context` o de que ese `Context` se almacene.

Para la bifurcación/almacenamiento de `Context`, podríamos filtrar los cambios para bifurcar scopes solo cuando cambie el span y así tener menos scopes bifurcados.

Si no hay un hook disponible, tendremos que recurrir a una variante más compleja de almacenamiento global. Consulta el ejemplo intermedio en [este tablero de Miro](https://miro.com/app/board/uXjVNnI7dsE=/).

Un hook de bifurcación/almacenamiento de `Context` por sí solo, lamentablemente, no nos permite hacer todo lo que necesitamos. En `SpanProcessor.onEnd` y, por extensión, también en `SpanExporter.export`, `Context.current()` devuelve el `Context` padre y no el `Context` que estuvo activo durante la ejecución del span. Esto parece ser así por diseño en OTel. Esto significa que, incluso si logramos agregar nuestros scopes al `Context`, no podremos acceder a él en `SpanProcessor.onEnd()`.

<div id="storing-scopes-which-belong-to-a-certain-span">
  #### Almacenamiento de Scopes que pertenecen a un Span concreto
</div>

Si tu lenguaje permite modificar el span de OTel y añadir `Scopes` de Sentry al span, probablemente sea la forma más sencilla de llevar los scopes a `SpanProcessor.onEnd` y, por extensión, a `SpanExporter.export`. Sin embargo, aún no hemos explorado esta variante en detalle.

Si no es posible modificar el span, la única forma que hemos encontrado hasta ahora de recuperar los `Scopes` en `SpanExporter.export` es usar un almacenamiento global. Para este almacenamiento global, usamos spans de OTel como claves con referencia débil y `Scopes` de Sentry como valores. Usamos referencias débiles para evitar fugas de memoria, por ejemplo, si un span nunca termina.

El hook para la creación de spans de OTel / bifurcación de `Context` / almacenamiento debe entonces buscar los `Scopes` de Sentry ya sea en el span (si el lenguaje admite esta variante) o en el almacenamiento global.

Los scopes bifurcados en `SpanProcessor.onStart` pueden encontrarse mediante el span de OTel en `Context` (o en el almacenamiento global si el span no puede modificarse). Sin embargo, puede que ya exista un objeto `Scopes` en el `Context`. El hook tiene que determinar qué objeto `Scopes` bifurcar. Se puede usar una comprobación de ascendencia para ver si los `Scopes` del `Context` son ancestros de los `Scopes` del span (o del almacenamiento global). Si es así, bifurcamos los `Scopes` del span (o del almacenamiento global), ya que es el “más reciente”. Si no es el caso, bifurcamos los `Scopes` del `Context` o, si no hay `Scopes` en el `Context`, recurrimos a bifurcar scopes raíz.

No podemos confiar en `Context.current()` en `SpanProcessor.onEnd`, ya que devolverá el `Context` padre o un `Context` no relacionado. En `SpanExporter.export` tampoco podemos usar `Context.current()` porque normalmente se procesa en lotes y puede ejecutarse en un hilo diferente donde el `Context` ni siquiera se propaga.

Algunas variantes para almacenar `Scopes` pueden verse en [este tablero de Miro](https://miro.com/app/board/uXjVNnI7dsE=/). La variante de la derecha es la preferida si el SDK puede modificar spans en `SpanProcessor.onStart`. La variante del medio es un plan alternativo si no hay hooks disponibles. La variante de la izquierda es la que usamos cuando hay hooks pero no podemos modificar spans en `SpanProcessor.onStart`.

<div id="sentry-api-that-interacts-with-otel">
  #### API de Sentry que interactúa con OTel
</div>

Parte del API de Sentry tendrá que crear y gestionar copias modificadas del `Context` de OTel. En `withScope`, por ejemplo, creamos una copia del `Context` actual y establecemos `Scopes` bifurcados en ella usando `ctx = Context.current().with(forkedScopes)`. Luego invocamos el callback pasado a `withScope` y, después, restauramos el `Context` anterior, p. ej., llamando a `.close()` en un objeto de gestión del ciclo de vida que OTel nos proporciona.

<div id="when-to-fork-isolation-scope">
  #### Cuándo bifurcar el Isolation Scope
</div>

No probado:
Podemos usar `Propagator.extract` para bifurcar el isolation scope. Intentamos leer los `Scopes` del `Context` que se pasa a `Propagator.extract` y bifurcarlos, o recurrir a bifurcar los root scopes si no hay `Scopes` en el `Context`.

`Propagator.extract` debería ser invocado por la autoinstrumentación para casos de servidor y consumidor.

[Si bifurcar en `Propagator.extract` no funciona, podemos intentar comprobar si un span tiene un padre en el proceso actual (`span.isRemote`) y crear un isolation scope si no es así.]

<div id="tracing-without-performance">
  #### Rastreo sin rendimiento
</div>

Sin probar:
En `Propagator.extract` podemos crear un `PropagationContext` a partir de encabezados entrantes (o metadatos similares) o, en su defecto, crear un nuevo `PropagationContext` con IDs aleatorios. Luego almacenamos este `PropagationContext` en el ámbito de aislamiento. En `Propagator.inject` y al enviar eventos a Sentry, podemos usar ese `PropagationContext` del ámbito de aislamiento y generar encabezados (o similares).

- por definir: ¿cómo funciona el congelado de DSC/baggage? ¿Podemos simplemente congelar cuando sale la primera solicitud (o similar)?
- por definir: ¿debería Sentry.continueTrace escribir en el ámbito de aislamiento? ¿Necesitaría entonces bifurcar siempre un ámbito de aislamiento al mismo tiempo? ¿Debería crear un nuevo span (en caso de que el rendimiento esté habilitado)?

<div id="where-to-store-sentry-span">
  #### Dónde almacenar Sentry Span
</div>

Hasta que podamos eliminar por completo `Span` de Sentry y depender únicamente de spans de OTel, podemos almacenar los spans de Sentry en el ámbito actual. Guardarlo en el ámbito de aislamiento permitiría a los usuarios ocultar el span actual al establecer un span en el ámbito actual, lo que rompería la instrumentación. Tendríamos que modificar mucho el ámbito de aislamiento para mantener qué span está activo en cada momento; esto implicaría que el span actual se filtre, por ejemplo, a la ejecución asíncrona donde podría existir un span distinto.

<div id="what-to-move-along-when-execution-moves-eg-to-another-thread">
  #### Qué trasladar cuando la ejecución pasa, por ejemplo, a otro hilo
</div>

Cuando la ejecución pasa, por ejemplo, a otro hilo, debemos llevar el ámbito de aislamiento y el ámbito actual. También puede tener sentido bifurcar el ámbito actual en este caso. Si podemos confiar en la propagación de `Context` de OTel, esto debería resolverse automáticamente. Consulta la parte derecha de [este tablero de Miro](https://miro.com/app/board/uXjVNtPiOfI=/) para ver ejemplos.
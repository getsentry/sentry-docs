---
title: Políticas de actualización de dependencias
sidebar_order: 50
---

<div id="our-philosophy">
  ## Nuestra filosofía
</div>

- Los paquetes clave como `react`, `emotion`, `typescript`, `@babel`, etc. deben mantenerse al día. Estos paquetes tienen pocas dependencias y suelen ofrecer rutas de actualización bien documentadas y razonadas. Actualizar las dependencias clave no es negociable debido al costo marginal creciente de las actualizaciones mayores. Para paquetes de este tipo, también puede ser buena idea retrasar las actualizaciones mayores hasta que haya pasado uno o dos meses.

- Evita actualizar paquetes que estén publicando constantemente versiones de parches. Es preferible actualizar cuando el paquete se haya estabilizado.

- ¡Las actualizaciones que eliminan subdependencias son una buena noticia! Cuantos menos paquetes instalados, mejor. Eso significa menos código que distribuir y menos posibilidades de errores específicos de bibliotecas.

- ¡Las actualizaciones que reducen el número de subdependencias compartidas en conflicto son un acierto! Si actualizar una versión menor de un paquete hace que comparta la misma versión de una dependencia con otro paquete de nivel superior, se reduce la cantidad de código que se distribuye.

- Las actualizaciones de paquetes no críticos como `jest`, `eslint` o `prettier` se pueden hacer cuando haya tiempo. Por ejemplo, si todas las pruebas pasan y todo se ve bien, actualizar es una decisión obvia.

- En caso de duda, comenta las actualizaciones en el [Frontend Technical Steering Committee (TSC)](https://www.notion.so/Frontend-Technical-Steering-Committee-TSC-504b63ca92204f068ffda7e36feefc04)

<div id="take-a-balanced-approach">
  ### Adopta un enfoque equilibrado
</div>

Ten en cuenta que actualizar es un arma de doble filo.

Si dejas que todo se estanque y no actualizas nada solo porque todo funciona, inevitablemente tendrás que actualizar un paquete por un nuevo parche de seguridad, una funcionalidad que haga el código más mantenible o, en el peor de los casos, para poder actualizar otra dependencia.

Esto puede convertirse en una enorme cantidad de trabajo, ya que el paquete puede estar desfasado por muchas versiones menores **o incluso varias versiones mayores**. Si actualizar se vuelve lo bastante difícil, la persona ingeniera puede optar por evitarlo por completo e implementar un hack para sortear la necesidad. Esto, por supuesto, es doblemente malo, porque cuando _absolutamente necesites actualizar_, no solo será difícil actualizar un paquete muy desactualizado, sino que además tendrás que entender y revertir el hack.

Siendo proactivos y manteniéndonos al día con las versiones mayores y menores, normalmente solo necesitaremos considerar un conjunto pequeño de cambios en el paquete. Esto es más seguro, ya que es menos probable que se rompan los usos del paquete, pues simplemente hay menos que validar. Esto también ayuda a seguir el ritmo de las últimas mejoras de rendimiento, correcciones de errores y parches de seguridad. Y ayuda a garantizar que, cuando una persona desarrolladora busque documentación sobre el uso de un paquete, no tenga que rastrear versiones antiguas de la documentación.

<div id="consider-the-benefits-and-risks">
  ### Considera los beneficios y los riesgos
</div>

Por otro lado, optar por mantener los paquetes siempre en las versiones más recientes puede tener numerosas consecuencias.

- Actualizar puede, en algunos casos, requerir un esfuerzo considerable para ganancias marginales. Validar incluso actualizaciones pequeñas lleva tiempo, a menudo cuando realmente nada ha cambiado. (Esto, por supuesto, es una pendiente resbaladiza: si esperas demasiado, los paquetes pueden volverse exponencialmente más laboriosos de actualizar)

- Existe un costo por demasiados cambios en `package.json`, como que los desarrolladores tengan que ejecutar constantemente `yarn install` en cada pull de Git.

- Una vulnerabilidad de seguridad puede introducirse en una versión nueva que antes no estaba presente. Si hubiéramos esperado a actualizar hasta el parche, no habríamos sido vulnerables.

- Las nuevas versiones del paquete pueden incluir defectos introducidos por los mantenedores, que pueden ser difíciles de detectar durante la validación.

En general, nuestro enfoque para actualizar paquetes es **equilibrado**, teniendo en cuenta tanto los posibles beneficios como los inconvenientes de actualizar. Considera cuidadosamente cada decisión de actualización para asegurarte de que sea la opción correcta para nuestra base de código. Esta guía nos permite mantener nuestra base de código actualizada y segura, evitando esfuerzos innecesarios y riesgos potenciales.

<div id="how-to-upgrade-a-package">
  ## Cómo actualizar un paquete
</div>

<Alert>

¡Puede que no tengas que hacerlo manualmente! Consulta la sección a continuación, [Aprovecha las herramientas](#take-advantage-of-tooling), para saber más sobre nuestro uso de `dependabot` para actualizar automáticamente paquetes de frontend.

</Alert>

<div id="seeing-what-can-be-upgraded">
  ### Ver qué se puede mejorar
</div>

```bash
yarn outdated --color | sort
```


<div id="upgrading-packages">
  ### Actualización de paquetes
</div>

```bash
yarn upgrade --latest [nombre-paquete] [...]
```

<Alert>
  No olvides actualizar también el paquete `@types/[package-name]` si es necesario.
</Alert>

Si deseas actualizar un grupo de paquetes (por ejemplo, `@babel`), puedes usar

```bash
yarn upgrade --latest $(yarn outdated | cut -d' ' -f1 | grep [group-name])
```


<div id="proper-testing-of-upgrades">
  ## Pruebas adecuadas de las actualizaciones
</div>

<Alert level="warning">

**Este es, sin duda, el paso más crítico al gestionar actualizaciones de paquetes.** La aplicación cliente de Sentry no debería romperse por actualizaciones de paquetes.

</Alert>

<div id="classifying-types-of-upgrades">
  ### Clasificación de tipos de actualizaciones
</div>

Según la categoría del paquete que hayas actualizado, hay varios pasos que debes seguir para validar que la actualización sea segura y que nada se haya roto. El primer paso es considerar en qué categorías encaja el paquete que estás actualizando.

Las categorías generales de dependencias de frontend que tenemos son:

1. **Dependencias específicas de una funcionalidad**

   Es un paquete que se utiliza para una funcionalidad concreta de la aplicación. Por ejemplo, en nuestro cuadro de comentarios de grupo usamos un paquete para gestionar las menciones @. Esta dependencia está muy aislada a esa funcionalidad y, por lo general, no se usa en ningún otro lugar.

2. **Dependencias tipo framework**

   Son dependencias que suelen usarse de forma global en toda la aplicación. Cosas como `react`, `react-router`, `emotion`, `moment`, etc. Pueden ser difíciles de validar cuando su uso está muy extendido y dependerá de qué haya cambiado en la nueva versión de la biblioteca.

3. **Dependencias de pruebas**

   Casi siempre son las más fáciles de validar, ya que si las pruebas pasan en CI, básicamente se garantiza que la actualización no será problemática.

4. **Dependencias de compilación de la aplicación**

   Es un paquete que se utiliza para compilar la aplicación de Sentry en archivos JavaScript que se enviarán a producción. Este tipo de dependencias se pueden validar relativamente rápido, ya que, por lo general, si algo falla, la aplicación no se compilará y CI fallará.

5. **Dependencias de desarrollo**

   Son dependencias que se usan al ejecutar la aplicación en modo desarrollo, como `fork-ts-checker-webpack-plugin`. Aun así, hay que tener cuidado al actualizarlas para no romper el entorno de desarrollo, ya que eso puede ralentizar a todo el mundo. Sin embargo, un fallo aquí no es ni de lejos tan crítico como en un paquete que afecta a producción.

<Alert level="warning">

**Es importante entender correctamente la categoría de la dependencia que estás actualizando.**

Por ejemplo, algunas dependencias como `webpack` entran tanto en las categorías de dependencias de compilación de la aplicación como de desarrollo. Por lo tanto, hay que validar ambos casos de uso de la dependencia.

</Alert>

<div id="steps-to-validate-a-upgrade">
  ### Pasos para validar una actualización
</div>

1. **Lee el CHANGELOG del paquete**

   Esto te dará contexto sobre qué debes tener en cuenta. Si el paquete tiene cambios incompatibles explícitos, es importante estar al tanto para validar que nuestros usos no se vean afectados por esos cambios. Si nos afectan, habrá que realizar cambios en el uso de esa dependencia en Sentry para que sea compatible.

2. **¿Pasa el CI?**

   Este es un muy buen primer indicador de si el cambio es seguro. Si el CI está fallando, hay una alta probabilidad de que la aplicación esté realmente rota. Necesitarás arreglar las pruebas que fallan antes de poder integrar una actualización del paquete.

   Sin embargo, ¡**NO** te fíes de que el CI pase para garantizar que el paquete se actualizó correctamente! Nuestra cobertura de pruebas es buena, pero no perfecta.

   Al actualizar dependencias de testing, en este punto también puede que quieras revisar los registros de pruebas y asegurarte de que no haya salidas inusuales, verificar que el número de pruebas ejecutadas no haya cambiado e incluso comprobar que el rendimiento de las ejecuciones de prueba no haya empeorado.

3. **¿Funciona la aplicación?**

   Aquí empieza a ser importante entender la categoría de la dependencia. Es muy útil usar las **Vercel Frontend Previews** durante este paso para ver cómo se comporta la aplicación con el paquete actualizado en una build de producción.

   - Para dependencias específicas de funcionalidades, puedes comprobar específicamente que las funcionalidades que usan el paquete estén funcionando como se espera.

   - Para dependencias de framework, querrás hacer verificaciones puntuales tanto como puedas. Debes tener en cuenta los cambios en la nueva versión del paquete y validar que lo que haya cambiado se comporte como se espera. Buscar usos “extraños” de APIs puede ser útil aquí (p. ej., ¿estamos haciendo llamadas manuales a `ReactDOM` en algún lugar? etc.).

   - Para dependencias de build de la aplicación, a estas alturas ya deberíamos sentirnos bastante bien, considerando que la aplicación se construyó y pasó el CI. Aun así, vale la pena revisar el changelog para asegurarse de que nada en la canalización de build haya afectado a la aplicación. Sin embargo, los problemas con la build de la aplicación aquí pueden ser difíciles de detectar, ya que probablemente serán sutiles si el CI no los detectó.

   - Para dependencias de pruebas y desarrollo, es muy probable que la aplicación esté funcionando bien. El único escenario en el que la aplicación podría romperse es si la dependencia SÍ tuvo algún efecto en el código de la aplicación (en cuyo caso no debería clasificarse como una dependencia puramente de test o dev).

   Este también puede ser un buen momento para comprobar si el **size-limit report bot** ha dejado un comentario indicando un cambio en el tamaño del bundle. Si el bundle ha aumentado drásticamente, vale la pena investigarlo (lo mismo si ha disminuido drásticamente de tamaño).

4. **¿Funciona el entorno de desarrollo?**

   Si has actualizado una dependencia de build o desarrollo, definitivamente querrás asegurarte de que el entorno de desarrollo siga funcionando como se espera.

   - ¿`sentry devserver` sigue ejecutando correctamente la aplicación del lado del cliente?

   - ¿`pnpm dev-ui` sigue ejecutando la versión solo cliente de la aplicación?

   Dependiendo de qué paquete estés actualizando, querrás considerar qué probar. Por ejemplo, si actualizaste `fork-ts-checker-webpack-plugin`, querrás validar que los tipos se sigan comprobando en desarrollo.

5. **Actualiza el paquete en getsentry si corresponde**

   Las herramientas de desarrollo y los paquetes de build están actualmente duplicados en el `package.json` de `getsentry`. Para esos paquetes, es importante recordar que necesitarás actualizar el paquete en ambos lugares.

6. **Lee el diff de `yarn.lock`**

   Es bueno entender exactamente qué ha cambiado con la actualización. Por lo general, es mala señal si la actualización ha provocado una discrepancia en las versiones de subdependencias compartidas. Por ejemplo, si actualizas `lodash` pero otro paquete de nivel superior especifica que necesita una versión más antigua de `lodash`, ahora tendremos **dos versiones** de `lodash` instaladas. ¡Eso significa que se enviarán dos versiones separadas de `lodash`!

   Por lo general, querrás asegurarte de que nada tenga versiones duplicadas; en ese caso, puede que necesites usar `[yarn-deduplicate](https://www.npmjs.com/package/yarn-deduplicate)` o, en el peor de los casos, quizá debas actualizar el paquete que está arrastrando las versiones antiguas problemáticas.

   Consulta [The Ultimate Guide to yarn.lock Lockfiles](https://www.arahansen.com/the-ultimate-guide-to-yarn-lock-lockfiles/) para una visión en profundidad de cómo funcionan.

7. **Valida en producción después de fusionar la actualización**

   Finalmente, en algunos casos, puede valer la pena comprobar que la aplicación está funcionando como se espera en producción. En algunos casos raros, un paquete puede comportarse de forma diferente en producción (aunque esto es muy raro, ya que revisar la vista previa del frontend es muy cercano al mismo bundle de producción).

<div id="take-advantage-of-tooling">
  ## Aprovecha las herramientas
</div>

Usamos [Dependabot de GitHub](https://docs.github.com/en/code-security/dependabot) para abrir automáticamente pull requests de actualización de paquetes.

Tiene dos modos principales de funcionamiento:

- **Creación de PR por vulnerabilidades de seguridad**

  Estos aumentos de versión son críticos, ya que corrigen vulnerabilidades CVE conocidas reportadas en la [GitHub Advisory Database](https://github.com/advisories). Deberían integrarse lo antes posible.
  [Más información sobre las alertas de Dependabot en GitHub](https://docs.github.com/en/code-security/dependabot/dependabot-alerts/about-dependabot-alerts).
  Además, mantener las dependencias al día ayuda a garantizar que, cuando se descubre una vulnerabilidad, podamos actualizar ese paquete sin tener que pasar por múltiples versiones menores o incluso mayores.

- **Apertura de PR de actualización de versión**

  Los PR que crea este modo equivalen a hacer manualmente las actualizaciones de paquetes en el `package.json`. Es conveniente porque podemos ver de un vistazo si el CI pasa para esa actualización. Dependabot también agrupa con criterio las actualizaciones; por ejemplo, actualizará los paquetes `@type/*` junto con la biblioteca.

**Ambos modos están actualmente en uso en `getsentry/sentry`.** Puedes consultar el [dependabot.yml](https://github.com/getsentry/sentry/blob/master/.github/dependabot.yml) para más detalles sobre cada cuánto abre PR automáticamente y cuántos abre a la vez.

<Alert level="warning">

¡Procuramos usar Dependabot para mantenernos al día con las actualizaciones de dependencias! Estos PR suceden con relativa frecuencia, por lo que hay un equipo dedicado en GitHub `[@owners-js-deps](https://github.com/orgs/getsentry/teams/owners-js-deps)` al que Dependabot asigna los PR para revisión.

</Alert>

<div id="merging-dependabot-prs">
  ### Fusionar PRs de dependabot
</div>

Para abordar un PR de dependabot hay algunos pasos que seguir:

1. Para que CI termine de ejecutarse tendrás que hacer dos cosas:

   1. Comenta `/gcbrun` para activar `self-hosted-github-pr-check`.

   2. Etiqueta el PR con [`trigger-getsentry-external`](https://github.com/getsentry/sentry/labels/trigger-getsentry-external) para activar la verificación `getsentry / frontend`.

   - <details>
         <summary>¿Por qué tengo que hacer esto?</summary>

     El usuario `dependabot` se considera un colaborador externo, por lo que se deben tomar las mismas precauciones con estos PR que con los de un colaborador externo.
     Es importante señalar que esta es una acción explícita que realizas para indicar que la actualización **se considera, en general, segura**. Teóricamente es posible que un paquete exfiltre secretos de las GitHub Actions de `getsentry/getsentry` al incluir código malicioso en el nuevo paquete. Sin embargo, esta situación es muy improbable y requeriría un ataque coordinado a la cadena de suministro por parte de una de nuestras dependencias ya validadas.

      </details>

2. De forma muy conveniente, dependabot incluye en la descripción del PR una sección sobre la actualización con las notas de versión relevantes para las versiones que se están actualizando. ¡Léelas! Si no se incluyen las notas de versión, quizá debas localizar el archivo CHANGELOG en el repositorio del paquete para entender qué ha cambiado.

3. Se deben seguir todos los pasos de [Steps to validate a successful upgrade](https://www.notion.so/Steps-to-validate-a-successful-upgrade-b2a86b52c333417fb6a2dfba641d8dea) para validar que la actualización no rompa nada.

4. **Aprueba y fusiona el PR**. Idealmente, consigue una segunda opinión y pide a otra persona que lo revise. Pero, por ahora, no tenemos ningún requisito explícito más allá de que lo revises tú mismo.

<div id="references">
  ## Referencias
</div>

- [Actualizaciones continuas de dependencias: mejorar los procesos afrontando el dolor por adelantado | Snyk](https://snyk.io/blog/continuous-dependency-updates-improving-processes-front-loading-pain/)
- [¿Cuándo conviene actualizar las dependencias?](https://softwareengineering.stackexchange.com/a/340742)
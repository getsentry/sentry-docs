---
title: Solicitudes de red
sidebar_order: 80
---

Hay varias formas de hacer solicitudes de red en la app de Sentry, pero React Query (`sentry/utils/queryClient.tsx`) es la opción preferida. En esta guía veremos cómo solicitar y actualizar datos de manera eficaz.

<div id="how-we-use-react-query">
  ## Cómo usamos React Query
</div>

En general, usamos React Query tal cual. Consulta la [documentación oficial](https://tanstack.com/query/latest/docs/react/overview) para la mayoría de las dudas sobre opciones y uso. Notarás que encapsulamos las exportaciones de la biblioteca en el archivo `sentry/utils/queryClient.tsx`, lo que aplica algunas modificaciones para facilitar su uso:

- `useApiQuery` encapsula `useQuery` y debería usarse siempre que sea posible.
  - Proporciona un valor predeterminado para `queryFn`, que usa `queryKey` para generar la URL de la solicitud.
  - Almacena datos adicionales de la respuesta de la API, incluidos encabezados y códigos de estado.
  - Requiere que se proporcione un valor para la opción `staleTime`, que normalmente es `0`. Hacerlo explícito garantiza que los consumidores sepan con qué frecuencia la consulta volverá a solicitar datos. Consulta la [sección sobre stale time](#what-to-use-for-staletime) para más información.
  - `refetchOnWindowFocus` tiene como valor predeterminado `false` en lugar de `true`. Esto, nuevamente, busca que las nuevas solicitudes sean más intencionales.
- `setApiQueryData` encapsula `setQueryData` para usar con `useApiQuery`. Consulta la [sección sobre cómo actualizar la caché](#updating-your-query-data) para más información.

<div id="queries-get-requests">
  ## Consultas (solicitudes GET)
</div>

Las consultas son relativamente sencillas. Reciben una clave de consulta, hacen una solicitud y almacenan el resultado en caché. Cualquier cambio en la clave de consulta iniciará automáticamente una nueva obtención (o un acierto de caché). Si tu componente no siempre está listo para hacer una solicitud, puedes desactivarlo con la opción `enabled`.

<div id="quick-start">
  ### Inicio rápido
</div>

Supongamos que haces la siguiente solicitud: `GET /projects/?org=<org>`

```tsx
import {useApiQuery} from 'sentry/utils/queryClient';

type FetchProjectsResponse = Array<{id: string; name: string}>;
type ProjectsListProps = {org: string};

function ProjectsList({org}: ProjectsListProps) {
  const {
    isPending,
    isError,
    data: projects,
    refetch,
  } = useApiQuery<FetchProjectsResponse>(['/projects/', {query: {org}}], {
    staleTime: 0,
  });

  if (isPending) {
    return <Placeholder height="100px" />;
  }

  if (isError) {
    return <LoadingError onRetry={refetch} message="Error al cargar los proyectos." />;
  }

  return (
    <ul>
      {projects.map(project => (
        <li>{project.id}</li>
      ))}
    </ul>
  );
}
```


<div id="what-to-use-for-staletime">
  ### Qué usar para staleTime
</div>

Piensa bien el valor que elijas para `staleTime`. Con las opciones predeterminadas, las consultas se volverán a obtener siempre que el hook se monte o cambie la clave de la consulta, siempre y cuando la consulta esté en estado stale. El valor de `staleTime` es el número de milisegundos que las consultas permanecen “frescas” en la caché antes de pasar a stale. Una vez en stale, las consultas permanecen en la caché y se vuelven a obtener en segundo plano en el siguiente evento de refetch (remontaje o cambio de clave). Estos son algunos valores habituales que podrías usar:

- `staleTime: Infinity` — “Una vez que obtenga esto, no quiero que se vuelva a obtener automáticamente nunca”
- `staleTime: 0` — “Estos datos cambian a menudo y me parece bien hacer refetch con más frecuencia”
- `staleTime: 30_000` — “Solo quiero volver a obtener como máximo cada 30 segundos”

Ten en cuenta que, independientemente del valor elegido para `staleTime`, los valores solo permanecen en la caché durante 5 minutos desde su último uso. Esto puede modificarse con `cacheTime`.

<div id="expected-error-statuses">
  ### Estados de error previstos
</div>

De forma predeterminada, cualquier código de estado que no sea 2xx se considerará un error y se volverá a intentar. Aunque esto funciona en la mayoría de los casos, a veces esperas estados de error como `404` y quieres mostrar inmediatamente el estado de “no encontrado”. Puedes desactivar por completo los reintentos con `retry: false` o filtrar estados específicos proporcionando una función como esta:

```tsx
useApiQuery(..., {retry: (_, error) => error.status !== 404});
```


<div id="headers-and-pagination">
  ### Encabezados y paginación
</div>

Puedes acceder a los encabezados, incluidos los enlaces de página, con `getResponseHeader`, que es devuelto por `useApiQuery`:

```tsx
const {getResponseHeader} = useApiQuery(...);
const pageLinks = getResponseHeader?.('Link');
```


<div id="making-your-query-reusable">
  ### Cómo hacer que tu consulta sea reutilizable
</div>

A menudo tendrás una llamada a `useApiQuery` en un lugar que realiza la solicitud y componentes en otros que también necesitarán acceder a los mismos datos. Hay algunas cosas a tener en cuenta al hacer que estos hooks sean reutilizables, así que veamos un ejemplo:

```tsx
// useFetchProjects.tsx
type ProjectsResponse = Array<{id: string; name: string}>;
type FetchProjectsParameters = {orgSlug: string};

export function makeFetchProjectsQueryKey({
  orgSlug,
}: FetchProjectsParameters): ApiQueryKey {
  return [`/projects/`, {query: {orgSlug}}];
}

export function useFetchProjects(
  params: FetchProjectsParameters,
  options: Partial<UseApiQueryOptions<ProjectsResponse>> = {}
) {
  return useApiQuery(makeFetchProjectsQueryKey(params), {
    staleTime: 0,
    ...options,
  });
}

// ProjectsPage.tsx
function ProjectsPage({orgSlug}: EventsPageProps) {
  const {isPending, isError, data} = useFetchProjects({orgSlug});
  return (...)
}

// ProjectSubComponent.tsx
function ProjectSubComponent({orgSlug}: EventPaginationProps) {
  const {data} = useFetchProjects({orgSlug});
  return (...)
}
```

Ten en cuenta que añadimos un argumento `options` a nuestro hook `useFetchProjects` para que los consumidores puedan pasar sus propias opciones. Algunas opciones útiles son:

* `refetchOnMount: false`
  * Si usas un valor finito para `staleTime`, los subcomponentes pueden provocar nuevas solicitudes al montarse. Al establecer `refetchOnMount: false` en el subcomponente `useApiQuery`, puedes evitarlo.
* `notifyOnChangeProps: ['data']`
  * Si sabes que tus datos ya estarán en caché y solo quieres extraerlos de ahí, usa esta opción para evitar renders adicionales cuando cambien otros estados de `useApiQuery`.
* `enabled: <condition>`
  * Si esta consulta depende de información que aún no está disponible, asegúrate de deshabilitarla hasta que tengas todo lo necesario.
  * Ten en cuenta que las consultas deshabilitadas siempre devolverán `isPending: true`. En estos casos, a menudo es mejor usar `isLoading`, que equivale a `isFetching && isPending`.

También ten en cuenta la función `makeFetchProjectsQueryKey`. Extraemos la creación de la clave de consulta a su propia función para que los consumidores de este hook también puedan actualizar y volver a consultar sin tener que recrear la clave manualmente, lo cual es propenso a errores.

Las consultas reutilizables como esta pueden colocarse en `/sentry/actionsCreators`.


<div id="updating-your-query-data">
  ### Actualizar los datos de tu consulta
</div>

Hay muchas situaciones en las que los datos de tu consulta quedan obsoletos y necesitan actualizarse o volver a obtenerse. Esto suele ocurrir por alguna acción del usuario (p. ej., crear, eliminar o editar un registro). Si ya sabes cómo deberían ser los nuevos datos, puedes (y deberías) actualizar inmediatamente la caché usando el cliente de consultas:

```tsx
import {setQueryData, useQueryClient} from 'utils/queryClient'

const queryClient = useQueryClient();

function handleCreateProject() {
  const newProject = await createProject();
  setApiQueryData<ProjectsResponse>(queryClient, makeFetchProjectsQueryKey(...), data => {
    return data ? [...data, newProject] : data;
  });
}
```

Ten en cuenta el uso de `setApiQueryData`. Usa esta función auxiliar cuando utilices `useApiQuery`, ya que se encarga por ti de establecer la respuesta completa de la API.

Si sabes que los datos están desactualizados, pero no sabes cómo debería ser la nueva información, puedes invalidar la caché con `invalidateQueries`. [Consulta la documentación](https://tanstack.com/query/v4/docs/react/guides/query-invalidation) para saber cómo usarlo.


<div id="mutations-postputdelete-requests">
  ## Mutaciones (solicitudes POST/PUT/DELETE)
</div>

Las mutaciones, a diferencia de las consultas, no se ejecutan automáticamente. En lugar de `data`, devuelven una función `mutate` que recibe las variables dinámicas necesarias para completar la mutación. Ten en cuenta también que, a diferencia de `useApiQuery`, donde la función de consulta se generaba automáticamente, debes proporcionar tu propia función de mutación.

<div id="quick-start">
  ### Inicio rápido
</div>

Supongamos que tienes un Button que crea un proyecto con `POST /organizations/<org>/projects/`. Deberás definir el tipo de respuesta (`CreateProjectResponse` en este ejemplo), así como la estructura del objeto que pasarás a la función de mutación (`CreateProjectVariables` en este ejemplo). Luego puedes usar la función `mutate` para ejecutar la mutación:

```tsx
import {fetchMutation, useMutation} from 'sentry/utils/queryClient';

type CreateProjectResponse = {id: string; name: string};
type CreateProjectVariables = {name: string; orgSlug: string};

function Component() {
  const {mutate} = useMutation<
    CreateProjectResponse,
    RequestError,
    CreateProjectVariables
  >({
    ...options,
    mutationFn: ({name, orgSlug}: CreateProjectVariables) =>
      fetchMutation({
        url: `/organizations/${orgSlug}/projects/`,
        method: 'POST',
        data: {name}
      }),
    onSuccess: response => {
      addSuccessMessage(`Proyecto ${response.name} creado con éxito`);
    },
  });

  return (
    <button onClick={() => mutate({name: 'My new project', orgSlug: 'my-org'})}>
      Crear proyecto
    </button>
  );
}
```


<div id="optimistic-updates">
  ### Actualizaciones optimistas
</div>

En algunas situaciones, mostrar un estado de carga para cada acción puede resultar engorroso y hacer que la experiencia se perciba pesada y lenta. Para interacciones de este tipo, puede tener sentido actualizar la caché de inmediato en lugar de esperar una respuesta.

Aunque no haya un estado de carga al actualizar de forma optimista, los errores deben seguir gestionándose. Los errores deberían restablecer la interfaz a su estado anterior y mostrar un mensaje para avisar al usuario de que su acción no se completó.

Por ejemplo, supongamos que quieres actualizar el nombre del proyecto:

```tsx
// useFetchProject.tsx
export function makeFetchProjectQueryKey({id}): ApiQueryKey {
  return [`/projects/${id}`];
}

// useUpdateProjectNameOptimistic.tsx
function useUpdateProjectNameOptimistic(incomingOptions: UpdateProjectOptions) {
  const queryClient = useQueryClient();

  const options: Options = {
    ...incomingOptions,
    mutationFn: ({id, name}) => {
      return fetchMutations({
        url: `/projects/${id}/`,
        method: 'PUT',
        data: {name},
      });
    },
    onMutate: async variables => {
      // Cancelar cualquier consulta en curso para que nuestros cambios de caché no sean sobrescritos
      await queryClient.cancelQueries(makeFetchProjectQueryKey({id: variables.id}));

      const previousProject = queryClient.getQueryData<Project>(
        makeFetchProjectQueryKey({id: variables.id})
      );

      // Actualizar el caché con el nuevo valor
      setQueryData(queryClient, makeFetchProjectQueryKey({id: variables.id}), oldData => {
        return oldData ? {...oldData, name: variables.name} : oldData;
      });

      // Llamar a `onMutate` en caso de que un consumidor quiera usar este manejador
      incomingOptions.onMutate?.(variables);

      // Devolver los datos anteriores que pueden usarse en caso de error
      // Esto será accesible como `context` en el manejador onError
      return {previousProject};
    },
    onError: (error, variables, context) => {
      addErrorMessage(t('No se pudo actualizar el nombre del proyecto.'));

      // Restablecer al valor anterior que establecimos en el valor de retorno de onMutate
      if (context) {
        queryClient.setQueryData(
          makeFetchProjectQueryKey({id: variables.id}),
          context.previousProject
        );
      }

      incomingOptions.onError?.(error, variables, context);
    },
    onSettled: (...params) => {
      // Para mayor seguridad, activar una nueva consulta después para asegurar que los datos sean correctos
      queryClient.invalidateQueries({queryKey: ['todos']});
      incomingOptions.onSettled?.(...params);
    },
  };

  return useMutation(options);
}
```


<div id="testing-components-hooks-with-network-requests">
  ## Pruebas de componentes y hooks con solicitudes de red
</div>

Usamos `MockApiClient` para simular respuestas de la API. Es una clase disponible globalmente en las pruebas que reimplementa `Client` en el entorno de prueba. Puedes consultar la lógica [aquí](https://github.com/getsentry/sentry/blob/master/static/app/__mocks__/api.tsx).

<div id="test-setup-for-components">
  ### Configuración de pruebas para componentes
</div>

```tsx
import {render, screen} from 'sentry-test/reactTestingLibrary';

describe('useFetchSomeData', () => {
  it('debería obtener datos', () => {
    const request = MockApiClient.addMockResponse(...);

    render(<MyComponentThatFetches />);

    expect(request).toHaveBeenCalled();
  });
});
```


<div id="test-setup-for-hooks">
  ### Configuración de pruebas para hooks
</div>

```tsx
import {makeTestQueryClient} from 'sentry-test/queryClient';
import {reactHooks} from 'sentry-test/reactTestingLibrary';
import {QueryClientProvider} from 'sentry/utils/queryClient';

function wrapper({children}: {children?: ReactNode}) {
  return (
    <QueryClientProvider client={makeTestQueryClient()}>{children}</QueryClientProvider>
  );
}

describe('useFetchSomeData', () => {
  it('debería obtener datos', () => {
    const request = MockApiClient.addMockResponse(...);

    const {result, waitFor} = reactHooks.renderHook(useFetchSomeData, {
      wrapper,
      initialProps: {organization},
    });

    expect(request).toHaveBeenCalled();
  });
});
```


<div id="mocking-successful-responses">
  ### Simulación de respuestas correctas
</div>

```tsx
// Simular la obtención de proyectos
MockApiClient.addMockResponse({
  url: '/projects/',
  body: [{id: 1, name: 'my project'}],
});

// Simular la creación de un proyecto
MockApiClient.addMockResponse({
  url: '/projects/',
  method: 'POST',
  body: {id: 1, name: 'my project'},
});

// Lógica de coincidencia más compleja:
// Coincide con POST /projects/?param=1 con {name: 'other'} en el body
MockApiClient.addMockResponse({
  url: '/projects/',
  method: 'POST',
  body: {id: 2, name: 'other'},
  match: [
    MockApiClient.matchQuery({param: '1'}),
    MockApiClient.matchData({name: 'other'}),
  ],
});
```


<div id="mocking-error-responses">
  ### Simulación de respuestas de error
</div>

```tsx
MockApiClient.addMockResponse({
  url: '/projects/',
  body: {
    detail: 'Error interno',
  },
  statusCode: 500,
});
```


<div id="common-pitfalls">
  ### Errores frecuentes
</div>

<div id="waiting-for-your-queries-to-respond">
  #### Espera a que tus consultas respondan
</div>

¡Siempre, siempre, siempre espera tus aserciones cuando haya una solicitud de red! Aunque los datos estén disponibles de inmediato (porque proporcionamos mocks), sigue siendo un proceso asíncrono que lleva varios ciclos de renderizado. Así que asegúrate de usar las consultas [`findBy`](https://testing-library.com/docs/dom-testing-library/api-async#findby-queries) cuando sea necesario.

<div id="mocking-mutations-with-refetches">
  #### Simulación de mutaciones con refetch
</div>

Al probar un componente con una mutación, a menudo querrás volver a obtener los datos después de que la mutación haya finalizado. Dado que los datos han cambiado, tendrás que actualizar tus mocks antes de que ocurra el refetch para crear una prueba que refleje la realidad. De lo contrario, podrías tener una lógica perfectamente válida que actualice la caché, pero el refetch usará los datos simulados originales y arruinará la prueba. Para evitarlo, consulta este ejemplo:

```tsx
it('adds a project to the list', function () {
  MockApiClient.addMockResponse({
    url: '/projects/',
    body: [],
  });
  const createProject = mockApiClient.addMockResponse({
    url: '/projects/',
    method: 'POST',
    body: {id: 1, name: 'Mi Proyecto'},
  });

  render(<ProjectList />);
  expect(screen.getByText('Mi Proyecto')).not.toBeInTheDocument();

  await userEvent.click(screen.getByRole('button', {name: 'Crear Proyecto'}));
  // Reemplaza la respuesta anterior con los nuevos datos
  MockApiClient.addMockResponse({
    url: '/projects/',
    body: [{id: 1, name: 'Mi Proyecto'}],
  });
  await waitFor(() => expect(createProject).toHaveBeenCalledWith({name: 'Mi Proyecto'}));
  await screen.findByText('Mi Proyecto').toBeInTheDocument();
});
```

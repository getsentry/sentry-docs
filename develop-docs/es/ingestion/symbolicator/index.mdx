---
title: Symbolicator
description: Un servicio para la simbolización de eventos nativos, de JavaScript y de JVM.
---

<div id="introduction">
  ## Introducción
</div>

Symbolicator es el servicio de Sentry para simbolicar eventos nativos, de JavaScript y de la JVM. Cuando Sentry recibe eventos de estas plataformas, las excepciones y las trazas de pila normalmente no están en un formato útil para la persona usuaria final. Las razones varían según la plataforma:

* Los marcos nativos de la pila pueden contener solo una dirección de instrucción y un módulo, pero no información de función/archivo/línea. Además, puede que ni siquiera haya una traza de pila cuando Sentry recibe el evento: es posible enviar minidumps a Sentry, a partir de los cuales se extrae la traza de pila en un proceso llamado *stackwalking*.
* El código JavaScript generalmente se minifica con un bundler antes de su despliegue, y toda la información en una traza de pila se refiere a la versión minificada del código.
* Del mismo modo, el código de la JVM puede ofuscarse/minificarse con un programa llamado [ProGuard](https://github.com/Guardsquare/proguard).

La simbolicación es el proceso de recuperar trazas de pila útiles a partir de los eventos que recibimos, con la ayuda de varios tipos de información de depuración.

* En nativo, esta información de depuración suele denominarse “archivos de información de depuración” (DIF) o simplemente “archivos de depuración”. Los DIF son artefactos de compilación que varían según la plataforma (archivos DWARF en Unix, archivos PDB en Windows, etc.). Los ejecutables también pueden contener información de depuración. Usamos el crate [symbolic](/es/ingestion/symbolic/) para procesar archivos de depuración nativos.
* Para JavaScript, el formato importante de archivo de información de depuración es el sourcemap. En resumen, un sourcemap es un archivo JSON que permite resolver una línea/columna en un archivo JS minificado a una línea/columna en uno de los archivos fuente originales. Usamos el crate [sourcemap](https://github.com/getsentry/rust-sourcemap) para procesar sourcemaps.
* Para la JVM, el mencionado ProGuard emite los llamados archivos de mapeo de ProGuard que pueden usarse para resolver nombres ofuscados de clases y métodos y volver a los nombres originales. Usamos el crate proguard para procesar archivos de mapeo de [proguard](https://github.com/getsentry/rust-proguard).

<div id="making-a-request-to-symbolicator">
  ## Realizar una solicitud a Symbolicator
</div>

Principalmente usamos Symbolicator como un servicio HTTP basado en axum. Proporciona varios endpoints para solicitudes de simbolización:

* `/symbolicate` para simbolización nativa
* `/minidump` para stackwalking de minidump y simbolización
* `/symbolicate-js` para simbolización de JavaScript
* `/symbolicate-jvm` para simbolización de JVM
* `/applecrashreport` para simbolización de informes de fallos de Apple

Estos endpoints difieren en el esquema de las solicitudes que esperan. En todos los casos, pasamos por la función `RequestService::create_symbolication_request`, que hace lo siguiente:

1. Comprueba el número de solicitudes que se están ejecutando actualmente. Si está al límite (200 por defecto), devuelve un `MaxRequestsError` (503).
2. Crea un ID aleatorio para la solicitud.
3. Inicia un future que realiza la simbolización y finalmente informa del resultado a través de un canal oneshot.
4. Almacena el extremo rx del canal en un mapa interno de solicitudes.
5. Devuelve el ID de la solicitud.

Con el ID de la solicitud, es posible comprobar su estado usando el endpoint `/requests`. Los posibles valores de respuesta (en JSON) son:

* `{ "status": "pending", "request_id": <ID>, "retry_after": 30 }` si la solicitud se está ejecutando
* `{ "status": "completed", <rest of response data> }` si la simbolización fue correcta
* `{ "status": "failed", "message": <message> }` si la simbolización falló
* `{ "status": "timeout" }` si la simbolización agotó el tiempo de espera (tras 15 min)
* `{ "status": "internal_error" }` si se descartó el emisor; es decir, algo fue muy mal

Cuando se realiza la solicitud por primera vez, también se sondea inmediatamente y probablemente devuelve `pending`.

Toda la funcionalidad anterior está implementada en el subcrate `symbolicator`.

<div id="native-symbolication">
  ## Simbolización nativa
</div>

Una solicitud de simbolización nativa puede adoptar tres formas:

1. Una lista de trazas de pila (stack traces) y módulos enviada al endpoint `/symbolicate`
2. Un informe de bloqueo de Apple enviado al endpoint `/applecrashreport`
3. Un archivo minidump enviado al endpoint `/minidump`

En el segundo caso, el informe de bloqueo de Apple se analiza en una lista de trazas de pila y una lista de módulos, y luego se simboliza como una solicitud a `/symbolicate`. En el tercer caso, el minidump se recorre con stackwalk (ver más abajo) y luego se simboliza.

La simbolización en sí funciona, brevemente, así:

1. Obtener la información de depuración de todos los módulos de la solicitud (ignorando los que no estén referenciados por ningún frame de la pila). Convertir la información de depuración en archivos SymCache / PpdbCache (más sobre esto más adelante).
2. Considerar cada frame de la pila en cada una de las trazas de la solicitud, uno por uno.
3. Encontrar el módulo al que pertenece ese frame comparando la dirección de instrucción del frame con el rango de direcciones de cada módulo.
4. Usar el archivo de caché del módulo para obtener la información de archivo, función y línea del frame (¡esta es la simbolización propiamente dicha!).

Es habitual que un solo frame nativo se descomponga en múltiples frames durante la simbolización. Esto se debe a que el compilador puede insertar funciones en línea (inlining). Cuando una función se inserta en línea, no obtiene su propio frame de pila, sino que usa el de la función en la que se insertó. En la traza de pila simbolizada, queremos restaurar todas las funciones insertadas en línea y mostrarlas con sus propios frames.

<div id="source-context">
  ### Contexto de origen
</div>

Por lo general, también queremos aplicar el contexto de origen a los frames simbolicados. Si tenemos disponible el archivo fuente, buscamos hasta 5 líneas a cada lado de la línea del frame y las añadimos al frame.

Se puede indicar a Symbolicator en la solicitud que omita la aplicación del contexto de origen. Esto resulta útil, por ejemplo, para perfiles.

<div id="minidump-stackwalking">
  ### Stackwalking de minidump
</div>

Un archivo minidump es un archivo creado en el momento en que ocurre un fallo que contiene información sobre el contenido de la pila, los módulos cargados, etc.

Cuando Symbolicator procesa un minidump, inicialmente solo hay un único marco de pila: aquel en el que ocurrió el fallo. *Stackwalking* o *desenrollado de pila* es el proceso de reconstruir toda la pila de llamadas a partir de este marco. Para hacerlo, se necesita *información de desenrollado* (también conocida como *call frame info* o CFI).

La información de desenrollado suele estar incluida en el propio ejecutable/biblioteca compilado, porque la pila también debe desenrollarse si, por ejemplo, ocurre una excepción o un pánico. Convertimos toda la información de desenrollado en archivos `cficache`, que usan el formato CFI de Breakpad.

Usamos el crate `minidump` (mantenido por Mozilla) para el stackwalking. La implementación es completamente asíncrona y obtiene archivos de caché de CFI bajo demanda. El resultado del procedimiento de stackwalking es un vector de trazas de pila y un vector de módulos, que luego podemos simbolicar como cualquier otro fallo nativo.

<div id="native-debug-files-and-debug-file-sources">
  ### Archivos de depuración nativos y fuentes de archivos de depuración
</div>

Nota: Esta sección solo es realmente relevante para la simbolización nativa. Para JavaScript y JVM, solo usamos sourcemaps/archivos de mapeo de ProGuard que se cargaron en Sentry.

<div id="object-files">
  #### Archivos objeto
</div>

En `symbolic` existe el concepto de un “archivo objeto” (o simplemente “objeto”). En este contexto, es un artefacto de compilación nativa que puede contener información de depuración. Entre los ejemplos se incluyen archivos ELF, PE/PDB, MachO, sourcebundles y archivos de símbolos de Breakpad.

Cada archivo objeto puede contener potencialmente *debug info*, *unwind info* o *sources*. Aquí, debug info se refiere a información que nos permite convertir un stacktrace en algo útil; unwind info nos permite hacer stackwalk de minidumps; y sources nos permiten completar el contexto del código fuente. En principio, un objeto puede contener cualquier combinación de estos tipos de información.

<div id="modules-in-symbolication-requests">
  #### Módulos en solicitudes de simbolización
</div>

Además de los stack traces, una solicitud nativa de simbolización incluye una lista de *módulos*. Por ejemplo:

```json
{
    "type": "pe_dotnet",
    "code_id": "efc9a199e000",
    "code_file": "./TimeZoneConverter.dll",
    "debug_id": "4e2ca887-825e-46f3-968f-25b41ae1b5f3-9e6d3fcc",
    "debug_file": "./TimeZoneConverter.pdb",
    "debug_checksum": "SHA256:87a82c4e5e82f386968f25b41ae1b5f3cc3f6d9e79cfb4464f8240400fc47dcd"
}
```

Un módulo puede asociarse con más de un archivo de depuración. Por ejemplo, para el módulo Common Language Runtime mencionado arriba, Symbolicator podría obtener la biblioteca compilada &quot;./TimeZoneConverter.dll&quot;, el archivo Portable PDB &quot;./TimeZoneConverter.pdb&quot; y un paquete de código fuente (sourcebundle) asociado.

Symbolicator obtiene archivos de depuración con distintos propósitos—`Unwind`, `Debug` o `Source`—según la situación. `Unwind` se usa para el recorrido de pila en minidumps, `Debug` para simbolizar trazas de pila y `Source` para aplicar el contexto de código fuente.

<div id="debug-file-sources">
  #### Fuentes de archivos de depuración
</div>

Las *fuentes de archivos de depuración* son lugares desde los que Symbolicator puede obtener los archivos de depuración que necesita para procesar solicitudes de simbolización. Admitimos estos tipos de fuentes:

* `Filesystem` para discos locales
* `Gcs` para buckets de GCS
* `Http` para servidores HTTP que implementan el protocolo de servidor de símbolos de Microsoft
* `S3` para buckets de Amazon S3
* `Sentry` para archivos de depuración cargados en Sentry

Además, existen diferentes estructuras de directorios que determinan cómo se organizan los archivos de depuración en la fuente y cómo es posible consultarlos. Están documentadas en detalle [aquí](https://docs.sentry.io/platforms/native/guides/qt/data-management/debug-files/symbol-servers/#directory-layouts).

Una solicitud de simbolización nativa contiene configuraciones para todas las fuentes de archivos de depuración de las que Symbolicator debería intentar obtener archivos de depuración. Normalmente, estas incluyen los archivos de depuración que se cargaron en Sentry (esa es una fuente de tipo `Sentry`), fuentes integradas que Sentry conoce (Electron, NVIDIA, Microsoft, Apple, …) y cualquier otra fuente de símbolos personalizada que un usuario haya configurado (por ejemplo, si aloja todos sus archivos de depuración en su propio servidor).

Cuando finaliza la simbolización nativa, Symbolicator devuelve una lista de “candidatos” para cada módulo que se utilizó durante la simbolización. Esto muestra qué fuentes se consultaron para qué archivo de depuración y si la obtención fue exitosa.

<div id="symcache-ppdbcache">
  ### SymCache / PpdbCache
</div>

Se mencionaron SymCache y PpdbCache anteriormente. Son formatos de archivo binarios personalizados para información de depuración.

Comencemos con una explicación de SymCache. Los archivos SymCache se pueden generar a partir de los archivos típicos de información de depuración nativa (DWARF, PDB). En principio, podríamos usar directamente los archivos objeto para la simbolización, pero convertirlos a SymCache tiene la gran ventaja de que los archivos SymCache no necesitan cargarse en memoria ni analizarse para simbolizar. Solo hay que mantener en memoria una pequeña estructura de encabezado que funciona como índice a las distintas partes del archivo de caché. Esto nos permite simbolizar directamente desde el disco mediante mapeo de archivos en memoria de los SymCache.

El formato PpdbCache es conceptualmente muy similar a SymCache, pero está adaptado al Common Language Runtime (CLR) de Microsoft. Su nombre proviene de que el formato de archivo de depuración para ejecutables CLR se llama “portable PDB”.

<div id="javascript-symbolication">
  ## Simbolización de JavaScript
</div>

La simbolización de JavaScript se diferencia de la nativa principalmente en cómo se obtienen los archivos de depuración (es decir, el código minificado y los sourcemaps).

Cuando se suben archivos JS a Sentry, se hace en forma de *artifact bundles*. Estructuralmente, no son más que sourcebundles ordinarios que contienen fuentes minificadas y sourcemaps. En el mejor de los casos, los archivos minificados y sus sourcemaps están vinculados con un debug ID; los plugins de Sentry para varios bundlers de JS, así como `sentry-cli`, pueden encargarse de ello. Sin embargo, a menudo se suben bundles sin debug IDs. En ese caso, el bundle debe asociarse a una *release* y *dist*.

Tenemos un endpoint de API en Sentry llamado `artifact-lookup` que te permite consultar un proyecto para obtener artifact bundles. Los bundles se pueden buscar por los debug IDs de los archivos que contienen o por una combinación de URL de archivo, release y dist. Preferimos claramente el primer caso porque los debug IDs son inequívocos. Con el método de release/dist, puede ocurrir que se suban varios bundles con cambios menores para el mismo par release/dist, en cuyo caso no hay una forma infalible de saber cuál contiene el archivo fuente minificado/sourcemap realmente asociado a un evento.

También es posible que el sourcemap correspondiente a un archivo fuente minificado no se suba a Sentry en absoluto, sino que resida en otro lugar de la web.

La respuesta de Symbolicator contiene metadatos sobre cómo se obtuvieron el archivo fuente minificado y el sourcemap de cada frame (desde Sentry vs. desde la web, release vs. debug ID, etc.).

El procedimiento de simbolización de JS consiste en mapear una ubicación (línea/columna) del código minificado a una ubicación/función/archivo del código original. Para ello, la simbolización de JS tiene su propio formato de caché, SourcemapCache, análogo a SymCache y PpdbCache en el caso nativo.

<div id="jvm-symbolication">
  ## Simbolización de la JVM
</div>

La plataforma JVM es la más sencilla en cuanto a procedimientos de simbolización.

En lo referente a archivos de depuración, los archivos de mapeo de ProGuard y los paquetes de código fuente son relevantes para la simbolización en JVM. Por el momento, solo admitimos obtenerlos de fuentes de Sentry: el caso de uso previsto es que las personas los suban a su proyecto de Sentry.

El procedimiento de simbolización de la JVM consiste en mapear un trío clase/método/línea del código ofuscado a un trío clase/función/línea del código original. Al igual que un compilador nativo, ProGuard puede insertar (inline) funciones, por lo que un frame puede expandirse en varios frames.

Además de los stack traces, una solicitud de simbolización de JVM también puede contener una lista de excepciones y una lista de nombres de clase adicionales. A las excepciones se les volverán a asignar (remapear) los campos `module` y `type`. Los nombres de clase adicionales también se remapean y se devuelven en forma de mapa. Actualmente, esta función se utiliza para desofuscar jerarquías de vistas.

Como en otras plataformas, existe un formato de caché especializado para los archivos de mapeo de ProGuard. En este caso, está optimizado para el mapeo entre nombres de clases y métodos.

<div id="caching">
  ## Caché
</div>

Symbolicator incorpora una lógica avanzada para almacenar en caché los archivos que descarga. Las cachés constan de varias capas:

1. Una caché LRU en memoria, basada en el crate `moka`.
2. Una caché en disco.
3. Una caché compartida, basada en GCS. Esta caché compartida se implementó originalmente para que, cuando se agreguen nuevos pods de Symbolicator, puedan empezar a procesar solicitudes muy rápidamente sin tener que descargar primero todos los archivos de depuración del mundo.

Esto significa que, cuando se solicita un archivo, Symbolicator primero comprueba si lo tiene en memoria, luego si ya está en el disco, después si está en la caché compartida de GCS, y solo si no está en ninguno de esos lugares se descarga.

Existen cachés para muchos tipos de archivos. Algunas cachés no están destinadas a archivos descargados directamente de internet, sino que se generan a partir de otros archivos previamente descargados y almacenados en caché. Entre estos se incluyen los metadatos de archivos de objeto y los archivos `symcache`.

<div id="implementation">
  ### Implementación
</div>

Se implementa una caché para un tipo de archivo determinado creando un tipo de solicitud e implementando el trait `CacheItemRequest` para este. El trait tiene un tipo asociado, `Item`, y dos métodos obligatorios:

* `compute<'a>(&'a self, temp_file: &'a mut NamedTempFile) -> BoxFuture<'a, CacheEntry>` calcula una instancia de `Self::Item` y la escribe en el archivo temporal indicado;
* `load(&self, data: ByteView<'static>) -> CacheEntry<Self::Item>` carga una instancia de `Self::Item` a partir de los `data` proporcionados.

Luego puedes añadir una instancia de `Cacher<MyItemRequest>` a cualquier servicio que requiera la caché y usar su método `compute_memoized` para calcular una instancia de `Item`, utilizando automáticamente las cachés en memoria, en disco y compartida.

<div id="cacheerror-cacheentry">
  ### `CacheError` / `CacheEntry`
</div>

Solo tenemos un tipo de error interno en Symbolicator: `CacheError`. Esta es su definición:

```rust
pub enum CacheError {
    NotFound,
    PermissionDenied(String),
    Timeout(Duration),
    DownloadError(String),
    Malformed(String),
    InternalError,
}
```

Cada uno de los casos representa algo que puede salir mal al obtener un archivo desde algún lugar. Además, contamos con el tipo `pub type CacheEntry<T = ()> = Result<T, CacheError>` como abreviatura.

En su momento teníamos muchos tipos de error individuales para distintas partes de Symbolicator, pero eran difíciles de entender y en realidad nunca necesitamos tantas distinciones de grano fino, así que los simplificamos a casos de fallo comunes.

<div id="expiry-cleanup">
  ### Vencimiento y limpieza
</div>

De forma predeterminada, conservamos distintos tipos de archivos en caché durante diferentes períodos:

* Los archivos descargados y derivados se mantienen durante 12 horas después de su último uso.
* Cuando un archivo no se puede descargar, ese hecho se almacena en caché durante 1 hora.
* Cuando un archivo está malformado (es decir, no se puede procesar por algún motivo), ese hecho se almacena en caché durante 12 horas.

La limpieza de la caché se realiza con el comando `symbolicator cleanup`. Ejecutamos este comando periódicamente como parte del despliegue de Symbolicator en Kubernetes.

<div id="versioning">
  ### Versionado
</div>

Todas las cachés también tienen control de versiones. Cada caché tiene un número de versión actual y una lista de versiones compatibles. Primero se intenta la versión actual y luego, en orden, las versiones compatibles. La idea es que podemos mejorar un formato de datos sin dejar de poder leer la versión anterior. Si solo hay disponible una versión más antigua (pero compatible), la usamos y, además, iniciamos un proceso para actualizarla a la versión actual. Si solo hay versiones incompatibles disponibles, se considera como no encontrada.

<div id="deployment">
  ## Despliegue
</div>

En SaaS, desplegamos un total de 9 grupos/entornos de Symbolicator: para cada plataforma (`native`, `js`, `jvm`) tenemos Symbolicators de producción, canary y LPQ.

Tenemos despliegues separados por plataforma para poder escalarlos de forma independiente y, por ejemplo, que el enorme volumen de solicitudes de JS no deje sin recursos a las solicitudes de native. Todas las plataformas usan la misma compilación de Symbolicator; en principio, cualquiera de ellas podría atender cualquier tipo de solicitud.

<div id="symbolicli">
  ## Symbolicli
</div>

Además del frontend HTTP principal, también hay un frontend de CLI para Symbolicator llamado `symbolicli`. Existe principalmente para que no sea necesario configurar un servidor HTTP para depurar la simbolización. Puede simbolizar eventos y minidumps en el sistema de archivos local o en una instancia de Sentry para la que tengas un token de autenticación válido.

`symbolicli` es práctico, pero tiene algunas desventajas:

* No puedes usarlo directamente con eventos de clientes porque no hay forma de otorgarle acceso de administrador.
* Aún no admite la simbolización de JVM, no por una limitación inherente, sino porque no ha sido necesario.
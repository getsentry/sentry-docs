---
title: Mejores prácticas de Relay
sidebar_order: 10
---

Relay es un componente clave de la infraestructura de Sentry que procesa cientos de miles de solicitudes por segundo.
Para que tus cambios en Relay se integren sin problemas, hay algunas mejores prácticas que conviene seguir.

Para conocer las mejores prácticas generales de desarrollo en Rust, asegúrate de leer el documento de [Desarrollo en Rust](/es/engineering-practices/rust/).

<div id="forward-compatibility">
  ## Compatibilidad futura
</div>

Asegúrate de que los cambios en el protocolo de eventos y las API sean compatibles hacia adelante. Relay no debería descartar
ni truncar datos que no entiende. Es un caso de uso admitido que los clientes ejecuten
Relays desactualizados pero SDK actualizados.

Por ejemplo, los `enum` en el protocolo de eventos (o cualquier otro tipo de datos recibido desde el SDK) deben tener una variante comodín
de modo que los relays de clientes que ejecuten una versión anterior aún puedan reenviar los datos:

```rust
enum EventColor {
    Red,
    Green,
    Blue,
    /// Color desconocido, para compatibilidad futura.
    Unknown(String),
}
```

<div id="feature-gate-new-functionality">
  ## Controla las nuevas funciones con Feature Gates
</div>

Considera hacer que tu nueva función sea condicional. Esto no solo permite un despliegue gradual, sino que también puede funcionar como un interruptor de emergencia cuando algo salga mal.

<div id="sentry-features">
  ### Funciones de Sentry
</div>

Las funciones de Sentry son más adecuadas para nuevas funciones del producto. Pueden implementarse gradualmente en un subconjunto de organizaciones y proyectos.

<div id="global-config">
  ### Configuración global
</div>

Los kill switches, y las tasas de muestreo y de despliegue también pueden configurarse mediante la “configuración global”. La configuración global
es un mecanismo sencillo para propagar una configuración dinámica de Sentry a Relay.

La configuración global funciona muy bien para despliegues técnicos y kill switches.

<div id="relay-config">
  ### Configuración de Relay
</div>

El archivo de configuración de Relay también puede usarse para controlar el acceso a funciones mediante un feature gate. Es más adecuado
para configuraciones específicas del entorno o fundamentales para el funcionamiento de Relay y no debería
utilizarse para funciones del producto.

<div id="regular-expressions">
  ## Expresiones regulares
</div>

Las expresiones regulares son una herramienta potente, muy conocidas y además extremadamente eficientes. Sin embargo, no siempre son la opción adecuada para Relay.

Algunos de los problemas enumerados son específicos del crate de Rust [regex](https://docs.rs/regex/latest/regex/) que utiliza Relay, y otros aplican a las expresiones regulares en general.

<Alert title="Importante">
  Revisa detenidamente la [documentación del crate de Rust](https://docs.rs/regex/latest/regex/#overview) antes de incorporar una expresión regular.
</Alert>

<div id="compiling">
  ### Compilación
</div>

Compilar una Regex es bastante costoso.

* No compiles una expresión regular para cada elemento procesado.
* Almacena siempre en caché las expresiones regulares.

Las expresiones regulares estáticas se pueden almacenar en caché con [`std::sync::LazyLock`](https://doc.rust-lang.org/beta/std/sync/struct.LazyLock.html).

<div id="user-defined-regular-expressions">
  ### Expresiones regulares definidas por el usuario
</div>

Evita exponer expresiones regulares a los usuarios. En su lugar, considera usar un lenguaje específico del dominio o patrones tipo glob, para los cuales Relay ofrece buen soporte.

<Alert level="warning" title="Importante">
  Las expresiones regulares definidas por el usuario pueden provocar un uso inesperado de CPU o memoria.
  Revisa atentamente la sección [Untrusted Input](https://docs.rs/regex/latest/regex/#untrusted-input) en la documentación del crate regex.
</Alert>

<div id="avoid-unicode">
  ### Evita Unicode
</div>

Cuando no sea estrictamente necesario, define los grupos de coincidencia sin soporte para Unicode. Por ejemplo, `\w` coincide con alrededor de 140 000 puntos de código distintos; si solo necesitas hacer coincidir ASCII, considera usar grupos explícitos `[0-9A-Za-z_]` o deshabilitar Unicode para el grupo con `(?-u:\w)`.

<div id="de-serialization">
  ## (De-)serialización
</div>

La (de-)serialización de JSON, protobuf y MessagePack consume una cantidad considerable de CPU y memoria. Ten en cuenta cuándo y dónde
(de-)serializas datos.

La arquitectura de Relay requiere que todas las operaciones con uso intensivo de CPU se realicen en un grupo de hilos dedicado, que se utiliza en el llamado
[servicio de procesador](https://github.com/getsentry/relay/blob/master/relay-server/src/services/processor.rs).

<div id="data-structures">
  ## Estructuras de datos
</div>

Todas las estructuras de datos tienen un costo; procura usar la estructura adecuada para tu carga de trabajo.

* Un `BTreeMap` puede ser más eficiente que un `HashMap` para cantidades pequeñas de datos.
* Usa `ahash` (a través de `hashbrown::HashMap`) como hasher para un `HashMap` a fin de reducir la sobrecarga de hashing en `HashMap` con alto rendimiento.
* Usa `smallvec` en lugar de `Vec` cuando es probable que tus datos sean pequeños.
* Evita iterar por colecciones grandes a intervalos regulares; considera usar una [cola de prioridad](https://en.wikipedia.org/wiki/Priority_queue) o un
  [montículo](https://doc.rust-lang.org/std/collections/struct.BinaryHeap.html) en su lugar.

<div id="cpu-and-memory-constraints">
  ## Restricciones de CPU y memoria
</div>

Relay procesa entradas de usuario no confiables; asegúrate de tomar suficientes precauciones para evitar un ataque de denegación de servicio.

* Aplica límites de tamaño a los payloads.
* Limita el consumo de memoria en Relay. Por ejemplo, aplica límites de tamaño también a la descompresión, no solo a los datos comprimidos entrantes.
* Evita los algoritmos exponenciales; a menudo hay estructuras de datos y algoritmos mejores. Si esto no es posible, establece un límite.

<div id="dont-panic">
  ## No te asustes
</div>

Relay debe poder manejar cualquier entrada de usuario sin un [panic](https://doc.rust-lang.org/std/macro.panic.html).
Devuelve siempre errores útiles cuando te encuentres con entradas inesperadas o malformadas. Esto mejora la capacidad de depuración,
garantiza la estabilidad y produce los resultados necesarios.
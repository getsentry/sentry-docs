---
title: Desarrollo con Rust
description: Este documento reúne varios recursos útiles para empezar con Rust y seguir nuestros principios de código.
sidebar_order: 40
---

<div id="getting-started">
  ## Primeros pasos
</div>

- Una introducción rápida a la sintaxis para quienes se acercan por primera vez:
  [Media hora para aprender Rust](https://fasterthanli.me/articles/a-half-hour-to-learn-rust)
- El libro de Rust, con documentación exhaustiva del lenguaje:
  [The Rust Programming Language](https://doc.rust-lang.org/book/)
- [The Async Book](https://rust-lang.github.io/async-book/)
- Empleados de Sentry: únanse al canal `#discuss-rust` en Slack

<div id="coding-principles">
  ## Principios de programación
</div>

<div id="iterators">
  ### Iteradores
</div>

Prefiere tipos de iterador explícitos en lugar de `impl Iterator` en interfaces públicas y estables de crates publicados.
Esto permite nombrar el tipo en lugares como tipos asociados o globales. El nombre del tipo debe terminar con `Iter` según la convención de nomenclatura.

Además del trait estándar `Iterator`, considera siempre implementar traits adicionales de `std::iter`:

* `FusedIterator` en todos los casos, a menos que haya una razón de peso para no hacerlo
* `DoubleEndedIterator` si es posible la iteración inversa
* `ExactSizeIterator` si el tamaño se conoce de antemano

Si resulta excepcionalmente difícil escribir un iterador personalizado, también puede ser un [newtype](https://doc.rust-lang.org/1.0.0/style/features/types/newtype.html) privado alrededor de un iterador en caja (boxed):

```rust
pub struct FooIter(Box<dyn Iterator<Item = Foo>>);

impl Iterator for FooIter {
    type Item = Foo;

    fn next(&mut self) -> Option<Self::Item> {
        self.0.next()
    }
}
```

{/* ### Async-await

  En general, nos gusta migrar a async-await en el código, aunque aún hay mucho código que no lo hace.
  Uso
  Durante la migración, puede que necesites funciones normales que devuelvan futures; para su firma, en general deberías preferir `-> impl Future<Output = ...>` frente a otros tipos de retorno. Esto permite que el compilador determine los detalles en los sitios de llamada y evita tener que forzar si algo debe estar fijado (pinned) o no. El pinning solo debería hacerse explícitamente cuando sea parte de campos en structs o similares.

  */}


<div id="async-traits">
  ### Traits asíncronos
</div>

La compatibilidad con async en **traits** ya [está disponible en Rust](https://blog.rust-lang.org/2023/12/21/async-fn-rpit-in-traits.html)
y, en general, ahora debería preferirse.

```rust
pub trait Database {
    fn get_user(&self) -> impl Future<Output = User> + Send;
}

impl Database for MyDatabase {
    async fn get_user(&self) -> User {
        todo!()
    }
}
```

Ten en cuenta que el tipo de `future` devuelto es `Send`, para garantizar que pueda ejecutarse en un entorno de ejecución multihilo.

Cuando necesites despacho dinámico o tengas que admitir versiones de Rust anteriores a la 1.75, considera usar el crate [`async-trait`](https://docs.rs/async-trait/).


<div id="avoid-unwrap">
  ### Evita `.unwrap()`
</div>

Puede parecer obvio, pero evita usar `.unwrap()` casi siempre. Incluso si un fragmento de código no va a provocar un panic en su forma actual (porque se cumple alguna precondición), podría reutilizarse o refactorizarse en el futuro en una situación donde esa precondición ya no se cumpla.

En su lugar, refactoriza tu código y las firmas de las funciones para usar `match`, etc.

<div id="use-get-instead-of-slice-syntax">
  ### Usa `.get()` en lugar de la sintaxis de slices
</div>

La sintaxis de slices (`&foo[a..b]`) producirá un pánico si los índices están fuera de rango o en un orden inválido. En especial al manejar datos no confiables, es mejor usar `.get(a..b)` junto con una expresión `if let Some(...) =`.

<div id="checked-math">
  ### Cálculo verificado
</div>

Los desbordamientos y subdesbordamientos aritméticos provocarán un pánico en compilaciones de depuración, pero en compilaciones de lanzamiento pueden dar resultados incorrectos o causar pánicos en otras partes del código (como la sintaxis de slices mencionada arriba).
Es buena idea usar siempre cálculo verificado, como `checked_sub` o `saturating_sub`. Las variantes `saturating` se limitarán al `MIN/MAX` correspondiente del tipo de dato subyacente.

<div id="field-visibility">
  ### Visibilidad de campos
</div>

De forma predeterminada, los campos de las structs (incluidas las tuple-structs) deben ser completamente privados. La única excepción a esto es:

- Newtypes (structs de 1 tupla) cuando se desea acceso directo al tipo interno. Esto permite anotar la semántica de un tipo cuando se requiere acceder al tipo interno.
- Tipos de datos simples con una firma muy estable. Por ejemplo, definiciones de esquema como el protocolo `Event` de Sentry.

La visibilidad mixta no está permitida nunca, ni siquiera entre private y `pub(crate)` o `pub(super)`. En su lugar, proporciona accesores:

- `foo()`, `foo_mut()` y `set_foo()` para exponer los valores
- Funciones accesor `pub(crate)` o `pub(super)` en casos puntuales
- Una implementación de `Default` y un builder cuando se requiera construcción incremental

<div id="style-guidelines">
  ## Pautas de estilo
</div>

En general, seguimos las [pautas de estilo oficiales de Rust](https://doc.rust-lang.org/1.0.0/style/README.html).

<div id="import-order">
  ### Orden de importación
</div>

Las importaciones deben declararse antes de cualquier otro código del archivo y solo pueden ir precedidas por comentarios de documentación del módulo y atributos del módulo (`#![...]`). Agrupamos las importaciones por su origen, separando cada grupo con una línea en blanco. El orden de las importaciones es:

1. Biblioteca estándar de Rust: `std`, `core` y `alloc`
2. Dependencias externas y del workspace, incluido `pub use`
3. Módulos del crate: `self`, `super` y `crate`

Esto equivale a la siguiente configuración de `rustfmt`, que requiere nightly:

```toml
imports_granularity = "Module"
group_imports = "StdExternalCrate"  # solo en nightly
```

**Ejemplo:**

```rust
use std::borrow::Cow;
use std::collections::HashMap;
use std::io::{self, Seek, Write};

use fnv::{FnvHashMap, FnvHashSet};
use num::FromPrimitive;
use symbolic_common::{Arch, DebugId, Language};
use symbolic_debuginfo::{DebugSession, Function, LineInfo};

use crate::error::{SymCacheError, SymCacheErrorKind, ValueKind};
use crate::format;

pub use gimli::RunTimeEndian as Endian;
```


<div id="declaration-order">
  ### Orden de declaraciones
</div>

Dentro de un archivo, el orden de los componentes debería ser, en líneas generales, siempre el mismo:

1. Documentación a nivel de módulo
2. Importaciones
3. Reexportaciones públicas
4. Módulos y módulos públicos
5. Constantes
6. Tipos de error
7. Todas las demás funciones y structs
8. Pruebas unitarias

No hay una regla estricta sobre el orden de las declaraciones, pero sugerimos colocar primero el elemento más relevante.
Por ejemplo, para tipos que exponen un iterador, declara primero el tipo y su bloque impl (incluido `fn iter`) y, debajo, define el iterador correspondiente.

Al declarar una estructura con una implementación, asegúrate de que el struct y sus bloques impl sean consecutivos. Usa el siguiente orden para los bloques:

1. Definición de `struct` o `enum`
1. Bloque `impl`
1. Bloque `impl` con restricciones adicionales
1. Implementaciones de traits de `std`
1. Implementaciones de traits de terceros
1. Implementaciones de traits propios

Dentro de un bloque `impl`, sigue aproximadamente este orden (público antes que privado):

1. Constantes asociadas
1. Funciones asociadas no de instancia
1. Constructores
1. Getters / setters
1. Cualquier otra cosa

<div id="default-lints">
  ### Lints predeterminados
</div>

Usamos [clippy](https://github.com/rust-lang/rust-clippy) con el conjunto `clippy::all` para el linting. Consulta la sección *Configuring CI* para saber cómo ejecutarlo.

Además, cada crate habilita las siguientes advertencias en su archivo de nivel superior, después del bloque de documentación y antes de las importaciones (consulta la [lista de todos los lints disponibles](https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html)):

```rust
#![warn(missing_docs)]
#![warn(missing_debug_implementations)]
```

Ten en cuenta que no habilitamos `unsafe_code`, ya que eso debería resaltar durante la revisión de código.
Hay algunos casos legítimos de código unsafe, y la palabra clave `unsafe` por sí sola ya los señala suficientemente.


<div id="naming">
  ### Nomenclatura
</div>

Seguimos estrictamente las [convenciones de nomenclatura de Rust](https://doc.rust-lang.org/1.0.0/style/style/naming/README.html).
Se aplican todas las convenciones; aquí destacamos algunas secciones:

- [Evitar prefijos redundantes](https://doc.rust-lang.org/1.0.0/style/style/naming/README.html#avoid-redundant-prefixes-[rfc-356])
- [Métodos getter y setter](https://doc.rust-lang.org/1.0.0/style/style/naming/README.html#getter/setter-methods-[rfc-344]) (`foo` en lugar de `get_foo`)
- [Conversiones](https://doc.rust-lang.org/1.0.0/style/style/naming/conversions.html) (`as_foo` vs `to_foo` vs `into_foo`)
- [Iteradores](https://doc.rust-lang.org/1.0.0/style/style/naming/iterators.html)
- [Constructores](https://rust-lang.github.io/api-guidelines/predictability.html#constructors-are-static-inherent-methods-c-ctor) (Las estructuras suelen tener `fn new(...) -> Self`, que nunca devuelve `Result`)

<div id="writing-doc-comments">
  ### Redacción de comentarios de documentación
</div>

Seguimos las convenciones de RFC 505 y RFC 1574 para redactar comentarios de documentación. Consulta el [texto completo de las convenciones](https://github.com/rust-lang/rfcs/blob/master/text/1574-more-api-documentation-conventions.md#appendix-a-full-conventions-text). En particular, esto incluye:

- Una frase breve de resumen en una sola línea, escrita en inglés estadounidense y en tercera persona.
- Usa los encabezados predeterminados cuando corresponda, pero evita secciones personalizadas fuera de la documentación a nivel de módulo.
- Vincula tipos y métodos entre sí cuando sea posible, especialmente dentro del crate.
- Escribe pruebas de documentación

<div id="writing-doc-tests">
  ### Redacción de pruebas de documentación
</div>

Para utilidades y SDK públicos del crate, es preferible escribir al menos un doctest para la ruta crítica de tus métodos o structs.
Por supuesto, esto requiere que la interfaz sea pública. Esto incluso debería tener prioridad sobre una prueba unitaria equivalente, ya que además de probar, documenta la API.

Para formatear código en comentarios de documentación, puedes [configurar temporalmente rustfmt](https://github.com/rust-lang/rustfmt/blob/master/Configurations.md#format_code_in_doc_comments) para hacerlo. Es posible que agreguemos esto a nuestra configuración predeterminada en algún momento:

```rust
format_code_in_doc_comments = true
```


<div id="writing-tests">
  ### Escribir pruebas
</div>

Todas las funciones de prueba deben incluir el nombre de la función + una condición simple en su propio nombre. El nombre de la prueba debe ser lo más conciso posible y evitar palabras redundantes (como «should», «that»). Ejemplos:

* `tests::parse_empty`
* `tests::parse_null`

Coloca las pruebas unitarias en un submódulo `tests` anotado con `#[cfg(test)]`. Así, las importaciones y funciones auxiliares para las pruebas solo se compilan antes de ejecutarlas. Según el editor, `rust-analyzer` expandirá automáticamente `tmod` a un fragmento adecuado.

```rust
fn foo() {}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn foo_works() { .. }
}
```

Las pruebas de integración deben ir en la carpeta `tests/`, idealmente en un archivo según la funcionalidad que prueben. Estas pruebas solo pueden usar la interfaz pública.
Consulta esta [entrada de blog](https://matklad.github.io/2021/02/27/delete-cargo-integration-tests.html#Rules-of-Thumb) para obtener consejos sobre cómo estructurar las pruebas de integración.

En el caso de las bibliotecas, considera proporcionar ejemplos en `examples/`.


<div id="development-environment">
  ## Entorno de desarrollo
</div>

Usamos VSCode para el desarrollo. Cada repositorio contiene archivos de configuración que definen el estilo de código, linters y funciones útiles. Al abrir el proyecto por primera vez, asegúrate de seleccionar Instalar las extensiones recomendadas, ya que permitirán asistencia del editor durante la programación. El ejemplo probablemente más actualizado siempre se puede encontrar en el [repositorio de Relay](https://github.com/getsentry/relay/blob/master/.vscode/extensions.json):

* *Rust Analyzer:* Una integración de servidor de lenguaje rápida y con muchas funciones.
* *CodeLLDB:* Depurador basado en LLDB, necesario para depurar con la extensión Rust Analyzer
* *Better TOML and Crates:* Compatibilidad con archivos `Cargo.toml` y actualización de versiones de dependencias

Configuraciones recomendadas de Rust Analyzer en el `.vscode/settings.json` de tu proyecto:

```jsx
{
  // Habilitar todas las funciones
  "rust-analyzer.cargo.features": "all",

  // Si no te gustan las anotaciones de tipo en línea, esto las desactiva a menos que mantengas pulsado Ctrl + Alt.
  "editor.inlayHints.enabled": "offUnlessPressed",

  // Reglas de importación
  "rust-analyzer.imports.granularity.group": "module",
  "rust-analyzer.imports.prefix": "crate"
}
```

Para las pruebas, a menudo usamos la biblioteca de snapshots `[insta](https://github.com/mitsuhiko/insta)`. De forma predeterminada, al ejecutar pruebas con Cargo, insta comparará los snapshots y mostrará los diffs con un formato legible en la salida estándar. Sin embargo, para sacarle el máximo partido a insta, instala `cargo-insta` y usa el comando de Cargo en su lugar:

```bash
# Instala insta. Esto actualizará las versiones obsoletas.
$ cargo install cargo-insta

# Para revisar interactivamente las diferencias de snapshots:
$ cargo insta review --all

# Para ejecutar todas las pruebas omitiendo los fallos:
$ cargo insta test --review

# Para rechazar rápidamente todas las diferencias pendientes:
$ cargo insta reject --all
```


<div id="makefiles">
  ## Makefiles
</div>

Usamos `Makefiles` para reunir las acciones más habituales. Un Makefile completo para un espacio de trabajo con varios crates debería verse aproximadamente así (puede simplificarse):

```Makefile
all: check test
.PHONY: all

check: style lint
.PHONY: check

test: test-default test-all
.PHONY: test

test-default:
	cargo test --all
.PHONY: test-default

test-all:
	cargo test --all --all-features
.PHONY: test-all

style:
	@rustup component add rustfmt --toolchain stable 2> /dev/null
	cargo +stable fmt --all -- --check
.PHONY: style

lint:
	@rustup component add clippy --toolchain stable 2> /dev/null
	cargo +stable clippy --all-features --all --tests --examples -- -D clippy::all
.PHONY: lint

format:
	@rustup component add rustfmt --toolchain stable 2> /dev/null
	cargo +stable fmt --all
.PHONY: format

doc:
	cargo doc --workspace --all-features --no-deps
.PHONY: doc

```


<div id="cargo-version-numbers">
  ## Números de versión de Cargo
</div>

Cargo sigue el [versionado semántico](https://semver.org/), que usa X.Y.Z, llamados respectivamente números de versión _major_, _minor_ y _patch_. Hay dos casos principales:

<div id="after-10">
  ### Después de la 1.0
</div>

Una vez que se alcanza una versión 1.0, seguir SemVer es fácil:

- Los cambios incompatibles requieren subir la versión mayor.
- Las nuevas funcionalidades suben la versión menor.
- Las versiones que solo corrigen errores suben la versión de parche.

<div id="before-10">
  ### Antes de la 1.0
</div>

Antes de llegar a la versión 1.0, [todo vale según la especificación](https://semver.org/#spec-item-4). Sin embargo, Cargo tiene [reglas de actualización estrictamente definidas para los requisitos con operador circunflejo (^)](https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html) (este operador es el predeterminado si se usan números de versión simples). Así que, para que `cargo update` se comporte correctamente, adoptamos lo siguiente:

- Los cambios que rompen compatibilidad requieren aumentar la versión menor (Y).
- Las nuevas funcionalidades aumentan la versión de parche (Z).
- Las versiones solo con correcciones de errores aumentan la versión de parche (Z).

<div id="further-reading">
  ## Lecturas recomendadas
</div>

- [El pequeño libro de macros en Rust](https://danielkeep.github.io/tlborm/book/index.html)
- [Rust Nomicon: Las artes oscuras del Rust inseguro](https://doc.rust-lang.org/nomicon/)
- [Rust by Example: Una lista completa de ejemplos](https://doc.rust-lang.org/stable/rust-by-example/)
- [Rust for Rustaceans: Programación idiomática para desarrolladores con experiencia](https://rust-for-rustaceans.com/)
- [Rust in Action: Conceptos y técnicas de programación de sistemas](https://www.rustinaction.com/)
- [Zero to Production in Rust: Una introducción al desarrollo de backend](https://www.zero2prod.com/)
- [Rust Atomics and Locks](https://marabos.nl/atomics/)
---
title: Issue Grouping
---

Grouping is the process by which multiple events are associated into one issue. Sentry internally uses different systems to group events. Whenever possible Sentry will attempt to use the stack trace that goes with an error to group events. If this doesn't work (for instance because the stack trace is of low quality or does not exist at all) it will fall back to some more generic methods.

When the default grouping does not yield satisfying results there are three ways in which grouping can be influenced which fall into two categories: server side and client side grouping.

**Client Side:**

on the client side when an event is captured the grouping can be influenced by supplying a fingerprint value with the event. This can be used to manually group events together that would otherwise not be.

**Server Side:**

One the server there are also ways in which grouping can be influenced. One is server side fingerprinting which works very similar to client side fingerprinting which lets you define common rules that force events to be grouped into the same issue. Additionally there are grouping enhancement rules which are useful to change the way the stacktrace based grouping operates.

## General Behavior

The general grouping behavior is determined by the "grouping config". This is the default algorithm and behavior that is used to determine the general behavior. When a project is created Sentry selects the latest and greatest version of the grouping config and is from that moment frozen. Customer support can opt a project into a newer version of the grouping config but this will likely cause new events not to fall into the same groups as older ones.

## Grouping Config

The grouping config determines the overall grouping process. The exact logic for how grouping works is relatively complex and depends on the platform of the event (eg: JavaScript and C++ events use very different behavior for grouping).

The general rules are relatively straightforward:

- At all times we will prioritize stacktraces over other grouping information
- In languages where source code is always available the source code of the line in question will generally be used for grouping (Python, PHP, JavaScript, Ruby). Otherwise we are more likely to use the function name.
- Newer grouping strategies have improved grouping for fallback cases (eg: group by message) by removing common outliers from messages

## Grouping Enhancements

Grouping enhancements are used to improve the stack trace based grouping. If stack traces are used for grouping the enhancements rules are used to influence what data is used.

Enhancements are rules written in a pretty straightforward way. Each line is a single enhancement rule. It's one or multiple match expressions followed by one or multiple actions to be executed when all expressions match. All rules are executed from top to bottom on all frames in the stack trace.

The syntax for grouping enhancements is roughly like this:

```yaml
matcher-name:expression other-matcher:expression ... action1 action2 ...
```

### Rules

- **matcher**: the following matchers exist. Multiple matchers can be defined in a line:
  - `family`: matches on the general platform family. Right now there are `javascript`, `native` and `other`. To make a rule apply to multiple platforms you can comma separate them. Eg: `family:native,javascript` applies to both javascript and native.
  - `path`: this matches case insensitive with unix glob behavior on a path. The path separators are normalized to `/`. As a special rule if the filename is relative it still matches on `**/`. Examples:
    - `path:**/project/**.c`: matches on all files under `project` with a `.c` extension
    - `path:**/vendor/foo/*.c`: matches on vendor/foo without sub folders
    - `path:**/*.c`: matches on `foo.c` as well as `foo/bar.c`.
  - `module`: is similar to `path` but matches on the module. This is not used for native but for instance for javascript, python and similar platforms. Matches are case sensitive and normal globbing is available.
  - `function`: matches on a function, case sensitive with normal globbing.
    - `function:myproject_*` matches all functions starting with `myproject_`
    - `function:malloc` matches on the malloc function
  - `package`: matches on a package. The package is the container a function or module is contained in. This is a `.jar`, a `.dylib` or similar. The same matching rules as for `path` apply (eg: this is an absolute path typically).
  - `app`: matches on the current state of the in-app flag. `yes` means the frame is in app, `no` means it's not.
  - An expression can be quoted if necessary (eg: spaces are included)
- **actions**: There are two types of actions: flag setting and setting variables.
  - **flag**: flags are what is to be done if all matchers match. a flag needs to be prefixed with `+` to set it or `-` to unset it. If this expression is prefixed with a `^` it applies to frames above (eg: towards the crash) the frame, if prefixed with `v` it applies to frames below (eg: away from the crash). For instance `-group ^-group` removes the matching frame and all frames above from the grouping.
    - `app`: marks or unmarks a frame in-app
    - `group`: adds or removes a frame from grouping
  - **variables**: additionally variables can be set (`variable=value`). Currently there is just one:
    - `max-frames`: sets the total number of frames to be considered for grouping. The default is `0` which means "all frames". If set to `3` only the top 3 frames are considered.
- If a line is prefixed with a hash (`#`) it's a comment and ignored

### Examples

```yaml
path:**/node_modules/** -group
path:**/app/utils/requestError.jsx -group
path:**src/getsentry/src/getsentry/** +app

family:native max-frames=3

function:fetchSavedSearches v-group
path:**/app/views/**.jsx function:fetchData ^-group

family:native function:SpawnThread v-app -app
family:native function:_NSRaiseError ^-group -app
family:native function:std::* -app
family:native function:core::* -app
```

### Recommendations

There are some general recommendations we have to greatly improve the out of the box grouping experience.

#### Mark in-app Frames

The highest quality of life improvement one can receive is to help Sentry determine which frames in your stack trace are "in app" (part of your own application) and which ones are not. The default rules are defined by the SDK but in many cases this can be improved on the server as well. In particular for languages where server side processing is necessary (eg: native C, C++ or JavaScript) it's better to override this on the server.

For instance the following marks all frames in-app that are below a certain C++ namespace:

```bash
function:myapplication::* +app
```

You can also achieve the inverse by just marking all frames "not in app". In that case however you should ensure that first all frames are set to in-app to override the defaults:

```bash
app:no             +app
function:std::*    -app
function:boost::*  -app
```

Forcing all frames to be in-app first might be necessary as there might already have been some defaults set by the client SDK or earlier processing.

#### Cut Stack Traces

Additionally in many cases you want to chop off the top or bottom of the stack trace. For instance many code bases use a common function to generate an error in which case the error machinery will appear as part of the stack trace. For instance if you use Rust you are likely to want to remove some frames that are related to panic handling:

```bash
function:std::panicking::begin_panic       ^-app -app ^-group
function:core::panicking::begin_panic      ^-app -app ^-group
```

Here we tell the system that all frames from begin-panic to the crash location are not part of the application (including the panic frame itself) and that all frames above are also in all cases irrelevant for grouping.

Likewise you can also chop off the base of a stack trace. This is particularly useful if you have different main loops that drive an application:

```bash
function:myapp::LinuxMainLoop         v-group -group
function:myapp::MacMainLoop           v-group -group
function:myapp::WinMainLoop           v-group -group
```

#### Stack Trace Frame Limits

This is something that is not useful for _all_ projects but can work well for large applications with many crashes. The default strategy is to consider most of the stack trace relevant for grouping. This means that every different stack trace that leads to a crashing function will cause a different group to be created. If you do not want that, you can alternatively force the groups to be much larger by limiting how many frames should be considered.

For instance you could tell the system to only consider the top N frames if any of the frames in the stack trace refer to a common external library:

```bash
# always only consider the top 1 frame for all native events
family:native max-frames=1

# if the bug is in proprietarymodule.so, only consider top 2 frames
family:native package:**/proprietarymodule.so  max-frames=2

# these are functions we want to consider much more of the stacktrace for
family:native function:KnownBadFunction1  max-frames=5
family:native function:KnownBadFunction2  max-frames=5
```

## Server Side Fingerprinting

Server side fingerprinting is also configured with a config similar to grouping enhancements but the syntax is slightly different. The matchers are the same but instead of flipping flags a fingerprint is assigned that overrides the default grouping entirely.

```yaml
(matcher:expression)+ -> list, of, values
```

All values are matched against and in case of stacktraces all frames are considered. If all matches in a line match then the fingerprint is applied.

The matchers are the same as for grouping enhancements but some extra ones are available:

- `type`: matches on an exception type
- `value`: matches on an exception value
- `message`: matches on a log message

Examples:

```yaml
# force all errors of the same type to have the same fingerprint
type:DatabaseUnavailable -> system-down

# force all memory allocation errors to be grouped together
family:native function:malloc -> memory-allocation-error

# force all events with a certain message to be matched together
message:"unexpected i/o error: *" -> io-error
```

## Grouping Debugging

On the bottom of an event page opted in customers (and customer support) can see which values went into the grouping algorithm:

![Issue Grouping Debug.png](../images/issue-grouping-debug.png)

## Next Steps

- The grouping config with the internal newstyle/legacy names is an experimental UI for internal use but temporarily exposed to customers who are enrolled. In the future we will give projects at the time they are created the latest grouping version and an upgrade button to change to newer grouping.
- Additionally we will give customer support an option to downgrade customers back to an older version of the grouping algorithm.
- Once this feature becomes available in production the latest revision of this document should be added to the documentation.

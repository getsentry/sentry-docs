---
title: Batch Processor
---

<Alert level="warning">
  ðŸš§ This document is work in progress.
</Alert>

<Alert>
  This document uses key words such as "MUST", "SHOULD", and "MAY" as defined in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt) to indicate requirement levels.
</Alert>

The BatchProcessor batches spans and logs into one envelope to reduce the number of HTTP requests. When an SDK implements span streaming or logs, it MUST use a BatchProcessor, which is similar to [OpenTelemetry's Batch Processor](https://github.com/open-telemetry/opentelemetry-collector/blob/main/processor/batchprocessor/README.md). The BatchProcessor holds logs and finished spans in memory and batches them together into envelopes. It uses a combination of time and size-based batching. When writing this, the BatchProcessor only handles spans and logs, but an SDK MAY use it for other telemetry data in the future.

## Specification

Whenever the SDK finishes a span or captures a log, it MUST put it into the BatchProcessor. The SDK MUST NOT put unfinished spans into the BatchProcessor.

The BatchProcessor MUST start a timeout of 5 seconds when the SDK adds the first span or log. When the timeout exceeds, the BatchProcessor MUST send all spans or logs, no matter how many items it contains. The SDK MAY choose a different value for the timeout, but it MUST NOT exceed 30 seconds, as this can lead to problems with the span buffer on the backend, which uses a time interval of 60 seconds for determining segments for spans. The BatchProcessor MUST only start a new timeout, when it has spans or logs to send, to avoid running the timeout unnecessarily.

The BatchProcessor MUST send all items after the SDK when containing spans or logs exceeding 1MiB in size. The SDK MAY choose a different value for the max batch size keeping the [envelope max sizes](/sdk/data-model/envelopes/#size-limits) in mind. The SDK MUST calculate the size of a span or a log to manage the BatchProcessor's memory footprint. The SDK MUST serialize the span or log and calculate the size based on the serialized JSON bytes. As serialization is expensive, the BatchProcessor SHOULD keep track of the serialized spans and logs and pass these to the envelope to avoid serializing multiple times.

When the BatchProcessor sends all spans or logs, it MUST reset its timeout and remove all spans and logs. The SDK MUST apply filtering and sampling before adding spans or logs to the BatchProcessor. The SDK MUST apply rate limits to spans and logs after they leave the BatchProcessor to send as much data as possible by dropping data as late as possible.

The BatchProcessor MUST send all spans and logs in memory to avoid data loss in the following scenarios:

1. When the user calls `SentrySDK.flush()`, the BatchProcessor MUST send all data in memory.
2. When the user calls  `SentrySDK.close()`, the BatchProcessor MUST send all data in memory.
3. When the application shuts down gracefully, the BatchProcessor SHOULD send all data in memory. This is mostly relevant for mobile SDKs already subscribed to these hooks, such as [applicationWillTerminate](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/applicationwillterminate(_:)) on iOS.
4. When the application moves to the background, the BatchProcessor SHOULD send all data in memory and stop the timer. This is mostly relevant for mobile SDKs.
5. We're working on concept for crashes, and will update the specification when we have more details.

The detailed specification is written in the [Gherkin syntax](https://cucumber.io/docs/gherkin/reference/). The specification uses spans as an example, but the same applies to logs or any other future telemetry data.


```Gherkin
Scenario: No spans in BatchProcessor 1 span added
    Given no spans in the BatchProcessor
    When the SDK finishes 1 span
    Then the SDK puts this span to the BatchProcessor
    And starts a timeout of 5 seconds
    And doesn't send the span to Sentry

Scenario: Span added before timeout exceeds
    Given span A in the BatchProcessor
    Given 4.9 seconds pass
    When the SDK finishes span B
    Then the SDK adds span B to the BatchProcessor
    And doesn't reset the timeout
    And doesn't send the spans A and B in the BatchProcessor to Sentry

Scenario: Timeout exceeds and no spans or logs to send
    Given no spans in the BatchProcessor
    When the timeout exceeds
    Then the BatchProcessor does nothing
    And doesn't start a new timeout

Scenario: Spans with size of 1 MiB - 1 byte added, timeout exceeds
    Given spans with size of 1 MiB - 1 byte in the BatchProcessor
    When the timeout exceeds
    Then the SDK adds all the spans to one envelope
    And sends them to Sentry
    And resets the timeout
    And clears the BatchProcessor

Scenario: Spans with size of 1 MiB - 1 byte added within 4.9 seconds
    Given spans with size of 1 MiB - 1 byte in the BatchProcessor
    When the SDK finishes another span and puts it into the BatchProcessor
    Then the BatchProcessor puts all spans into one envelope
    And sends the envelope to Sentry
    And resets the timeout
    And clears the BatchProcessor

Scenario: Unfinished spans
    Given no span is in the BatchProcessor
    When the SDK starts a span but doesn't finish it
    Then the BatchProcessor is empty

Scenario: Span filtered out
    Given no span is in the BatchProcessor
    When the finishes a span
    And the span is filtered out
    Then the BatchProcessor is empty

Scenario: Span not sampled
    Given no span is in the BatchProcessor
    When the finishes a span
    And the span is not sampled
    Then the BatchProcessor is empty

Scenario: 1 span added application crashes
  Given 1 span in the SpansAggregator
  When the SDK detects a crash
  Then the SDK does nothing with the items in the BatchProcessor
  And loses the spans in the BatchProcessor

```

## Sudden Process Terminations

The BatchProcessor SHOULD accordingly handle sudden process terminations, such as crashes or watchdog terminations, to prevent data loss. Since each environment is unique, SDKs have three options to choose from.
The options get more complex the higher their number is. The first option is the simplest and the last option is the most complex. SDKs SHOULD implement the least complex option that is suitable for their environment.

### 1. Store Data into Envelope

When the SDK detects a sudden process termination it MUST put all items in the BatchProcessor into one envelope and store it to disk. When the SDK starts again, it MUST send this envelope to Sentry. The BatchProcessor MUST keep it's existing logic described in the specification above.

If SDKs can't reliably detect sudden process terminations or they can't reliably store envelopes to disk when a sudden process termination happens, they SHOULD implement the [FileStream Cache](#2-file-stream-cache) or the [FIFO Queue with Async IO](#3-fifo-queue-with-async-io).

### 2. FileStream Cache

SDKs for which blocking the main thread is a nogo, such as Android and Apple, SDKs MUST NOT implement this option. They SHOULD implement the [FIFO Queue with Async IO](#3-fifo-queue-with-async-io).

Instead of keeping the data in memory, the BatchProcessor stores the data on the calling thread to disk. The BatchProcessor keeps the timeout logic to ensure the delay of sending data to Sentry is minimal. For efficiency, the BatchProcessor MUST use file handles or file streams when writing data to disk.

The BatchProcessor uses two types of cache files:
- **`current`** - The file the processor is actively writing to
- **`sending`** - The file being converted to an envelope and sent to Sentry (deleted after successful send)

When the timeout expires or the cache file hits the size limit, the BatchProcessor renames the `current` file to `sending`, creates a new `current` file for incoming data, converts the data in the `sending` file to an envelope, sends it to Sentry, and then deletes the `sending` file. When the SDK starts again, it MUST check if there are any cache files in the cache directory (both `current` and `sending`) and if so, it MUST load the data from the files and send it to Sentry.


### 3. Crash Safe List with Async FileStream Cache

This is the recommended option for SDKs that can't reliably detect sudden process terminations or they can't reliably store envelopes to disk when a sudden process termination happens.

With this option, the BatchProcessor stores its logs in a thread-safe list, residing in an async-safe memory space, allowing the crash reporter to write them to disk when a crash occurs. Furthermore, the BatchProcessor stores logs asynchronously into a file, allowing it to recover after an abnormal termination, for which the crash handler can't run.

When the BatchProcessor receives a item, it performs the following steps:

1. Put the log into the async safe and thread safe list on the calling thread.
2. On a background thread, store the items in the list to the batch-processor-cache-file.

The BatchProcessor MUST keep two lists for storing its items and two files for the batch-processor-cache. When one list exceeds half of the max batch size, the BatchProcessor writes those items to an envelope and stores incoming items in the other list and the other batch-processor-file. After it stored the envelope successfully to disk, it removes items in the list and also deletes the batch-processor-cache-file. These are the flushing steps:

1. Store items of `async-safe-list1` to an envelope in the batch processor directory, which MUST be the same folder as the other BatchProcessor files, and name it `batch-processor-cache-envelope-to-flush-list1`.
2. Remove items in `async-safe-list1`
3. Move the `batch-processor-cache-envelope-to-flush-list1` to the envelopes cache folder.

If a crash occurs, between step 2 and 3, SDKs avoid sending duplicate items to Sentry, by discarding items stored in `async-safe-list1` and only send `batch-processor-cache-envelope-to-flush-list1` on the next launch.

When a crash occurs, the SDKs write the items in the list to batch-processor-abnormal-termination-file and send these on the next launch. The SDKs ignore items in batch-processor-cache-file when a batch-processor-abnormal-termination-detected-file exists. SDKs only send items in the batch-processor-cache-file when there is no batch-processor-abnormal-termination-file, which means that an abnormal termination occurred with the SDK being able to detect and handle it.

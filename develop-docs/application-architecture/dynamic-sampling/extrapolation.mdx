---
title: Extrapolation
sidebar_order: 5
---

### Purpose of this document & outline

This document serves as an introduction to extrapolation, informing how extrapolation will interact with different product surfaces and how to integrate it into the product for the users’ benefit. The document covers:

- How data is extrapolated using samples and the connected sample rate for different aggregations & which aggregations cannot be extrapolated
- The effect of extrapolation on data accuracy
- What extrapolation means for the stability of aggregations
- The benefit of extrapolation for the user
    - Sample rate changes do not break alerts
    - Numbers correspond to the real occurrences when looking at sufficiently large groups
- Which use cases are better served by
    - extrapolated data
    - sample data

### Introduction to Extrapolation

Sentry’s system uses sampling to reduce the amount of data ingested, for reasons of both performance and cost. This means that beyond a certain volume, Sentry only ingests a fraction of the data according to the specified sample rate of a project: if you sample at 10% and initially have 1000 requests to your site in a given timeframe, you will only see 100 spans in Sentry. Of course, without making up for the sample rate, this misrepresents the volume of an application, and when different parts of the application have different sample rates, there is even an unfair bias, skewing the total volume towards parts with higher sample rates. This effect is exacerbated for numerical attributes like latency.

To account for this fact, Sentry offers a feature called Extrapolation. Extrapolation smartly combines the data that was ingested to account for different sample rates in different parts of the application. However, low sample rates will cause the extrapolated data to be less accurate than if there was no sampling at all.

So how does one handle this type of data, and when is extrapolated data accurate and expressive? Let’s start with some definitions: 

- **Accuracy** refers to data being correct. For example, the measured number of spans corresponds to the actual number of spans that were executed. As sample rates decrease, accuracy also goes down, because minute random decisions can influence the result in major ways, in absolute numbers. 
- **Expressiveness** refers to data being able to express something about the state of the observed system. For example, a single sample with specific tags and a full trace can be very expressive, and a large amount of spans can have very misleading characteristics. Expressiveness therefore depends on the use case for the data. Also, when traffic is low and 100% of data is sampled, the system is fully accurate despite aggregates being affected by inherent statistical uncertainty that reduce expressiveness.

At first glance, extrapolation may seem unnecessarily complicated. However, for high-volume organizations, sampling is a way to control costs and egress volume, and reduce the amount of redundant data sent to Sentry. Why don’t we just show the user the data they send? We don’t just extrapolate for fun, it actually has some major benefits to the user:

1. **Steady data when the sample rate changes**: Whenever you change sample rates, both the count and possibly the distribution of the values will change in some way. When you switch the sample rate from 10% to 1% for whatever reason, suddenly you have a drop in all associated metrics. Extrapolation corrects for this, so your graphs are steady, and your alerts don’t fire on a change of sample rate. 
2. **Combining different sample rates**: When your endpoints don’t have the same sample rate, how are you supposed to know the true p90 when one of your endpoints is sampled at 1% and another at 100%, but all you get is the aggregate of the samples?




### **Modes**

There are two modes that can be used to view data in Sentry: default mode and sample mode.

- Default mode extrapolates the ingested data as outlined below.
- Sample mode does not extrapolate and presents exactly the data that was ingested.

Depending on the context and the use case, one mode may be more useful than the other. 

There is currently no way for Sentry to automatically switch from the default mode into sample mode based on query attributes, therefore the transition needs to be triggered by the user. However, Sentry can nudge the user, based on observed characteristics of a query, to switch from one mode to another. One example for this is when an ID column is detected: extrapolated aggregates for high-cardinality and low-volume ID columns are usually not very useful, because they may refer to a highly exaggerated volume of data that is not extrapolated correctly due to the high-cardinality nature of the column in question.

## Aggregates

Sentry allows the user to aggregate data in different ways - the following aggregates are generally available, along with whether they are extrapolatable or not:

| **Aggregate** | **Can be extrapolated?** |
| --- | --- |
| avg | yes |
| min | no |
| count | yes |
| sum | yes |
| max | no |
| percentiles | yes |
| count_unique | no |

Each of these aggregates has their own way of dealing with extrapolation, due to the fact that e.g. counts have to be extrapolated in a slightly different way from percentiles. 

[Insert text about how different extrapolation mechanisms work]

As long as there are sufficient samples, the sample rate itself does not matter as much, but due to the extrapolation mechanism, what would be a fluctuation of a few samples, may turn into a much larger absolute impact e.g. in terms of the view count. Of course, when a site gets billions of visits, a fluctation of 100.000 via the noise introduced by a sample rate of 0.00001 is not as salient. 


## How to deal with extrapolation in the product?

### General approach

In new product surfaces, the question of whether or not to use extrapolated vs non-extrapolated data is a delicate one, and it needs to be deliberated with care. In the end, it’s a judgement call on the person implementing the feature, but these questions may be a guide on the way to a decision:

1. What should be the default, and how should the switch between modes work?
    1. In most scenarios, extrapolation should be on by default when looking at aggregates, and off when looking at samples. Switching, in most cases, should be a very conscious operations that users should be aware they are taking, and not an implicit switch that just happens to trigger when users navigate the UI.
2. Does it make sense to mix extrapolated data with non-extrapolated data?
    1. In most cases, mixing the two will be recipe for confusion. For example, offering two functions to compute an aggregate, like p90_raw and p90_extrapolated in a query interface will be very confusing to most users. Therefore, in most cases we should refrain from mixing this data implicitly. 
3. When sample rates change over time, is consistency of data points over time important?
    1. In alerts, for example, consistency is very important, because noise affects the trust users have in the alerting system. A system that alerts everytime users switch sample rates is not very convenient to use, especially in larger teams.
4. Does the user care more about a truthful estimate of the aggregate data or about the actual events that happened?
    1. Some scenarios, like visualizing metrics over time, are based on aggregates, whereas a case of debugging a specific user’s problem hinges on actually seeing the specific events. The best mode depends on the intended usage of the product. 

### Confidence

When users filter on data that has a very low count but also a low sample rate, yielding a highly extrapolated but low-sample dataset, developers and users should be careful with the conclusions they draw from the data. The storage platform provides confidence intervals along with the extrapolated estimates for the different aggregation types to indicate when there is elevated uncertainty in the data. These types of datasets are inherently noisy and may contain misleading information. When this is discovered, the user should either be very careful with the conclusions they draw from the aggregate data, or switch to non-default mode for investigation of the individual samples. 

## **Conclusion**

- Extrapolation offers benefits in many parts of the product, but brings some inherent complexity.
- Some aggregates can be extrapolated, others cannot - we may add the capability to additional aggregates in the future.
- A lot of care should be taken about how to expose extrapolation and especially switching of the modes to the user.
---
title: Transaction vs Continuous Profiling
sidebar_order: 140
description: "Learn about the differences between continuous and transaction-based profiling."
---

We've released a new profiling mode called **continuous profiling**. Read on to learn about the differences between transaction-based and continuous profiling mode. 


## Historical Context

Transaction-based profiling was the first profiling mode supported by Sentry. It made it so that any code executed between `Sentry.startTransaction` and `transaction.finish` could be profiled. In this mode, all profiles were attached to transactions and sent as part of the same envelope. 

This had the benefit of automatically profiling parts of the application that were actually instrumented while requiring no extra effort. This approach had drawbacks that continuous profiling aims to address - one of the most obvious ones being that profiles couldn't exceed 30-second durations.

In theory, transactions can be infinitely long since their duration doesn't impact payload size because start and end are represented by two timestamps. But profiles are different. Each stack sample that is collected by the profiler increases the payload size, which is why all Sentry SDKs had enforced a max profile duration of 30s. This limitation helps safeguard against large payloads that could harm your application performance. 

This unfortunately, comes at the expense of limiting profiling capabilities, making it so that profiling isn't able to profile long-running tasks such as machine learning pipelines or build workflows. This feedback was the driving force behind continuous profiling.

The cap on max profile duration isn't the only drawback of transaction-based profiling. Another limitation is that the profiling data you collect will only ever be as good as the instrumentation you have. In other words, if there are parts of your application that you didn't instrument, the chance of you finding out that they're slowing down your application are near zero.

To address these limitations, we created a different profiling mode, one that doesn't impose constraints on profile durations and can surface parts of your application that might be slowing down your application even if you haven't instrumented them.

## Continuous profiling mode

In countinuous profiling mode, the profiler runs continuously (no pun intended) and regularly flushes what we call profile "profile chunks" to the server, this enables us to extend profile durations and continuously profile your application.

Continuous profiling mode is suitable for profiling long running workflows or processes that you want full visibility into, while the transaction based profiling is largely suitable for workflows where you want to limit profiling to only a subset of your application.


## SDK differences

Transaction based profiling was opaque from the SDK point of view with the SDK being in full control of when the profiler woulds start and stop based on the transactions it would generate. In continuous profiling mode, this is no longer true. Developers can now control when the profiler is started or stopped via new top level SDK methods. The exact method naming varies, but most SDKs that support continuous profiling now expose a top level Sentry.profiler that exposes a startProfiling and stopProfiling method (please see SDK docs for exact definitions).

It is advisable that you call the startProfiling method right after the Sentry SDK is initialized so that you gain visibility at the earliest point in your application lifecycle. From then on, the profiler will keep collecting profiles and sending chunks to Sentry until stopProfiling is called.

## Enabling transaction or continuous profiling mode

Unfortunately, it is currently not possible to use both profiling modes at the same time, as they are mutually exlusive. Since the mode you intend on using depend on the SDK initialization arguments, it means that the profiling mode will have to be selected at the time the Sentry SDK is initialized.

To enable continuous profiling mode, you should ensure that neither profileSampleRate or profilesSampler are set as the values to the Sentry.Init call. If either of those value are set, the SDK will default to transaction based profiling. When the SDK is configured for continuous profiling, the top level calls to start profiles will enable calls to the profiler. If the SDK is configured for transaction based profiling, then these calls will void and not trigger the profiler.

Example of enabling continuous profiling in NodeJS

```javascript
Sentry.Init({
  dsn: "___PUBLIC_DSN___",
  integrations: [nodeProfilingIntegration()]
})

Sentry.profiler.startProfiling();
```

If you wish to keep using transaction based profiling, then the options remain the same and you should either set profilesSampleRate or profilesSampler option on the SDK.


Example of enabling transaction based profiling in NodeJS

```javascript
Sentry.Init({
  dsn: "___PUBLIC_DSN___",
  profileSampleRate: 0.1 // profiles 10% of transactions
  integrations: [nodeProfilingIntegration()]
})

const transaction = Sentry.startTransaction();
//code executed between these two calls is subject to profiling
transaction.finish();
```

Note that while the profiling mode cannot be changed at runtime, it is fine for different projects or applications to use different profiling modes, or to switch modes.

## Differences in product experience

The major difference in product experience when using continuous profiling is that you will be able to visualize a flamegraph for your entire application, which means you can now take a step back from the previous transaction based view and look at your application's runtime as a whole. This makes it easier to for you to prioritize the functions that are slowing down your entire application and not just one particular transaction.

The product experience otherwise remains largely the same with entrypoints into profiling being supported from various parts of the performance product.

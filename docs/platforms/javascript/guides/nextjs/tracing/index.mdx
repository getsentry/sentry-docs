---
title: Set Up Tracing
sidebar_title: Tracing
description: "Monitor performance across all Next.js runtimes: client, server, and edge."
sidebar_order: 5
sidebar_section: features
---

Tracing captures the timing and flow of requests through your Next.js application. Sentry automatically instruments most operations, but Server Actions require manual setup.

## What's Traced Automatically

<SplitLayout>
<SplitSection>
<SplitSectionText>

### By Runtime

The SDK instruments different operations depending on where your code runs:

| Runtime | Auto-Instrumented |
|---------|-------------------|
| **Client** | Page loads, navigations, fetch requests, Web Vitals |
| **Server** | API routes, Server Components, `getServerSideProps` |
| **Edge** | Middleware, edge API routes |

</SplitSectionText>
<SplitSectionCode>

```tsx
// All of these create spans automatically

// Client: navigation creates a span
<Link href="/dashboard">Dashboard</Link>

// Server: API route creates a span
export async function GET() {
  return Response.json({ data });
}

// Server Component: creates a span
export default async function Page() {
  const data = await fetchData();
  return <div>{data}</div>;
}
```

</SplitSectionCode>
</SplitSection>
</SplitLayout>

## Enable Tracing

<SplitLayout>
<SplitSection>
<SplitSectionText>

### Configure Sample Rate

Add `tracesSampleRate` to your Sentry configuration in all three runtime files.

**Start with 100% in development, 10-20% in production.** Adjust based on traffic volume and budget.

</SplitSectionText>
<SplitSectionCode>

```typescript {tabTitle:Client} {filename:instrumentation-client.ts}
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: "___PUBLIC_DSN___",
  tracesSampleRate: process.env.NODE_ENV === "development" ? 1.0 : 0.1,
});
```

```typescript {tabTitle:Server} {filename:sentry.server.config.ts}
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: "___PUBLIC_DSN___",
  tracesSampleRate: process.env.NODE_ENV === "development" ? 1.0 : 0.1,
});
```

```typescript {tabTitle:Edge} {filename:sentry.edge.config.ts}
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: "___PUBLIC_DSN___",
  tracesSampleRate: process.env.NODE_ENV === "development" ? 1.0 : 0.1,
});
```

</SplitSectionCode>
</SplitSection>
</SplitLayout>

## Server Actions

<SplitLayout>
<SplitSection>
<SplitSectionText>

### Why Manual Instrumentation?

Server Actions are **not** automatically instrumented. Without wrapping, they appear as anonymous server operations with no timing or context.

Use `withServerActionInstrumentation` to:
- Create named spans for each action
- Capture timing and errors
- Connect client and server traces

</SplitSectionText>
<SplitSectionCode>

```tsx {filename:app/actions.ts}
"use server";

import * as Sentry from "@sentry/nextjs";

export async function createOrder(formData: FormData) {
  return Sentry.withServerActionInstrumentation(
    "createOrder",
    async () => {
      // Your action logic
      const order = await db.orders.create({
        data: { items: formData.get("items") },
      });
      return { success: true, orderId: order.id };
    }
  );
}
```

</SplitSectionCode>
</SplitSection>

<SplitSection>
<SplitSectionText>

### With Headers

Pass headers to connect client-side traces with server-side spans. This enables full distributed tracing across the browser-to-server boundary.

</SplitSectionText>
<SplitSectionCode>

```tsx {filename:app/actions.ts}
"use server";

import * as Sentry from "@sentry/nextjs";
import { headers } from "next/headers";

export async function submitForm(formData: FormData) {
  return Sentry.withServerActionInstrumentation(
    "submitForm",
    { headers: await headers() },
    async () => {
      // Action logic with full trace context
    }
  );
}
```

</SplitSectionCode>
</SplitSection>
</SplitLayout>

## Web Vitals

<SplitLayout>
<SplitSection>
<SplitSectionText>

### Core Web Vitals

The SDK automatically captures Google's Core Web Vitals on page load:

| Metric | What It Measures |
|--------|------------------|
| **LCP** | Largest Contentful Paint — loading performance |
| **INP** | Interaction to Next Paint — responsiveness |
| **CLS** | Cumulative Layout Shift — visual stability |

These appear as measurements on your page load transactions.

</SplitSectionText>
<SplitSectionCode>

```typescript
// Automatic - no code needed
// Web Vitals are captured on every page load transaction

// View in Sentry:
// Performance → Web Vitals
// Or on individual transaction details
```

</SplitSectionCode>
</SplitSection>
</SplitLayout>

## Custom Instrumentation

<SplitLayout>
<SplitSection>
<SplitSectionText>

### When to Use `startSpan`

Add custom spans when you want to measure:
- Business operations (checkout flow, multi-step wizards)
- External API calls you want to track separately
- Database operations not auto-captured
- Expensive computations

</SplitSectionText>
<SplitSectionCode>

```tsx {filename:app/api/checkout/route.ts}
import * as Sentry from "@sentry/nextjs";

export async function POST(request: Request) {
  return Sentry.startSpan(
    { name: "checkout.process", op: "checkout" },
    async () => {
      // Nested spans for sub-operations
      const cart = await Sentry.startSpan(
        { name: "checkout.validate_cart", op: "validation" },
        () => validateCart(request)
      );

      const payment = await Sentry.startSpan(
        { name: "checkout.process_payment", op: "payment" },
        () => processPayment(cart)
      );

      return Response.json({ orderId: payment.orderId });
    }
  );
}
```

</SplitSectionCode>
</SplitSection>

<SplitSection>
<SplitSectionText>

### Add Attributes

Attach data to spans for filtering and debugging in Sentry.

</SplitSectionText>
<SplitSectionCode>

```tsx
Sentry.startSpan(
  {
    name: "order.process",
    op: "order",
    attributes: {
      "order.id": orderId,
      "order.value": cart.total,
      "order.item_count": cart.items.length,
    },
  },
  async () => {
    // Operation logic
  }
);
```

</SplitSectionCode>
</SplitSection>
</SplitLayout>

## Distributed Tracing

<SplitLayout>
<SplitSection>
<SplitSectionText>

### Automatic Propagation

The SDK automatically propagates trace context for:
- `fetch()` requests to your own domain
- Server Actions (when using `withServerActionInstrumentation` with headers)

For external APIs, configure `tracePropagationTargets`:

</SplitSectionText>
<SplitSectionCode>

```typescript {filename:instrumentation-client.ts}
Sentry.init({
  dsn: "___PUBLIC_DSN___",
  tracesSampleRate: 0.1,

  // Propagate traces to these external services
  tracePropagationTargets: [
    "localhost",
    /^https:\/\/api\.yourcompany\.com/,
    /^https:\/\/payments\.stripe\.com/,
  ],
});
```

</SplitSectionCode>
</SplitSection>
</SplitLayout>

## Quick Reference

| Scenario | Auto-Instrumented? | Action |
|----------|-------------------|--------|
| Page loads and navigations | Yes | None |
| API routes (`route.ts`) | Yes | None |
| Server Components | Yes | None |
| `getServerSideProps` | Yes | None |
| **Server Actions** | **No** | Use `withServerActionInstrumentation` |
| External API calls | Partial | Configure `tracePropagationTargets` |
| Custom business logic | No | Use `startSpan` |

## Disable Tracing

To fully disable tracing, **remove** `tracesSampleRate` from your config. Setting it to `0` still initializes tracing code.

For complete removal from your bundle, set the build flag:

```bash {filename:.env}
__SENTRY_TRACING__=false
```

See <PlatformLink to="/configuration/tree-shaking/">Tree Shaking</PlatformLink> for details.

## Troubleshooting

### Server Actions not appearing

Ensure you're using `withServerActionInstrumentation`:

```tsx
// ❌ No span created
export async function myAction() {
  return doSomething();
}

// ✅ Creates a named span
export async function myAction() {
  return Sentry.withServerActionInstrumentation("myAction", () => {
    return doSomething();
  });
}
```

### Traces disconnected between client and server

Pass headers to `withServerActionInstrumentation` to connect the trace:

```tsx
import { headers } from "next/headers";

export async function myAction() {
  return Sentry.withServerActionInstrumentation(
    "myAction",
    { headers: await headers() },
    () => doSomething()
  );
}
```

### High trace volume

If you're sending too many traces, lower your sample rate or use `tracesSampler` for dynamic sampling:

```typescript
Sentry.init({
  tracesSampler: ({ name, attributes }) => {
    // Always sample errors
    if (attributes?.["http.status_code"] >= 500) return 1.0;
    // Sample 5% of health checks
    if (name.includes("health")) return 0.05;
    // Default 10%
    return 0.1;
  },
});
```

See <PlatformLink to="/tracing/configure-sampling/">Configure Sampling</PlatformLink> for more options.

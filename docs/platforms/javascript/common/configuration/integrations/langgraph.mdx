---
title: LangGraph
description: "Adds instrumentation for LangGraph."
supported:
  - javascript.node
  - javascript.aws-lambda
  - javascript.azure-functions
  - javascript.connect
  - javascript.express
  - javascript.fastify
  - javascript.gcp-functions
  - javascript.hapi
  - javascript.hono
  - javascript.koa
  - javascript.nestjs
  - javascript.electron
  - javascript.nextjs
  - javascript.nuxt
  - javascript.solidstart
  - javascript.sveltekit
  - javascript.react-router
  - javascript.remix
  - javascript.astro
  - javascript.bun
  - javascript.tanstackstart-react
  - javascript.cloudflare
  - javascript
---

<Alert>

This integration works in the Node.js, Cloudflare Workers, Vercel Edge Functions, and browser runtimes. It requires SDK version `10.25.0` or higher.

</Alert>

_Import name: `Sentry.langGraphIntegration`_

LangGraph is instrumented via the [`langGraphIntegration`](./langgraph), which automatically captures spans for LangGraph operations including agent invocations, graph executions, and node operations.

<PlatformSection notSupported={["javascript.cloudflare", "javascript.nextjs", "javascript"]}>

It is enabled by default and will automatically capture spans for LangGraph operations. You can opt-in to capture inputs and outputs by setting `recordInputs` and `recordOutputs` in the integration config:

```javascript
Sentry.init({
  dsn: "____PUBLIC_DSN____",
  tracesSampleRate: 1.0,
  integrations: [
    Sentry.langGraphIntegration({
      recordInputs: true,
      recordOutputs: true,
    }),
  ],
});
```

## Usage Example

```javascript
import { ChatOpenAI } from "@langchain/openai";
import { StateGraph, MessagesAnnotation, START, END } from '@langchain/langgraph';

// Create LLM call
const llm = new ChatOpenAI({
  modelName: "gpt-4o",
  apiKey: process.env.OPENAI_API_KEY,
});

async function callLLM(state) {
  const response = await llm.invoke(state.messages);

  return {
    messages: [...state.messages, response],
  };
}

// Create the agent
const agent = new StateGraph(MessagesAnnotation)
  .addNode('agent', callLLM)
  .addEdge(START, 'agent')
  .addEdge('agent', END);

const compiledAgent = agent.compile({ name: 'my_agent' });

// Invoke the agent - automatically instrumented
const result = await compiledAgent.invoke({
  messages: [
    new SystemMessage("You are a helpful assistant."),
    new HumanMessage("Hello!"),
  ],
});
```

</PlatformSection>

<PlatformSection supported={["javascript.cloudflare"]}>

For Cloudflare Workers, you need to manually instrument the LangGraph graph using the `instrumentLangGraph` helper:

```javascript
import * as Sentry from "@sentry/cloudflare";
import { ChatOpenAI } from "@langchain/openai";
import { StateGraph, MessagesAnnotation, START, END } from '@langchain/langgraph';

// Create LLM call
const llm = new ChatOpenAI({
  modelName: "gpt-4o",
  apiKey: process.env.OPENAI_API_KEY,
});

async function callLLM(state) {
  const response = await llm.invoke(state.messages);

  return {
    messages: [...state.messages, response],
  };
}

// Create the agent
const agent = new StateGraph(MessagesAnnotation)
  .addNode('agent', callLLM)
  .addEdge(START, 'agent')
  .addEdge('agent', END);

const graph = agent.compile({ name: 'my_agent' });

// Manually instrument the graph
Sentry.instrumentLangGraph(graph, {
  recordInputs: true,
  recordOutputs: true,
});

// Invoke the agent
const result = await graph.invoke({
  messages: [
    new SystemMessage("You are a helpful assistant."),
    new HumanMessage("Hello!"),
  ],
});
```

</PlatformSection>

<PlatformSection supported={["javascript"]}>

For browser applications, you need to manually instrument the LangGraph graph using the `instrumentLangGraph` helper:

```javascript
import * as Sentry from "@sentry/browser";
import { ChatOpenAI } from "@langchain/openai";
import { StateGraph, MessagesAnnotation, START, END } from '@langchain/langgraph';

// Create LLM call
const llm = new ChatOpenAI({
  modelName: "gpt-4o",
  apiKey: process.env.OPENAI_API_KEY,
});

async function callLLM(state) {
  const response = await llm.invoke(state.messages);

  return {
    messages: [...state.messages, response],
  };
}

// Create the agent
const agent = new StateGraph(MessagesAnnotation)
  .addNode('agent', callLLM)
  .addEdge(START, 'agent')
  .addEdge('agent', END);

const graph = agent.compile({ name: 'my_agent' });

// Manually instrument the graph
Sentry.instrumentLangGraph(graph, {
  recordInputs: true,
  recordOutputs: true,
});

// Invoke the agent
const result = await graph.invoke({
  messages: [
    new SystemMessage("You are a helpful assistant."),
    new HumanMessage("Hello!"),
  ],
});
```

</PlatformSection>

## Options

### `recordInputs`

_Type: `boolean`_

Records inputs to LangGraph operations (such as messages and state data passed to the graph).

Defaults to `true` if `sendDefaultPii` is `true`.

```javascript
Sentry.init({
  integrations: [Sentry.langGraphIntegration({ recordInputs: true })],
});
```

### `recordOutputs`

_Type: `boolean`_

Records outputs from LangGraph operations (such as generated responses, agent outputs, and final state).

Defaults to `true` if `sendDefaultPii` is `true`.

```javascript
Sentry.init({
  integrations: [Sentry.langGraphIntegration({ recordOutputs: true })],
});
```

## Configuration

By default this integration adds tracing support for LangGraph operations including:

- **Agent Creation** (`gen_ai.create_agent`) - Captures spans when compiling a StateGraph into an executable agent
- **Agent Invocation** (`gen_ai.invoke_agent`) - Captures spans for agent execution via `invoke()`

## Supported Versions

- `@langchain/langgraph`: `>=0.2.0 <1.0.0`

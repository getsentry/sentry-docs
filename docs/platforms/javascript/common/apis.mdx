---
title: APIs
description: "Learn more about APIs of the SDK."
customCanonicalTag: "/platforms/javascript/apis/"
sidebar_order: 3
---

This page shows all available to-level APIs of the SDK. You can use them like this:

```javascript
import * as Sentry from "@sentry/browser";

Sentry.setTag("tag", "value");
```

## Available Options

<TableOfContents ignoreIds={["available-options"]} />

## Core APIs

<SdkApi
  name="init"
  signature="function init(options: InitOptions): Client | undefined"
>
  Initialize the SDK with the given options. See{" "}
  <PlatformLink to="/configuration/options/">Options</PlatformLink> for the
  options you can pass to `init`.
</SdkApi>

<SdkApi name="getClient" signature="function getClient(): Client | undefined">
  Returns the currently active client.
</SdkApi>

<SdkApi
  name="setCurrentClient"
  signature="function setCurrentClient(client: Client): void"
>
  Make the given client the current client. You do not need this if you use
  `init()`, this is only necessary if you are manually setting up a client.Àù
</SdkApi>

<SdkApi
  name="lastEventId"
  signature="function lastEventId(): string | undefined"
>
  Returns the ID of the last sent error event. Note that this does not guarantee
  that this event ID exists, as it may have been dropped along the way.
</SdkApi>

<SdkApi
  name="flush"
  signature="function flush(timeout?: number): Promise<boolean>"
  parameters={[
    {
      name: "timeout",
      type: "number",
      description:
        "Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause the client to wait until all events are sent before resolving the promise.",
    },
  ]}
>
  Flushes all pending events.
</SdkApi>

<SdkApi name="isEnabled" signature="function isEnabled(): boolean">
  Returns true if the SDK is initialized & enabled.
</SdkApi>

<SdkApi
  name="close"
  signature="function flush(timeout?: number): Promise<boolean>"
  parameters={[
    {
      name: "timeout",
      type: "number",
      description:
        "Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause the client to wait until all events are sent before resolving the promise.",
    },
  ]}
>
  Flushes all pending events and disables the SDK. Note that this does not
  remove any listeners the SDK may have set up.
</SdkApi>

<SdkApi
  name="addEventProcessor"
  signature="function addEventProcessor(processor: EventProcessor): void"
  parameters={[
    {
      name: "processor",
      type: "(event: Event, hint: EventHint) => Event | null | Promise<Event | null>",
    },
  ]}
>
  Adds an event processor to the SDK. An event processor receives every event
  before it is sent to Sentry. It can either mutate the event (and return it) or
  return `null` to discard the event. Event processors can also return a
  promise, but it is recommended to use this only when necessary as it slows
  down event processing.
</SdkApi>

<SdkApi
  name="addIntegration"
  signature="function addIntegration(integration: Integration): void"
>
  Adds an integration to the SDK. This can be used to conditionally add
  integrations after `Sentry.init()` has been called. Note that it is
  recommended to pass integrations to `init` instead of calling this method,
  where possible.
</SdkApi>

<SdkApi name="lazyLoadIntegration" signature="function lazyLoadIntegration(name: string, scriptNonce?: string): Promise<Integration>" categorySupported={['browser']}>
  Lazy load an integration. This expects the name to be e.g. `replayIntegration`. It will load the script from the CDN, and return a promise that resolves to the integration, which can then be added to the SDK using `addIntegration`:

```javascript
Sentry.lazyLoadIntegration("replayIntegration")
  .then((integration) => {
    Sentry.addIntegration(integration);
  })
  .catch((error) => {
    // Make sure to handle errors here!
    // This rejects e.g. if the CDN bundle cannot be loaded
  });
```

If you use a bundler, using e.g. `const { replayIntegration } = await import('@sentry/browser')` is recommended instead.

</SdkApi>

## Scopes

<SdkApi name="getCurrentScope" signature="function getCurrentScope(): Scope">
  Returns the current scope. See{" "}
  <PlatformLink to="/configuration/scopes/">Scopes</PlatformLink> for more
  information.
</SdkApi>

<SdkApi
  name="withScope"
  signature="function withScope(callback: (scope: Scope) => void): void"
>
  Forks the current scope and calls the callback with the forked scope. See{" "}
  <PlatformLink to="/configuration/scopes/">Scopes</PlatformLink> for more
  information.
</SdkApi>

<SdkApi
  name="getIsolationScope"
  signature="function getIsolationScope(): Scope"
>
  Returns the current isolation scope.
</SdkApi>

<SdkApi
  name="withIsolationScope"
  signature="function withIsolationScope(callback: (scope: Scope) => void): void"
>
  Forks the current isolation scope and calls the callback with the forked
  scope. See <PlatformLink to="/configuration/scopes/">Scopes</PlatformLink> for
  more information.
</SdkApi>

<SdkApi name="getGlobalScope" signature="function getGlobalScope(): Scope">
  Returns the global scope. See{" "}
  <PlatformLink to="/configuration/scopes/">Scopes</PlatformLink> for more
  information.
</SdkApi>

## Capturing Events

<SdkApi
  name="captureException"
  signature={`function captureException(
  exception: unknown,
  captureContext?: CaptureContext
): EventId`}
  parameters={[
    {
      name: "exception",
      required: true,
      type: "unknown",
      description: "The exception to capture. This is usually an Error object.",
    },
    {
      name: "captureContext",
      type: {
        name: "CaptureContext",
        properties: [
          {
            name: "user",
            type: {
              name: "User",
              properties: [
                { name: "id", type: "string | number" },
                { name: "email", type: "string" },
                { name: "ip_address", type: "string" },
                { name: "username", type: "string" },
              ],
            },
          },
          {
            name: "level",
            type: '"fatal" | "error" | "warning" | "log" | "info" | "debug"',
          },
          {
            name: "extra",
            type: "Record<string, unknown>",
            description:
              "Additional data that should be sent with the exception.",
          },
          {
            name: "tags",
            type: "Record<string, string>",
            description:
              "Additional tags that should be sent with the exception.",
          },
          { name: "contexts", type: "Record<string, Record<string, unknown>>" },
          { name: "fingerprint", type: "string[]" },
        ],
      },
      description: "Optional additional data to attach to the Sentry event.",
    },
  ]}
>
  Capture an exception event and send it to Sentry. Note that you can pass not
  only `Error` objects, but also other objects as `exception` - in that case,
  the SDK will attempt to serialize the object for you, and the stack trace will
  be generated by the SDK and may be less accurate.
</SdkApi>

<SdkApi
name="captureMessage"
signature={`function captureMessage(
  message: string,
  captureContext?: CaptureContext | SeverityLevel
): EventId`}
parameters={[
  {
    name: "message",
    required: true,
    type: "string",
    description: "The message to capture.",
  },
  {
    name: "captureContext",
    type: {
      name: "CaptureContext",
      properties: [
        {
          name: "user",
          type: {
            name: "User",
            properties: [
              { name: "id", type: "string | number" },
              { name: "email", type: "string" },
              { name: "ip_address", type: "string" },
              { name: "username", type: "string" },
            ],
          },
        },
        {
          name: "level",
          type: '"fatal" | "error" | "warning" | "log" | "info" | "debug"',
        },
        {
          name: "extra",
          type: "Record<string, unknown>",
          description:
            "Additional data that should be sent with the exception.",
        },
        {
          name: "tags",
          type: "Record<string, string>",
          description:
            "Additional tags that should be sent with the exception.",
        },
        { name: "contexts", type: "Record<string, Record<string, unknown>>" },
        { name: "fingerprint", type: "string[]" },
      ],
    },
    description: "Optional additional data to attach to the Sentry event.",
  },
]}
>
Capture a message event and send it to Sentry. Optionally, instead of a
`CaptureContext`, you can also pass a `SeverityLevel` as second argument, e.g.
`"error"` or `"warning"`.

Messages show up as issues on your issue stream, with the message as the issue name.

</SdkApi>

## Enriching Events

<SdkApi
  name="setTag"
  signature="function setTag(key: string, value: string): void"
  parameters={[]}
>
  Set a tag to be sent with Sentry events.
</SdkApi>

<SdkApi
  name="setTags"
  signature="function setTags(tags: Record<string, string>): void"
  parameters={[]}
>
  Set multiple tags to be sent with Sentry events.
</SdkApi>

<SdkApi
  name="setContext"
  signature="function setContext(name: string, context: Record<string, unknown>): void"
  parameters={[]}
>
  Set a context to be sent with Sentry events.
</SdkApi>

<SdkApi
  name="setExtra"
  signature="function setExtra(name: string, extra: unknown): void"
  parameters={[]}
>
  Set additional data to be sent with Sentry events.
</SdkApi>

<SdkApi
  name="setExtras"
  signature="function setExtras(extras: Record<string, unknown>): void"
  parameters={[]}
>
  Set multiple additional data entries to be sent with Sentry events.
</SdkApi>

<SdkApi
  name="setUser"
  signature="function setUser(user: User | null): void"
  parameters={[
    {
      name: "user",
      type: {
        name: "User",
        properties: [
          { name: "id", type: "string | number" },
          { name: "email", type: "string" },
          { name: "ip_address", type: "string" },
          { name: "username", type: "string" },
        ],
      },
    },
  ]}
>
  Set a user to be sent with Sentry events. Set to `null` to unset the user.
</SdkApi>

<SdkApi
  name="addBreadcrumb"
  signature="function addBreadcrumb(breadcrumb: Breadcrumb, hint?: Hint): void"
  parameters={[
    {
      name: "breadcrumb",
      required: true,
      type: {
        name: "Breadcrumb",
        properties: [
          {
            name: "message",
            type: "string",
            description:
              "If a message is provided, it is rendered as text with all whitespace preserved.",
          },
          {
            name: "type",
            type: '"default" | "debug" | "error" | "info" | "navigation" | "http" | "query" | "ui" | "user"',
            defaultValue: '"default"',
            description:
              "The type influences how a breadcrumb is rendered in Sentry. When in doubt, leave it at `default`.",
          },
          {
            name: "level",
            type: '"fatal" | "error" | "warning" | "log" | "info" | "debug"',
            defaultValue: '"info"',
            description:
              "The level is used in the UI to emphasize or deemphasize the breadcrumb.",
          },
          {
            name: "category",
            type: "string",
            description:
              "Typically it is a module name or a descriptive string. For instance, `ui.click` could be used to indicate that a click happened",
          },
          {
            name: "data",
            type: "Record<string, unknown>",
            description:
              "Additional data that should be sent with the breadcrumb.",
          },
        ],
      },
    },
    {
      name: "hint",
      type: "Record<string, unknown>",
      description:
        "A hint object containing additional information about the breadcrumb.",
    },
  ]}
>
  You can manually add breadcrumbs whenever something interesting happens. For
  example, you might manually record a breadcrumb if the user authenticates or
  another state change occurs.
</SdkApi>

## Tracing

<SdkApi
name="startSpan"
signature="function startSpan<T>(options: StartSpanOptions, callback: (span: Span) => T): T"
parameters={[
  {
    name: "options",
    required: true,
    type: {
      name: 'StartSpanOptions',
      properties: [
        { name: "name", type: "string", required: true },
        { name: 'attributes', type: 'Record<string, string | number | boolean | null | undefined>', description: 'Attributes to add to the span.' },
        { name: 'startTime', type: 'number', description: 'The timestamp to use for the span start. If not provided, the current time will be used.' },
        { name: 'op', type: 'string', description: 'The operation name for the span. This is used to group spans in the UI' },
        { name: 'forceTransaction', type: 'boolean', description: 'If true, the span will be forced to be sent as a transaction, even if it is not the root span.' },
        { name: 'parentSpan', type: 'Span | null', description: 'The parent span for the new span. If not provided, the current span will be used.' },
        { name: 'onlyIfParent', type: 'boolean', description: 'If true, the span will only be created if there is an active span.' },
      ]
    },
  },
  { name: "callback", type: "(span: Span) => T", required: true },
]}>
  Starts a new span, that is active in the provided callback.
  This span will be a child of the currently active span, if there is one.

Any spans created inside of the callback will be children of this span.

The started span will automatically be ended when the callback returns, and will thus measure the duration of the callback. The callback cann also be an async function.

  <Expandable title='Examples'>
  ```javascript
  // Synchronous example
 Sentry.startSpan({ name: 'my-span' }, (span) => {
    measureThis();
  });

// Asynchronous example
const status = await Sentry.startSpan({ name: 'my-span' }, async (span) => {
const status = await doSomething();
return status;
});

````
</Expandable>

See <PlatformLink to="/tracing/instrumentation/">Tracing Instrumentation</PlatformLink> for more information on how to work with spans.

</SdkApi>

<SdkApi
  name="startInactiveSpan"
  signature="function startInactiveSpan<T>(options: StartSpanOptions): Span"
  parameters={[
  {
    name: "options",
    required: true,
    type: {
      name: 'StartSpanOptions',
      properties: [
        { name: "name", type: "string", required: true },
        { name: 'attributes', type: 'Record<string, string | number | boolean | null | undefined>', description: 'Attributes to add to the span.' },
        { name: 'startTime', type: 'number', description: 'The timestamp to use for the span start. If not provided, the current time will be used.' },
        { name: 'op', type: 'string', description: 'The operation name for the span. This is used to group spans in the UI' },
        { name: 'forceTransaction', type: 'boolean', description: 'If true, the span will be forced to be sent as a transaction, even if it is not the root span.' },
        { name: 'parentSpan', type: 'Span | null', description: 'The parent span for the new span. If not provided, the current span will be used.' },
        { name: 'onlyIfParent', type: 'boolean', description: 'If true, the span will only be created if there is an active span.' },
      ]
    },
  }
]}>
  Starts a new span. This span will be a child of the currently active span, if there is one.
  The returned span has to be ended manually via `span.end()` when the span is done.

  <Expandable title='Examples'>
  ```javascript
const span = Sentry.startInactiveSpan({ name: 'my-span' });
doSomething();
span.end();
````

</Expandable>

See <PlatformLink to="/tracing/instrumentation/">Tracing Instrumentation</PlatformLink> for more information on how to work with spans.

</SdkApi>

<SdkApi
 name="startSpanManual"
 signature="function startSpanManual<T>(options: StartSpanOptions, callback: (span: Span) => T): T"
 parameters={[
  {
    name: "options",
    required: true,
    type: {
      name: 'StartSpanOptions',
      properties: [
        { name: "name", type: "string", required: true },
        { name: 'attributes', type: 'Record<string, string | number | boolean | null | undefined>', description: 'Attributes to add to the span.' },
        { name: 'startTime', type: 'number', description: 'The timestamp to use for the span start. If not provided, the current time will be used.' },
        { name: 'op', type: 'string', description: 'The operation name for the span. This is used to group spans in the UI' },
        { name: 'forceTransaction', type: 'boolean', description: 'If true, the span will be forced to be sent as a transaction, even if it is not the root span.' },
        { name: 'parentSpan', type: 'Span | null', description: 'The parent span for the new span. If not provided, the current span will be used.' },
        { name: 'onlyIfParent', type: 'boolean', description: 'If true, the span will only be created if there is an active span.' },
      ]
    },
  },
  { name: "callback", type: "(span: Span) => T", required: true },
]}>
  Starts a new span, that is active in the provided callback.
  This span will be a child of the currently active span, if there is one.

Any spans created inside of the callback will be children of this span.

The started span will _not_ automatically end - you have to call `span.end()` when the span is done. Please note that the span will still only be the parent span of spans created inside of the callback, while the callback is active. In most cases, you will want to use `startSpan` or `startInactiveSpan` instead.

  <Expandable title='Examples'>
  ```javascript
const status = await Sentry.startSpanManual({ name: 'my-span' }, async (span) => {
const status = await doSomething();
span.end();
return status;
});

````
</Expandable>

See <PlatformLink to="/tracing/instrumentation/">Tracing Instrumentation</PlatformLink> for more information on how to work with spans.

</SdkApi>

<SdkApi
  name="continueTrace"
  signature="function continueTrace<T>(options: TraceOptions, callback: () => T): T"
  parameters={[
    {
      name: "options",
      type: {
        name: "TraceOptions",
        properties: [
          {
            name: "sentryTrace",
            type: "string",
            description: "The sentry-trace header.",
          },
          {
            name: "baggage",
            type: "string",
            description: "The baggage header.",
          },
        ],
      },
    },
    {
      name: "callback",
      type: "() => T",
      description: "The callback to continue the trace.",
    },
  ]}
>
  Continues a trace in the provided callback. Any spans created inside of the
  callback will be linked to the trace.
</SdkApi>

<SdkApi
  name="suppressTracing"
  signature="function suppressTracing<T>(callback: () => T): T"
>
  Ensure that all spans created inside of the provided callback are not sent to
  Sentry.
</SdkApi>

<SdkApi
  name="startNewTrace"
  signature="function startNewTrace<T>(callback: () => T): T"
>
  Start a new trace that is active in the provided callback.
</SdkApi>

<SdkApi
  name="startBrowserTracingPageLoadSpan"
  signature="function startBrowserTracingPageLoadSpan(client: Client, options: StartSpanOptions): Span | undefined"
  categorySupported={["browser"]}
>
  Start an pageload span that will be automatically ended when the page is
  considered idle. If a pageload/navigation span is currently ongoing, it will
  automatically be ended first. In most cases, you do not need to call this, as
  the `browserTracingIntegration` will automatically do that for you. However,
  if you opt-out of pageload spans, you can use this method to manually start
  such a span. Please note that this function will do nothing if
  `browserTracingIntegration` has not been enabled.
</SdkApi>

<SdkApi
  name="startBrowserTracingNavigationSpan"
  signature="function startBrowserTracingNavigationSpan(client: Client, options: StartSpanOptions): Span | undefined"
  categorySupported={["browser"]}
>
  Start an navigation span that will be automatically ended when the page is
  considered idle. If a pageload/navigation span is currently ongoing, it will
  automatically be ended first. In most cases, you do not need to call this, as
  the `browserTracingIntegration` will automatically do that for you. However,
  if you opt-out of navigation spans, you can use this method to manually start
  such a span. Please note that this function will do nothing if
  `browserTracingIntegration` has not been enabled.
</SdkApi>

<SdkApi name="withActiveSpan" signature="function withActiveSpan<T>(span: Span | null, callback: () => T): T">
  Runs the provided callback with the given span as the active span. If `null` is provided, the callback will have no active span.
</SdkApi>

## Tracing Utilities

These utilities can be used for more advanced tracing use cases.

<SdkApi name="spanToJSON" signature="function spanToJSON(span: Span): SpanJSON">
  Convert a span to a JSON object.
</SdkApi>

<SdkApi
  name="updateSpanName"
  signature="function updateSpanName(span: Span, name: string): void"
>
  Update the name of a span. Use this over `span.updateName(name)` to ensure
  that the span is updated in all backends.
</SdkApi>

<SdkApi
  name="getActiveSpan"
  signature="function getActiveSpan(): Span | undefined"
>
  Get the currently active span.
</SdkApi>

<SdkApi name="getRootSpan" signature="function getRootSpan(span: Span): Span">
  Get the root span of a span.
</SdkApi>

## Sessions

<SdkApi name="startSession" signature="function startSession(): void">
  Starts a new session.
</SdkApi>

<SdkApi name="endSession" signature="function endSession(): void">
  Ends the current session (but does not send it to Sentry).
</SdkApi>

<SdkApi
  name="captureSession"
  signature="function captureSession(end = false): void"
>
  Sends the current session on the scope to Sentry. Pass `true` as argument to
  end the session first.
</SdkApi>

## User Feedback

<SdkApi
  name="captureFeedback"
  signature="function captureFeedback(feedback: Feedback, hint?: Hint): string"
  parameters={[
    {
      name: "feedback",
      type: {
        name: "Feedback",
        properties: [
          { name: "message", type: "string", required: true },
          { name: "name", type: "string" },
          { name: "email", type: "string" },
          { name: "url", type: "string" },
          { name: "source", type: "string" },
          {
            name: "associatedEventId",
            type: "string",
            description: "The event id that this feedback is associated with.",
          },
          { name: "tags", type: "Record<string, string>" },
        ],
      },
      description: "The feedback to capture.",
    },
    {
      name: "hint",
      type: {
        name: "Hint",
        properties: [
          {
            name: "captureContext",
            type: {
              name: "CaptureContext",
              properties: [
                {
                  name: "user",
                  type: {
                    name: "User",
                    properties: [
                      { name: "id", type: "string | number" },
                      { name: "email", type: "string" },
                      { name: "ip_address", type: "string" },
                      { name: "username", type: "string" },
                    ],
                  },
                },
                {
                  name: "level",
                  type: '"fatal" | "error" | "warning" | "log" | "info" | "debug"',
                },
                {
                  name: "extra",
                  type: "Record<string, unknown>",
                  description:
                    "Additional data that should be sent with the exception.",
                },
                {
                  name: "tags",
                  type: "Record<string, string>",
                  description:
                    "Additional tags that should be sent with the exception.",
                },
                {
                  name: "contexts",
                  type: "Record<string, Record<string, unknown>>",
                },
                { name: "fingerprint", type: "string[]" },
              ],
            },
            description:
              "Optional additional data to attach to the Sentry event.",
          },
        ],
      },
      description:
        "Optional hint object containing additional information about the feedback.",
    },
  ]}
>
  Send user feedback to Sentry.
</SdkApi>

<SdkApi
  name="getFeedback"
  signature="function getFeedback(): ReturnType<feedbackIntegration> | undefined"
>
  Get the feedback integration, if it has been added. This can be used to access
  the feedback integration in a type-safe way.
</SdkApi>

<SdkApi
  name="sendFeedback"
  signature="function sendFeedback(feedback: Feedback, hint?: Hint): Promise<string>"
  parameters={[
    {
      name: "feedback",
      type: {
        name: "Feedback",
        properties: [
          { name: "message", type: "string", required: true },
          { name: "name", type: "string" },
          { name: "email", type: "string" },
          { name: "url", type: "string" },
          { name: "source", type: "string" },
          {
            name: "associatedEventId",
            type: "string",
            description: "The event id that this feedback is associated with.",
          },
          { name: "tags", type: "Record<string, string>" },
        ],
      },
      description: "The feedback to capture.",
    },
    {
      name: "hint",
      type: {
        name: "Hint",
        properties: [
          {
            name: "captureContext",
            type: {
              name: "CaptureContext",
              properties: [
                {
                  name: "user",
                  type: {
                    name: "User",
                    properties: [
                      { name: "id", type: "string | number" },
                      { name: "email", type: "string" },
                      { name: "ip_address", type: "string" },
                      { name: "username", type: "string" },
                    ],
                  },
                },
                {
                  name: "level",
                  type: '"fatal" | "error" | "warning" | "log" | "info" | "debug"',
                },
                {
                  name: "extra",
                  type: "Record<string, unknown>",
                  description:
                    "Additional data that should be sent with the exception.",
                },
                {
                  name: "tags",
                  type: "Record<string, string>",
                  description:
                    "Additional tags that should be sent with the exception.",
                },
                {
                  name: "contexts",
                  type: "Record<string, Record<string, unknown>>",
                },
                { name: "fingerprint", type: "string[]" },
              ],
            },
            description:
              "Optional additional data to attach to the Sentry event.",
          },
        ],
      },
      description:
        "Optional hint object containing additional information about the feedback.",
    },
  ]}
>
  This method is similar to [`captureFeedback`](#capturefeedback), but it
  returns a promise that resolves only when the feedback was successfully sent
  to Sentry. It will reject if the feedback cannot be sent.
</SdkApi>

<PlatformCategorySection supported={['server']}>
## Cron Monitoring

<SdkApi
  name="captureCheckIn"
  signature="function captureCheckIn(checkIn: CheckIn, monitorConfig?: MonitorConfig): string"
  categorySupported={["server"]}
  parameters={[
    {
      name: "checkIn",
      type: {
        name: "CheckIn",
        properties: [
          {
            name: "status",
            type: '"ok" | "error" | "in_progress"',
            required: true,
          },
          { name: "monitorSlug", type: "string", required: true },
          { name: "checkInId", type: "string" },
          { name: "duration", type: "number" },
        ],
      },
      required: true,
    },
    {
      name: "monitorConfig",
      type: {
        name: "MonitorConfig",
        properties: [
          {
            name: "schedule",
            type: '{ type: "crontab", value: string } | { type: "interval", value: number, unit: "year" | "month" | "day" | "hour" | "minute" }',
            required: true,
          },
          { name: "checkinMargin", type: "number" },
          { name: "maxRuntime", type: "number" },
          { name: "timezone", type: "string" },
          { name: "failureIssueThreshold", type: "number" },
          { name: "recoveryThreshold", type: "number" },
        ],
      },
    },
  ]}
>
  Create a cron monitor check in and send it to Sentry.
</SdkApi>

<SdkApi
name="withMonitor"
signature={`function withMonitor(
monitorSlug: string,
callback: () => any,
monitorConfig?: MonitorConfig
): string`}
categorySupported={['server']}
parameters={[
{
  name: "monitorSlug",
  type: 'string',
  required: true,
},
 {
  name: "callback",
  type: '() => any',
  required: true,
},
{
  name: "monitorConfig",
  type: {
    name: "MonitorConfig",
    properties: [
      {
        name: "schedule",
        type: '{ type: "crontab", value: string } | { type: "interval", value: number, unit: "year" | "month" | "day" | "hour" | "minute" }',
        required: true,
      },
      { name: "checkinMargin", type: "number" },
      { name: "maxRuntime", type: "number" },
      { name: "timezone", type: "string" },
      { name: "failureIssueThreshold", type: "number" },
      { name: "recoveryThreshold", type: "number" },
    ],
  },
},
]}
>
Wraps a callback with a cron monitor check in. The check in will be sent to Sentry when the callback finishes.
</SdkApi>
</PlatformCategorySection>
```
````

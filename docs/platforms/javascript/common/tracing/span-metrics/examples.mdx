---
title: Example Instrumentation
description: "Examples of using span metrics to debug performance issues and monitor application behavior across frontend and backend services."
sidebar_order: 10
---

<Alert>

These examples assume you have already <PlatformLink to="/tracing/">set up tracing</PlatformLink> in your application.

</Alert>

<Alert>

The sample code contained within this page is for demonstration purposes only. It is not production-ready and may not be up to date with the latest version of Sentry. It's included as sample JavaScript code, and ultimately may not be for your specific language or framework.

</Alert>

This guide provides practical examples of using span attributes and metrics to solve common monitoring and debugging challenges across your entire application stack. Each example demonstrates how to instrument both frontend and backend components, showing how they work together within a distributed trace to provide end-to-end visibility. You'll also find example repository code, walkthroughs and attributes to explore.

## E-Commerce Checkout Flow (React + Backend)

<Arcade src="https://demo.arcade.software/tGYGb3qewR6i4xjRt2Tg?embed" />

Example Repository: [Crash Commerce](https://github.com/getsentry/crash-commerce-tracing-sample)

**Challenge:** Capture end-to-end checkout flow, understand average cart size and value, diagnose performance of payment providers across frontend, and server API.

**Solution:** Start a client span on the checkout action for the application, and relevant spans on the backend for each step in the checkout flow. Attach attributes that represent critical metrics for the application, such as cart size and value, and payment provider used in the transaction.

**Frontend (React) — instrument the Checkout click handler:**

```javascript
// In your Checkout button click handler
Sentry.startSpan(
  {
    name: 'Checkout',
    op: 'ui.action',
    attributes: {
      'cart.item_count': cartCount,
      'cart.value_minor': cartValueMinor,
      'cart.currency': 'USD',
      'payment.provider.ui_selected': paymentProvider,
    },
  },
  async (span) => {
    try {
      const response = await fetch(`${API_URL}/api/checkout`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ items: cart, paymentProvider }),
      })
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Payment failed' }))
        throw new Error(errorData.error || `HTTP ${response.status}`)
      }
      const data: { orderId: string; paymentProvider: string } = await response.json()
      span.setAttribute('order.id', data.orderId)
      span.setAttribute('payment.provider', data.paymentProvider)
      Sentry.logger.info(Sentry.logger.fmt`✨ Order ${data.orderId} confirmed via ${data.paymentProvider}`)
      
      // Show order confirmation
      setOrderConfirmation({
        orderId: data.orderId,
        provider: data.paymentProvider,
        total: cartValueMinor
      })
      setCart([])
      setIsCartOpen(false)
    } catch (err) {
      span.setStatus({ code: 2, message: 'internal_error' })
      const errorMessage = err instanceof Error ? err.message : 'Checkout failed'
      setCheckoutError(errorMessage)
      Sentry.logger.error(Sentry.logger.fmt`❌ ${errorMessage}`)
    } finally {
      setIsCheckingOut(false)
    }
  }
)
```

Where to put this in your app:
- In the `onClick` for the checkout button, or inside the submit handler of your checkout form/container component.
- Auto-instrumentation will add client `fetch` spans; keep the explicit UI span for specific application context.

**Backend — Checkout API with an Order Processing span, and a Payment span:**

```javascript
// Example: Node/Express
app.post('/api/checkout', async (req: Request, res: Response) => {
  await Sentry.startSpan(
    {
      name: 'Order Processing',
      op: 'commerce.order.server',
    },
    async (span) => {
      try {
        const items = (req.body?.items as { productId: string; quantity: number }[]) || []
        const requestedProviderRaw = (req.body?.paymentProvider as string | undefined) ?? undefined
        const requestedProvider = PAYMENT_PROVIDERS.find((p) => p === requestedProviderRaw) ?? pickPaymentProvider()

        // Validate cart
        if (!Array.isArray(items) || items.length === 0) {
          span.setAttribute('payment.status', 'failed')
          span.setAttribute('inventory.reserved', false)
          res.status(400).json({ error: 'Cart is empty' })
          return
        }

        let totalMinor = 0
        for (const line of items) {
          const product = PRODUCTS.find((p) => p.id === line.productId)
          if (!product || line.quantity <= 0) {
            span.setAttribute('payment.status', 'failed')
            span.setAttribute('inventory.reserved', false)
            res.status(400).json({ error: 'Invalid cart item' })
            return
          }
          totalMinor += product.priceMinor * line.quantity
        }

        // Simulate reserving inventory (80% chance true)
        const reserved = Math.random() < 0.8

        // Simulate payment
        const charge = await Sentry.startSpan(
          {
            name: `Charge ${requestedProvider}`,
            op: 'commerce.payment',
            attributes: {
              'payment.provider': requestedProvider,
            },
          },
          async (paymentSpan) => {
            const result = await fakeCharge(totalMinor, requestedProvider)
            paymentSpan.setAttribute('payment.status', result.status)
            return result
          }
        )

        if (charge.status === 'failed' || !reserved) {
          span.setAttribute('payment.provider', charge.provider)
          span.setAttribute('payment.status', 'failed')
          span.setAttribute('inventory.reserved', reserved)
          res.status(402).json({ error: 'Payment failed' })
          return
        }

        const orderId = randomId()
        ORDERS.push({ id: orderId, totalMinor, items })

        // Set attributes before returning
        span.setAttribute('order.id', orderId)
        span.setAttribute('payment.provider', charge.provider)
        span.setAttribute('payment.status', 'success')
        span.setAttribute('inventory.reserved', reserved)

        res.json({ orderId, paymentProvider: charge.provider })
      } catch (err) {
        Sentry.captureException(err)
        res.status(500).json({ error: 'Internal error' })
      }
    }
  )
})
```

**How the trace works together:**
- UI span starts when checkout is selected → Server Backend starts a span to continue the track when the server `/checkout` API is called. As payment processes, a payment span is started.
- Attributes and Span metrics let you track more than just the latency of the request. Can track store busienss performances through `cart.item_count` and other `cart` attributes, and store reliabiliyt by checking error performance on `payment.provider` properties.

What to monitor with span metrics:
- p95 span.duration of `op:ui.action` checkout by `cart.item_count` bucket.
- Error rate for `op:payment` by `payment.provider`.

## Media Upload with Background Processing (React + Express)

Example Repository: [SnapTrace](https://github.com/getsentry/snaptrace)

**Challenge:** Track user-perceived upload time, server-side validation, and async media processing (optimization, thumbnail generation) while maintaining trace continuity across async boundaries.

**Solution:** Start a client span for the entire upload experience, create a backend span for upload validation, and a separate span for async media processing. Use rich attributes instead of excessive spans to capture processing details.

**Frontend (React) — Instrument Upload Action**

```typescript
// In your UploadForm component's upload handler
const handleUpload = async () => {
  if (!selectedFile) return;

  // Start Sentry span for entire upload operation
  await Sentry.startSpan(
    {
      name: 'Upload media',
      op: 'file.upload',
      attributes: {
        'file.size_bytes': selectedFile.size,
        'file.mime_type': selectedFile.type,
      }
    },
    async (span) => {
      const uploadStartTime = Date.now();
      
      try {
        // Single API call to upload and start processing
        const uploadResponse = await fetch(`${API_BASE_URL}/api/upload`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            fileName: selectedFile.name,
            fileType: selectedFile.type,
            fileSize: selectedFile.size
          })
        });

        if (!uploadResponse.ok) {
          throw new Error(`Upload failed: ${uploadResponse.statusText}`);
        }

        const uploadData = await uploadResponse.json();
        
        // Set success attributes
        span?.setAttribute('upload.success', true);
        span?.setAttribute('upload.duration_ms', Date.now() - uploadStartTime);
        span?.setAttribute('job.id', uploadData.jobId);
        
        // Update UI to show processing status
        updateUploadStatus(uploadId, 'processing');
        
      } catch (error) {
        span?.setAttribute('upload.success', false);
        span?.setAttribute('upload.error', error instanceof Error ? error.message : 'Unknown error');
        setUploadStatus('error');
      }
    }
  );
};
```

Where to put this in your app:
- In the upload button click handler or form submit handler
- In drag-and-drop onDrop callback
- Auto-instrumentation will capture fetch spans; the explicit span adds business context

**Backend — Upload Validation and Async Processing**

```typescript
// Import Sentry instrumentation first (required for v10)
import './instrument';
import express from 'express';
import * as Sentry from '@sentry/node';

// POST /api/upload - Receive and validate upload, then trigger async processing
app.post('/api/upload', async (req: Request<{}, {}, UploadRequest>, res: Response) => {
  const { fileName, fileType, fileSize } = req.body;

  // Span 2: Backend validates and accepts upload
  await Sentry.startSpan(
    {
      op: 'upload.receive',
      name: 'Receive upload',
      attributes: {
        'file.name': fileName,
        'file.size_bytes': fileSize,
        'file.mime_type': fileType,
        'validation.passed': true
      }
    },
    async (span) => {
      try {
        // Validate the upload
        if (!fileName || !fileType || !fileSize) {
          span?.setAttribute('validation.passed', false);
          span?.setAttribute('validation.error', 'Missing required fields');
          return res.status(400).json({ error: 'Missing required fields' });
        }

        if (fileSize > 50 * 1024 * 1024) { // 50MB limit
          span?.setAttribute('validation.passed', false);
          span?.setAttribute('validation.error', 'File too large');
          return res.status(400).json({ error: 'File too large (max 50MB)' });
        }

        // Create a job for processing
        const job = createJob(fileName, fileType, fileSize);
        span?.setAttribute('job.id', job.id);

        // Start async processing (Span 3 will be created here)
        setImmediate(async () => {
          await processMedia(job);
        });

        // Respond immediately with job ID
        res.json({
          jobId: job.id,
          status: 'accepted',
          message: 'Upload received and processing started'
        });

      } catch (error) {
        span?.setAttribute('validation.passed', false);
        span?.setAttribute('error.message', error instanceof Error ? error.message : 'Unknown error');
        Sentry.captureException(error);
        res.status(500).json({ error: 'Failed to process upload' });
      }
    }
  );
});

// Async media processing (runs in background via setImmediate)
export async function processMedia(job: ProcessingJob): Promise<void> {
  await Sentry.startSpan(
    {
      op: 'media.process',
      name: 'Process media',
      attributes: {
        'media.size_bytes': job.fileSize,
        'media.mime_type': job.fileType,
        'media.size_bucket': getSizeBucket(job.fileSize),
        'job.id': job.id
      }
    },
    async (span) => {
      try {
        const startTime = Date.now();
        const operations: string[] = [];
        
        // Simulate image optimization and thumbnail generation
        if (job.fileType.startsWith('image/')) {
          // Note: No separate spans for these operations - use attributes instead
          await optimizeImage(); // Simulated delay
          operations.push('optimize');
          
          await generateThumbnail(); // Simulated delay
          operations.push('thumbnail');
        }
        
        // Calculate results
        const sizeSaved = Math.floor(job.fileSize * 0.3); // 30% reduction
        const thumbnailCreated = Math.random() > 0.05; // 95% success rate
        
        // Rich attributes instead of multiple spans
        span?.setAttribute('processing.operations', operations);
        span?.setAttribute('processing.optimization_level', 'high');
        span?.setAttribute('processing.thumbnail_created', thumbnailCreated);
        span?.setAttribute('processing.duration_ms', Date.now() - startTime);
        span?.setAttribute('result.size_saved_bytes', sizeSaved);
        span?.setAttribute('result.size_reduction_percent', 30);
        span?.setAttribute('result.status', 'success');
        
        // Update job status
        job.status = 'completed';
        
      } catch (error) {
        span?.setAttribute('result.status', 'failed');
        span?.setAttribute('error.message', error instanceof Error ? error.message : 'Unknown error');
        Sentry.captureException(error);
      }
    }
  );
}
```

**How the trace works together:**
- Frontend span (`file.upload`) captures the entire user experience from file selection to server response.
- Backend validation span (`upload.receive`) tracks server-side validation and job creation.
- Async processing span (`media.process`) runs in background with rich attributes for all processing operations.
- No unnecessary spans for individual operations — prefer attributes for details.
- Trace continuity is maintained via Sentry’s automatic context propagation.

What to monitor with span metrics:
- p95 upload duration by `file.size_bucket`.
- Processing success rate by `media.mime_type`.
- Average storage saved via `result.size_saved_bytes` where `result.status = success`.
- Validation failure reasons grouped by `validation.error`.

## Search Autocomplete (debounced, cancellable, performance monitoring)

Example Repository: [NullFlix](https://github.com/getsentry/nullflix-tracing-sample)

**Challenge:** Users type quickly in search; you need to debounce requests, cancel in-flight calls, handle errors gracefully, and monitor performance across different query types while keeping latency predictable.

**Solution:** Start a client span for each debounced request, mark aborted requests, track search patterns, and on the server, instrument search performance with meaningful attributes.

**Frontend (React + TypeScript) — instrument debounced search:**

```typescript
const response = await Sentry.startSpan(
  {
    op: 'http.client',
    name: 'Search autocomplete',
    attributes: {
      'query.length': searchQuery.length,
      'ui.debounce_ms': DEBOUNCE_MS,
    },
  },
  async (span) => {
    try {
      const response = await fetch(
        `${API_URL}/api/search?${new URLSearchParams({ q: searchQuery })}`,
        {
          signal: controller.signal,
          headers: { 'Content-Type': 'application/json' },
        }
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        const errorMessage = errorData.error || `Search failed: ${response.status}`;
        throw new Error(errorMessage);
      }

      const data: SearchResponse = await response.json();
      
      span?.setAttribute('results.count', data.results.length);
      span?.setAttribute('results.has_results', data.results.length > 0);
      span?.setAttribute('http.response_size', JSON.stringify(data).length);
      span?.setStatus({ code: 1, message: 'ok' });
      
      return data;
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        span?.setAttribute('ui.aborted', true);
        span?.setStatus({ code: 2, message: 'cancelled' });
        throw error;
      }
      
      span?.setStatus({ code: 2, message: error instanceof Error ? error.message : 'unknown error' });
      throw error;
    }
  }
);
```

Where to put this in your app:
- In your search input component, triggered after debounce timeout

**Backend (Node.js + Express) — instrument search with meaningful attributes:**

```typescript
app.get('/api/search', async (req: Request, res: Response) => {
  await Sentry.startSpan(
    {
      name: 'Search',
      op: 'search',
    },
    async (span) => {
      try {
        const query = String(req.query.q || '');
        const queryLength = query.length;
        
        // Check if request was aborted
        req.on('close', () => {
          if (!res.headersSent) {
            span?.setStatus({ code: 2, message: 'cancelled' });
            span?.setAttribute('request.aborted', true);
          }
        });
        
        if (!query) {
          span?.setAttribute('results.count', 0);
          span?.setAttribute('search.engine', 'elasticsearch');
          return res.json({ results: [] });
        }
        
        // Perform search
        const startSearch = Date.now();
        const results = await searchMovies(query);
        const searchDuration = Date.now() - startSearch;
        
        // Set span attributes
        span?.setAttribute('search.engine', 'elasticsearch');
        span?.setAttribute('search.mode', queryLength < 3 ? 'prefix' : 'fuzzy');
        span?.setAttribute('results.count', results.length);
        span?.setAttribute('query.length', queryLength);
        
        // Track slow searches
        if (searchDuration > 500) {
          span?.setAttribute('performance.slow', true);
          span?.setAttribute('search.duration_ms', searchDuration);
        }
        
        return res.json({ results });
      } catch (error: any) {
        span?.setStatus({ code: 2, message: error?.message || 'error' });
        span?.setAttribute('error.type', (error as any)?.constructor?.name || 'Error');
        
        Sentry.captureException(error);
        if (!res.headersSent) {
          return res.status(500).json({ error: 'Search failed' });
        }
      }
    }
  );
});
```

**How the trace works together:**
- Client span starts when debounced search triggers → tracks the full user-perceived latency.
- Aborted requests are marked with `ui.aborted=true` and short duration, showing wasted work.
- Server span shows search performance characteristics: mode (prefix vs fuzzy), results count, and slow queries.

What to monitor with span metrics:
- p95 duration of `op:search` grouped by `query.length`.
- Characteristics of slow searches via `op:search performance.slow:true`.
- Compare prefix vs fuzzy via `op:search` grouped by `search.mode`.
- Cancellation rate via `op:http.client ui.aborted:true`.
- Empty result rate via `op:http.client results.has_results:false`.
- Distribution of `http.response_size` for payload optimization.
- Error rate for `op:search` filtered by `status:error`.
- Backend abandonment via `op:search request.aborted:true`.

---
title: Trace Propagation
description: "Learn how to connect events across applications/services."
sidebar_order: 3000
notSupported:
  - javascript.cordova
---

If the overall application landscape that you want to observe with Sentry consists of more than just a single service or application, distributed tracing can add a lot of value.

## What is Distributed Tracing?

In the context of tracing events across a distributed system, distributed tracing acts as a powerful debugging tool. Imagine your application as a vast network of interconnected parts. For example, your system might be spread across different servers or your application might split into different backend and frontend services, each potentially having their own technology stack.

When an error or performance issue occurs, it can be challenging to pinpoint the root cause due to the complexity of such a system. Distributed tracing helps you follow the path of an event as it travels through this intricate web, recording every step it takes. By examining these traces, you can reconstruct the sequence of events leading up to the event of interest, identify the specific components involved, and understand their interactions. This detailed visibility enables you to diagnose and resolve issues more effectively, ultimately improving the reliability and performance of your distributed system.

## Basic Example

Here's an example showing a distributed trace in Sentry:

<Include name="common-imgs/distributed-trace-in-sentry" />

This distributed trace shows a Vue app's `pageload` making a request to a Python backend, which then calls the `/api` endpoint of a Ruby microservice.

What happens in the background is that Sentry uses reads and further propagates two HTTP headers between your applications:

- `sentry-trace`
- `baggage`

If you run any JavaScript applications in your distributed system, make sure that those two headers are added to your CORS allowlist and won't be blocked or stripped by your proxy servers, gateways, or firewalls.

## Trace Duration

<PlatformCategorySection supported={["browser"]}>

In the browser, the SDK automatically starts a new trace in the following situations:

- On page load: Whenever the page is (re-)loaded, a new trace is started. At the same time, a `pageload` span is created (see <PlatformLink to="/tracing/instrumentation/automatic-instrumentation">Performance Monitoring</PlatformLink>). Once this span ends, the trace remains until the next navigation or page load. In case the server serving the initial page already started a trace and sent the necessary [HTML tags](./custom-instrumentation/#extract-tracing-information-from-html-meta-tags) to the browser, the SDK will continue this trace instead of starting a new one.
- On navigation: Whenever a user navigates (for example in a single-page application), a new trace is started. At the same time, a `navigation` span is created (see <PlatformLink to="/tracing/instrumentation/automatic-instrumentation">Performance Monitoring</PlatformLink>). Once this span ends, the trace remains until the next navigation or page load.

In both cases, this means that if you start spans after the automatic `pageload` and `navigation` spans ended, they will still be part of the same trace. This makes it easy to connect what happened before and after your span.

</PlatformCategorySection>

<PlatformCategorySection supported={["server", "serverless"]}>

Server-side SDKs handle traces automatically on a per-request basis. This means that SDKs will:

- Continue an existing trace if the incoming request contains a trace header.
- Start a new trace if the incoming request does not contain a trace header. This trace stays active until the response is sent.

</PlatformCategorySection>

If necessary, you can override the default trace duration by [manually starting a new trace](./custom-instrumentation#starting-a-new-trace).

## How to Use Distributed Tracing?

<PlatformContent includePath="distributed-tracing/how-to-use/" />

<Alert level="info" >

Remember that in order to propagate trace information through your whole distributed system, you have to use Sentry in all of the involved services and applications. Take a look at the respective SDK documentation to learn how distributed tracing can be enabled for each platform.

</Alert>

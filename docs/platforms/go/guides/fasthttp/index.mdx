---
title: FastHTTP
description: "Learn how to add Sentry instrumentation to programs using the FastHTTP package."
---

For a quick reference, there is a [complete example](https://github.com/getsentry/sentry-go/tree/master/_examples/fasthttp) available directly at the Go SDK source code repository.

[Go Dev-style API documentation](https://pkg.go.dev/github.com/getsentry/sentry-go/fasthttp) is also available.

## Install

```bash
go get github.com/getsentry/sentry-go
go get github.com/getsentry/sentry-go/fasthttp
```

<Break />

## Configure

### Initialize the Sentry SDK

<PlatformContent includePath="getting-started-config" />

### Options

`sentryfasthttp` accepts a struct of `Options` that allows you to configure how the handler will behave.

```go
// Repanic configures whether Sentry should repanic after recovery, in most cases, it defaults to false,
// as fasthttp doesn't include its own Recovery handler.
Repanic bool
// WaitForDelivery configures whether you want to block the request before moving forward with the response.
// Because fasthttp doesn't include its own `Recovery` handler, it will restart the application,
// and the event won't be delivered otherwise.
WaitForDelivery bool
// Timeout for the event delivery requests.
Timeout time.Duration
```

<Break />

```go
// Create an instance of sentryfasthttp
sentryHandler := sentryfasthttp.New(sentryfasthttp.Options{
    Repanic:         false,
    WaitForDelivery: true,
    Timeout:         5 * time.Second,
})
```

## Verify

```go
// Create an instance of sentryfasthttp
sentryHandler := sentryfasthttp.New(sentryfasthttp.Options{
// specify options here...
})

// After creating the instance, you can attach the handler as one of your middleware
fastHTTPHandler := sentryHandler.Handle(func(ctx *fasthttp.RequestCtx) {
	// capturing an error intentionally to simulate usage
	sentry.CaptureMessage("It works!")
	
	ctx.SetStatusCode(fasthttp.StatusOK)
})

fmt.Println("Listening and serving HTTP on :3000")

// And run it
if err := fasthttp.ListenAndServe(":3000", fastHTTPHandler); err != nil {
	panic(err)
}
```

## Usage

`sentryfasthttp` attaches an instance of `*sentry.Hub` (https://pkg.go.dev/github.com/getsentry/sentry-go#Hub) to the request's context, which makes it available throughout the rest of the request's lifetime.
You can access it by using the `sentryfasthttp.GetHubFromContext()` method on the context itself in any of your proceeding middleware and routes.
And it should be used instead of the global `sentry.CaptureMessage`, `sentry.CaptureException`, or any other calls, as it keeps the separation of data between the requests.

**Keep in mind that `*sentry.Hub` won't be available in middleware attached before `sentryfasthttp`!**

```go
func enhanceSentryEvent(handler fasthttp.RequestHandler) fasthttp.RequestHandler {
	return func(ctx *fasthttp.RequestCtx) {
		if hub := sentryfasthttp.GetHubFromContext(ctx); hub != nil {
			hub.Scope().SetTag("someRandomTag", "maybeYouNeedIt")
		}
		handler(ctx)
	}
}

// Later in the code
sentryHandler := sentryfasthttp.New(sentryfasthttp.Options{
	Repanic: true,
	WaitForDelivery: true,
})

defaultHandler := func(ctx *fasthttp.RequestCtx) {
	if hub := sentryfasthttp.GetHubFromContext(ctx); hub != nil {
		hub.WithScope(func(scope *sentry.Scope) {
			scope.SetExtra("unwantedQuery", "someQueryDataMaybe")
			hub.CaptureMessage("User provided unwanted query string, but we recovered just fine")
		})
	}
	ctx.SetStatusCode(fasthttp.StatusOK)
}

fooHandler := enhanceSentryEvent(func(ctx *fasthttp.RequestCtx) {
	panic("y tho")
})

fastHTTPHandler := func(ctx *fasthttp.RequestCtx) {
	switch string(ctx.Path()) {
	case "/foo":
		fooHandler(ctx)
	default:
		defaultHandler(ctx)
	}
}

fmt.Println("Listening and serving HTTP on :3000")

if err := fasthttp.ListenAndServe(":3000", sentryHandler.Handle(fastHTTPHandler)); err != nil {
	panic(err)
}
```

### Accessing Context in `BeforeSend` callback


```go
sentry.Init(sentry.ClientOptions{
	Dsn: "___PUBLIC_DSN___",
	BeforeSend: func(event *sentry.Event, hint *sentry.EventHint) *sentry.Event {
		if hint.Context != nil {
			if ctx, ok := hint.Context.Value(sentry.RequestContextKey).(*fasthttp.RequestCtx); ok {
				// You have access to the original Context if it panicked
				fmt.Println(string(ctx.Request.Host()))
			}
		}
		return event
	},
})
```

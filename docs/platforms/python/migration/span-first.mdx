---
title: Migrate to Span Streaming
sidebar_order: 8998
description: "Learn about switching to span streaming in the SDK."
---

This guide describes the common patterns involved in migrating to the new span
streaming API introduced in version `<TODO>`.


## Enabling Span Streaming

In your SDK `init()`, provide the following experimental option:

```python
import sentry_sdk

sentry_sdk.init(
    # ...your existing options...
    _experiments={
        "trace_lifecycle": "stream",
    },
)
```

Note that you need to have tracing enabled via the `traces_sample_rate` or
`traces_sampler` option.

In order to stream spans, you need to switch to the new `traces.start_span` API
in addition to setting `trace_lifecycle="stream"`. Using the legacy
`sentry_sdk.start_span` and `sentry_sdk.start_transaction` API will not stream
spans.


## New `start_span` API

The `sentry_sdk.start_span()`, `sentry_sdk.start_transaction()`, and
`span.start_child()` APIs have been replaced by `sentry_sdk.traces.start_span()`.

```python diff
  import sentry_sdk

- with sentry_sdk.start_span(name="flow.checkout") as span:
+ with sentry_sdk.traces.start_span(name="flow.checkout") as span:
      ...
```

Alternatively, you can just change the import:

```python diff
- from sentry_sdk import start_span
+ from sentry_sdk.traces import start_span

  with start_span(name="flow.checkout") as span:
      ...
```

The `sentry_sdk.start_transaction()` API doesn't exist anymore. Instead, use
`sentry_sdk.traces.start_span()`.

```python diff
  import sentry_sdk

- with sentry_sdk.start_transaction(name="flow.checkout") as transaction:
+ with sentry_sdk.traces.start_span(name="flow.checkout") as span:
      ...
```

### Arguments

The `sentry_sdk.traces.start_span()` API accepts the following arguments:
- `name`: Required.
- `attributes`: See [Attributes Stored on Spans](#attributes-stored-on-spans).
- `parent_span`: A span instance that should be set as the parent of this span.
  If not provided, the currently active span will be set as the parent, if any.

The new API does not accept the `description` argument anymore. `description`
should be migrated to `name`.

The `op` argument is also not supported anymore. However, there's a 
`span.set_op(op)` method on the span.

```python diff
- from sentry_sdk import start_span
+ from sentry_sdk.traces import start_span

- with start_span(description="span", op="db.query") as span:
-     ...
+ with start_span(name="span") as span:
+     span.set_op("db.query")
```


### Using as a Context Manager or Directly

`sentry_sdk.traces.start_span()` can be used as a context manager or directly.

```python
import sentry_sdk

with sentry_sdk.traces.start_span(name="flow.checkout") as span:
    ... # Do something

# The span ends once the with block is over
```

The above is equivalent to:

```python
import sentry_sdk

span = sentry_sdk.traces.start_span(name="flow.checkout")
span.start()
# Do something
span.finish()
```

### Other Tracing API

#### `@trace`

The span-streaming-friendly version of the `@trace` decorator is accessible under
`@sentry_sdk.traces.trace` and accepts an optional `name` (defaulting to function
name) and `attributes`.

```python diff
- from sentry_sdk import trace
+ from sentry_sdk.traces import trace

@trace(name="flow.checkout", attributes={"flow.pipeline": "legacy"})
def checkout():
    ...
```

#### `start_child()`

The `span.start_child()` API is not supported anymore.

You can either start the child span with `sentry_sdk.traces.start_span()` while
the parent span is still active, in which case it'll become its parent automatically,
or, in more difficult scenarios, you can set the `parent_span` argument to control
the parentage:

```python
import sentry_sdk

with sentry_sdk.traces.start_span(name="outer") as span:
    with sentry_sdk.traces.start_span(name="child 1"):
        with sentry_sdk.traces.start_span(name="child 2", parent_span=span):
            ...
```

In this case, "child 2" would be a direct child of "outer" rather than
"child 1". If you didn't provide a `parent_span` to "child 2",
it would become the direct child of "child 1".

## Span Attributes

Spans now have attributes. These are key-value pairs, where keys are strings and
values are of type `int`, `bool`, `str`, `float`, or an array of these primitive
types (no mixing of types supported, they all have to be the same in one array).
Notably, `None` attribute values are not supported.

The following API exists to retrieve and mutate the attributes set on a span:

```python
import sentry_sdk

with sentry_sdk.traces.start_span(name="flow.checkout.prepare") as span:
    span.set_attribute("flow.version", "0.35")
    span.set_attributes({"flow.conversion": 1.0, "flow.use_new_pipeline": True})
    span.get_attributes()  # returns {"flow.version": "0.35", "flow.conversion": 1.0, "flow.use_new_pipeline": True}
    span.remove_attribute("flow.conversion")
    span.get_attributes()  # returns {"flow.version": "0.35", "flow.use_new_pipeline": True}
```

In span streaming mode, spans have no contexts, data, or tags. Everything is a
span attribute. It's therefore necessary to migrate all existing
`span.set_data()`, `span.set_context()`, and `span.set_tag()` to
`span.set_attribute()`.

Replacing `set_data()`:

```python diff
import sentry_sdk

- with sentry_sdk.start_span(name="flow.checkout.process") as span:
-     span.set_data("flow.step", "submit_payment")
+ with sentry_sdk.traces.start_span(name="flow.checkout.process") as span:
+     span.set_attribute("flow.step", "submit_payment")
```

Replacing `set_context()`:

```python diff
import sentry_sdk

- with sentry_sdk.start_span(name="flow.checkout.process") as span:
-     span.set_context("flow", {"id": "123456789", "pipeline": "legacy"})
+ with sentry_sdk.traces.start_span(name="flow.checkout.process") as span:
+     # Dictionaries are not allowed as attribute values, so take the original
+     # context apart:
+     span.set_attribute("flow.id", "123456789")
+     span.set_attribute("flow.pipeline", "legacy")
```

Replacing `set_tag()`:

```python diff
import sentry_sdk

- with sentry_sdk.start_span(name="flow.checkout.process") as span:
-     span.set_tag("http.status_code", 201)
+ with sentry_sdk.traces.start_span(name="flow.checkout.process") as span:
+     span.set_attribute("http.response.status_code", 201)
```

### Applying Data from Scope

Note that since spans no longer support tags, tags set on the scope with the
global `sentry_sdk.set_tag()` API will not be applied to spans. You can use the
the `scope.set_attribute()` API to set attributes on the scope -- spans captured
in that scope will inherit them.

```python diff
  import sentry_sdk

  sentry_sdk.set_tag("region", "Europe")
+ scope = sentry_sdk.get_global_scope()
+ scope.set_attribute("region", "Europe")
```

In the above example, the tag will be applied to all telemetry that supports
tags, while the attribute will be applied to all telemetry that supports
attributes (streaming spans, logs, metrics).

Use the global scope if you want the attribute to be applied to all telemetry
over the lifecycle of your program. If you need to only apply it to a specific
subset of telemetry, use the isolation or the current scope. See [the Scopes
documentation](/platforms/python/enriching-events/scopes/)
for more details.

## Other Span Properties

### Status

Span status can only be `ok` or `error`. The status is `ok` by default. Use the
 `span.set_status()` API to update it.

```python
from sentry_sdk.traces import start_span

with start_span(name="span") as span:
    try:
        ...
    except:
        span.set_status("error")
```

### Source

```python
from sentry_sdk.traces import start_span

with start_span(name="span") as span:
    span.set_source("function")
```

## Trace Propagation

In span streaming mode, trace propagation is done via the
`sentry_sdk.traces.continue_trace()` API.

`sentry_sdk.traces.continue_trace()` works slightly differently to the legacy
`sentry_sdk.continue_trace()`:
- It's not a context manager.
- It doesn't return a transaction.

Instead, it sets the SDK's propagation context, which holds trace propagation
data like `trace_id`, `parent_span_id`, and so on. When a span starts, it
automatically checks the current propagation context and makes sure incoming
traces are continued and that we also propagate trace information to outgoing
requests.

```python diff
import sentry_sdk

# Example incoming headers from a request
headers = {
    "sentry-trace": "4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-1",
    "baggage": "sentry-trace_id=4bf92f3577b34da6a3ce929d0e0e4736,sentry-sample_rate=0.5,sentry-sample_rand=0.123456",
}

- with sentry_sdk.continue_trace(headers) as transaction:
-     pass
+ sentry_sdk.traces.continue_trace(headers)  # Sets the propagation context
+ with sentry_sdk.traces.start_span():  # This span will continue the trace
+     pass
```

## Sampling

In order to make a sampling decision `traces_sampler`, you'll have all starting
attributes on the span accessible in `sampling_context["attributes"]`. You can
provide attributes via the `attributes` argument to
`sentry_sdk.traces.start_span()`.

Sampling is applied on span start. If you're using the context manager way
(`with start_span(...):`), the span will be sampled immediately after the `with`
block is entered. If you're using the direct `span = start_span(...)` API, the
span will be sampled when calling `span.start()`.

As before, sampling will only be applied to top-level spans. Children spans
inherit the sampling decision of their parents, unless specifically filtered
out via the [`ignore_span` callback](#filtering).

### Custom sampling context

If you're using a traces sampler, it's possible to provide a custom sampling
context in addition to the attributes set on the span. The custom sampling
context will solely be used for making the sampling decision in the traces
sampler and will not be materialized on the span in any way. It also has no
type restrictions, so you can, for instance, have the whole request object
accessible in the traces sampler in a web framework context, as long as it's
accessible at sampling time.

Before, the custom sampling context used to be an optional argument to
`start_span`. In span streaming mode, it's instead a method on the scope:

```python diff
  import sentry_sdk

  def traces_sampler(sampling_context):
      if sampling_context["asgi_scope"].method not in ("GET", "POST"):
          return 0.0
      return 1.0

  sentry_sdk.init(
+     _experiments={"trace_lifecycle": "stream"},
      traces_sampler=traces_sampler,
  )

  custom_sampling_context = {
      "asgi_scope": asgi_scope,
  }

- with sentry_sdk.start_span(
-     name="flow.start",
-     custom_sampling_context=custom_sampling_context
- ):
-     ...
+ sentry_sdk.get_current_scope().set_custom_sampling_context(custom_sampling_context)
+ with sentry_sdk.traces.start_span(name="flow.start"):
+     ...
```

## Filtering

`<TODO: ignore_spans>`

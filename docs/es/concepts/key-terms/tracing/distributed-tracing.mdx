---
title: Trazabilidad distribuida
sidebar_order: 20
description: >-
  Con la trazabilidad distribuida, puedes seguir el rendimiento del software y
  medir el caudal (throughput) y la latencia, mientras observas el impacto de
  los errores en múltiples sistemas.
og_image: /og-images/concepts-key-terms-tracing-distributed-tracing.png
---

La trazabilidad distribuida ofrece una vista conectada de tu aplicación de frontend a backend. Ayuda a seguir el rendimiento del software, medir [métricas](/es/product/insights/overview/metrics/) como el caudal (throughput) y la latencia, y mostrar el impacto de los errores en múltiples sistemas. Esto convierte a Sentry en una solución más completa de [monitorización del rendimiento](/es/product/insights/overview/), que ayuda a diagnosticar problemas y a medir la salud general de tu aplicación.

El [tracing](/es/concepts/key-terms/tracing/distributed-tracing/) en Sentry proporciona información como:

* Qué ocurrió en un evento de error o incidencia específicos
* Las condiciones que provocan cuellos de botella o problemas de latencia
* Los endpoints u operaciones que consumen más tiempo

<div id="what-is-distributed-tracing">
  ## ¿Qué es el trazado distribuido?
</div>

Una herramienta de trazado se centra en qué ocurrió (y cuándo), registrando eventos durante la ejecución de un programa en múltiples sistemas. Las trazas suelen incluir marcas de tiempo, lo que permite calcular duraciones, pero su propósito es más amplio: mostrar cómo interactúan los sistemas interconectados y cómo los problemas en uno pueden afectar a otro. Aunque el trazado puede ser útil si se instrumenta solo en el frontend o el backend, es más potente cuando se configura para toda tu pila (trazado distribuido).

Es importante señalar que el trazado no es [profiling](/es/product/explore/profiling/). Un generador de perfiles (profiler) mide diversos aspectos del funcionamiento de una aplicación y produce un resumen estadístico. Aunque ambos ayudan a diagnosticar problemas de aplicaciones, difieren en lo que miden y en cómo se registran los datos.

Obtén más información en este taller: [Tracing: Frontend issues with backend solutions](https://sentry.io/resources/tracing-frontend-issues-with-backend-solutions/?original_referrer=https%3A%2F%2Fblog.sentry.io%2F).

<div id="the-tracing-data-model">
  ### El modelo de datos de trazas
</div>

En última instancia, cualquier estructura de datos se define por el tipo de datos que contiene, y las relaciones entre estructuras de datos se definen por cómo se registran los vínculos entre ellas. Las trazas, transacciones y spans no son la excepción.

<div id="traces">
  #### Trazas
</div>

Una traza se define como el conjunto de todas las transacciones que comparten un mismo valor de `trace_id`.

<div id="transactions">
  #### Transacciones
</div>

Las transacciones comparten la mayoría de propiedades (hora de inicio y fin, etiquetas, etc.) con sus spans raíz. También tienen una propiedad `transaction_name`, usada en la UI para identificar la transacción. Algunos ejemplos comunes incluyen rutas de endpoints para transacciones de solicitudes de backend, nombres de tareas para transacciones de cron jobs y URLs para transacciones de carga de página.

Antes de enviar la transacción, las propiedades `tags` y `data` se combinarán con los datos del alcance global. (Los datos del alcance global se configuran en `Sentry.init()` o mediante `Sentry.configureScope()`, `Sentry.setTag()`, `Sentry.setUser()` o `Sentry.setExtra()`).

<Alert>
  Los nombres de transacción pueden contener **datos sensibles**. Consulta [Scrubbing Sensitive Data](/es/platforms/javascript/data-management/sensitive-data/#scrubbing-data) para obtener más información.
</Alert>

<div id="spans">
  #### Spans
</div>

Los datos de los spans incluyen:

* `parent_span_id`: vincula el span con su span padre
* `op`: cadena breve que identifica el tipo o la categoría de operación que el span está midiendo
* `start_timestamp`: cuándo se abrió el span
* `end_timestamp`: cuándo se cerró el span
* `description`: descripción más detallada de la operación del span
* `status`: código breve que indica el estado de la operación
* `tags`: pares clave-valor que contienen datos adicionales sobre el span
* `data`: datos adicionales con estructura arbitraria sobre el span

Un ejemplo de uso conjunto de las propiedades `op` y `description` es `op: db.query` y `description: SELECT * FROM users WHERE last_active < %s`. La propiedad `status` indica el éxito o el fracaso de la operación del span, o un código de respuesta para solicitudes HTTP. `tags` y `data` añaden información contextual adicional al span, como `function: middleware.auth.is_authenticated` para una llamada de función o `request: {url: ..., headers: ... , body: ...}` para una solicitud HTTP.
Para buscar datos de spans, consulta [Propiedades con soporte de búsqueda](/es/concepts/search/searchable-properties/spans/)

<div id="what-can-tracing-help-with">
  ### ¿En qué puede ayudar el tracing?
</div>

Las aplicaciones están formadas por componentes o servicios interconectados. Por ejemplo, una aplicación web moderna puede incluir:

* Frontend (Single-Page Application)
* Backend (REST API)
* Cola de tareas
* Servidor de bases de datos
* Planificador de cron jobs

Cada componente puede instrumentarse de forma individual con un SDK de Sentry para capturar datos de errores o informes de fallos, pero eso no ofrece la visión completa. El tracing distribuido reúne todos los datos.

El tracing distribuido te permite seguir una solicitud desde el [frontend](/es/product/sentry-basics/integrate-frontend/) hasta el [backend](/es/product/sentry-basics/integrate-backend/) y de regreso, incorporando datos de cualquier tarea en segundo plano o trabajo de notificaciones que esa solicitud genere. Esto ayuda a correlacionar los informes de errores de Sentry y a identificar qué servicios pueden afectar negativamente al rendimiento de tu aplicación.

<div id="traces-transactions-and-spans">
  ## Trazas, transacciones y spans
</div>

Una **traza** es el registro de toda la operación que quieres medir o seguir, como la carga de una página o una acción del usuario. Cuando una traza abarca trabajo en varios servicios, se denomina **traza distribuida**.

Cada traza consta de una o más estructuras en forma de árbol llamadas [**transacciones**](/es/product/insights/overview/transaction-summary/), con nodos llamados **spans**. Cada transacción representa una instancia de un servicio que se invoca y cada span representa una unidad de trabajo. Aquí tienes un ejemplo de traza, desglosada en transacciones y spans:

![Diagrama que ilustra cómo una traza se compone de múltiples transacciones, y cada transacción se compone de múltiples spans.](./img/diagram-transaction-trace.png)

Los spans de nivel superior pueden descomponerse en spans más pequeños, como cuando una función llama a otras. Cualquier span puede ser el **span padre** de múltiples **spans hijo**. En cada transacción, un span representa la transacción en sí, y todos los demás spans descienden de ese span raíz. Aquí tienes una vista ampliada de una de las transacciones del diagrama anterior:

![Diagrama que ilustra la relación padre-hijo entre spans dentro de una sola transacción.](./img/diagram-transaction-spans.png)

<div id="tracing-example-investigating-slow-page-load">
  ### Ejemplo de trazas: investigando una carga de página lenta
</div>

Supón que tu aplicación web tarda en cargar. Para que tu app llegue a un estado utilizable, tienen que ocurrir muchas cosas: múltiples solicitudes a tu backend, llamadas a tu base de datos o a APIs externas y procesamiento del navegador. ¿Qué parte está frenando todo?

En este ejemplo simplificado, cuando una persona carga la app en su navegador, sucede lo siguiente:

* *Navegador*
  * 1 solicitud para HTML, 1 para CSS y 1 para JavaScript
  * 1 tarea de renderizado, que desencadena 2 solicitudes de datos JSON
* *Backend*
  * 3 solicitudes para servir archivos estáticos (HTML, CSS, JS)
  * 2 solicitudes de datos JSON: 1 que requiere una llamada a la base de datos y 1 que requiere una llamada a una API externa y procesamiento
* *Servidor de base de datos*
  * 1 solicitud que requiere 2 consultas (autenticación y recuperación de datos)

*Nota:* La API externa no se incluye porque es externa y no puede verse desde dentro.

Todo el proceso de carga de la página está representado por una única **traza**. Esa traza consta de las siguientes **transacciones**:

* 1 transacción del navegador (para la carga de la página)
* 5 transacciones del backend (una por cada solicitud)
* 1 transacción del servidor de base de datos (para la única solicitud a la BD)

Cada transacción se descompone en **spans**:

* *Transacción de carga de página del navegador*: 7 spans
  * 1 span raíz para toda la carga de la página
  * 1 span cada uno (3 en total) para las solicitudes de HTML, CSS y JS
  * 1 span para la tarea de renderizado, que contiene 2 spans hijo para cada solicitud JSON

Algunos spans de la transacción del navegador corresponden a transacciones del backend. Cuando un span en un servicio da lugar a una transacción en otro, el span original es span padre tanto de la transacción como de su span raíz. En el diagrama de abajo, las líneas onduladas representan esta relación padre-hijo.

![Diagrama que ilustra la relación traza-transacción-span aplicada al ejemplo.](./img/diagram-transaction-example.png)

En nuestro ejemplo, cada transacción distinta de la transacción inicial de carga de página del navegador es hija de un span en otro servicio. En un sistema completamente instrumentado, este patrón siempre se cumple. El único span sin padre es la raíz de la transacción inicial; todos los demás spans tienen un padre. Padres e hijos viven en el mismo servicio, excepto cuando el span hijo es la raíz de una transacción hija, en cuyo caso el span padre vive en el servicio que llama y la transacción hija/el span raíz hijo vive en el servicio llamado.

Un sistema completamente instrumentado crea una traza que es un árbol conectado, con cada transacción como un subárbol. Los límites entre subárboles/transacciones son los límites entre servicios. El diagrama anterior muestra una rama del árbol completo de trazas de nuestro ejemplo.

Ahora, volviendo a nuestros spans:

* *Transacciones de solicitud de HTML/CSS/JS del backend*: 1 span cada una
  * 1 span raíz para toda la solicitud (hijo de un span del navegador)
* *Transacción de solicitud del backend con llamada a la BD*: 2 spans
  * 1 span raíz para toda la solicitud (hijo de un span del navegador)
  * 1 span para consultar la base de datos (padre de la transacción del servidor de base de datos)
* *Transacción de solicitud del backend con llamada a la API*: 3 spans
  * 1 span raíz para toda la solicitud (hijo de un span del navegador)
  * 1 span para la solicitud a la API (no es span padre, ya que la API es externa)
  * 1 span para procesar los datos de la API
* *Transacción de solicitud del servidor de base de datos*: 3 spans
  * 1 span raíz para toda la solicitud (hijo del span de backend anterior)
  * 1 span para la consulta de autenticación
  * 1 span para la consulta de recuperación de datos

Después de instrumentar todos los servicios, podrías descubrir que la consulta de autenticación en tu servidor de base de datos está causando la lentitud. Las trazas no pueden decirte *por qué* sucede, pero ahora sabes dónde mirar.

<div id="further-examples-of-tracing-transactions-spans">
  ### Más ejemplos de trazabilidad, transacciones y spans
</div>

<div id="measuring-a-specific-user-action">
  #### Medir una acción específica del usuario
</div>

Para una aplicación de comercio electrónico, podrías medir el tiempo entre que un usuario hace clic en &quot;Submit Order&quot; y aparece la confirmación del pedido. Este proceso es un trazo, con transacciones (*T*) y spans (*S*) para:

* Proceso completo del navegador (*T* y span raíz *S*)
  * Solicitud XHR al backend* (*S*)
  * Renderizado de la pantalla de confirmación (*S*)
* Procesamiento de la solicitud en el backend (*T* y span raíz *S*)
  * Llamada de función para calcular el total (*S*)
  * Llamada a la BD para almacenar el pedido* (*S*)
  * Llamada a la API del procesador de pagos (*S*)
  * Encolado de la confirmación por correo electrónico* (*S*)
* Trabajo de la base de datos al actualizar el historial de pedidos del cliente (*T* y span raíz *S*)
  * Consultas SQL individuales (*S*)
* Tarea en cola de envío del correo electrónico (*T* y span raíz *S*)
  * Llamada de función para completar la plantilla de correo (*S*)
  * Llamada a la API del servicio de envío de correos (*S*)

* Los spans marcados con estrella son padres de transacciones posteriores (y sus spans raíz).

<div id="monitoring-a-background-process">
  #### Supervisión de un proceso en segundo plano
</div>

Para un backend que, de forma periódica, consulta datos de un servicio externo, los procesa, los almacena en caché y los reenvía a un servicio interno, cada instancia es un trace, con transacciones (*T*) y spans (*S*) para:

* Tarea cron que completa todo el proceso (*T* y span raíz *S*)
  * Llamada a la API del servicio externo (*S*)
  * Función de procesamiento (*S*)
  * Llamada al servicio de caché* (*S*)
  * Llamada a la API del servicio interno* (*S*)
* Trabajo realizado en tu servicio de caché (*T* y span raíz *S*)
  * Comprobación de la caché para datos existentes (*S*)
  * Almacenamiento de nuevos datos en la caché (*S*)
* Procesamiento de la solicitud por parte del servicio interno (*T* y span raíz *S*)
  * Gestión de la solicitud (*S*)

* Los spans marcados con asterisco son padres de transacciones posteriores (y de sus spans raíz).

<div id="important-information-about-tracing-spans-transactions">
  ### Información importante sobre trazas, spans y transacciones
</div>

<div id="trace-duration">
  #### Duración de una traza
</div>

Una traza comienza cuando se inicia la transacción más temprana y termina cuando finaliza la última. No puedes “iniciar” ni “finalizar” una traza, pero puedes iniciar una transacción que la active. Completar todas las transacciones da por terminada la traza.

<div id="async-transactions">
  #### Transacciones asíncronas
</div>

Las transacciones secundarias pueden extenderse más allá de las transacciones que contienen sus spans padre. Por ejemplo, si una llamada a una API de backend inicia una tarea de larga duración y luego devuelve inmediatamente una respuesta, la transacción de backend terminará mucho antes que la transacción de la tarea asíncrona. La asincronía implica que el orden en que se envían las transacciones a Sentry no dependerá del orden en que se crearon. Sin embargo, el orden de recepción de las transacciones dentro de la misma traza está correlacionado con su orden de finalización.

<div id="orphan-transactions">
  #### Transacciones huérfanas
</div>

En un sistema totalmente instrumentado, cada traza debería contener solo una transacción y un span (la raíz de la transacción) sin padre. Sin embargo, puede que no tengas el rastreo habilitado en todos los servicios, o que un servicio instrumentado no llegue a informar una transacción. Esto puede generar huecos en tu jerarquía de trazas, con transacciones no originadas y sin padre, llamadas **transacciones huérfanas**.

<div id="nested-spans">
  #### Spans anidados
</div>

No hay un límite definido para la profundidad de la anidación de spans, pero sí hay límites prácticos: las cargas de transacciones enviadas a Sentry tienen un tamaño máximo permitido y hay que equilibrar la granularidad de los datos con la facilidad de uso.

<div id="zero-duration-spans">
  #### Spans de duración cero
</div>

Un span puede tener tiempos de inicio y fin iguales, lo que se registrará como una duración de cero. Esto puede ocurrir si el span se usa como marcador, por ejemplo, en la [API de rendimiento](https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark) del navegador, o si la duración de la operación es menor que la resolución de medición (que variará según el servicio).

<div id="clock-skew">
  #### Desfase de reloj
</div>

Recopilar transacciones de varias máquinas puede provocar **desfase de reloj**, donde las marcas de tiempo de una transacción no coinciden con las de otra. Para mitigarlo, usa el Protocolo de Tiempo de Red (NTP) o los servicios de sincronización de reloj de tu proveedor de la nube.

<div id="how-data-is-sent">
  #### Cómo se envían los datos
</div>

Los spans individuales no se envían a Sentry; toda la transacción se envía como una sola unidad. Los servidores de Sentry no registran ningún dato de spans hasta que la transacción se cierra y se envía. Las transacciones siguen siendo válidas y se envían incluso si solo contienen su span raíz.

<div id="data-sampling">
  ## Muestreo de datos
</div>

Cuando activas el muestreo, eliges un porcentaje de las transacciones recopiladas para enviar a Sentry. Por ejemplo, una tasa de muestreo de `0.25` en un endpoint que recibe 1000 solicitudes por minuto resulta en que se envíen aproximadamente 250 transacciones a Sentry cada minuto. El muestreo ayuda a gestionar la cantidad de eventos enviados a Sentry y equilibra las necesidades de rendimiento y volumen con la precisión de los datos.

<div id="consistency-within-a-trace">
  ### Consistencia dentro de una traza
</div>

Sentry utiliza un enfoque &quot;basado en la cabecera&quot;: la decisión de muestreo se toma en el servicio de origen y se transmite a los servicios posteriores. Por ejemplo, si un navegador hace solicitudes a tu backend, incluye la decisión de muestreo en las cabeceras. El backend recopila datos de transacciones y spans si la decisión es &quot;sí&quot; y transmite la decisión a los servicios posteriores. Esto garantiza que se recopilen todas las transacciones de una traza determinada o ninguna.

<Alert level="warning">
  El muestreo dinámico garantiza trazas completas al retener todas las transacciones asociadas a una traza si se conserva la transacción inicial. Sin embargo, pueden seguir faltando transacciones u otros elementos de una traza cuando el rate limiting o la aplicación de cuotas los descarta.
</Alert>

<div id="viewing-trace-data">
  ## Visualización de datos de trazas
</div>

Usa el [Trace Explorer](/es/product/explore/traces/) para buscar trazas que contengan spans que cumplan tus condiciones de consulta específicas. Esto te ayuda a encontrar trazas distribuidas que te ofrecen una vista conectada de tu aplicación y puede ayudarte a depurar y optimizar tu código.

A través de [Performance](/es/product/insights/overview/) y [Discover](/es/product/explore/discover-queries/), también puedes ver datos de trazas en la página [Trace View](/es/concepts/key-terms/tracing/trace-view/).
---
title: OkHttp
caseStyle: camelCase
supportLevel: production
sdk: sentry.java.okhttp
description: "Más información sobre la integración de Sentry con OkHttp para el SDK de Android."
categories:
  - mobile
---

La biblioteca `sentry-okhttp` ofrece compatibilidad con [OkHttp](https://github.com/square/okhttp) para Sentry mediante el [Interceptor de OkHttp](https://github.com/square/okhttp/blob/a2059dedc0b1d4a977480834ae4ed9ea576a3eb8/okhttp/src/main/kotlin/okhttp3/Interceptor.kt).

En esta página te ayudamos a empezar con la integración de OkHttp de Sentry, para que agregue automáticamente un breadcrumb y cree un span a partir del span activo vinculado al scope en cada solicitud HTTP.

<Alert>
  La versión mínima compatible de `okhttp` es `3.13.0` debido a sus [incompatibilidades](https://medium.com/square-corner-blog/okhttp-3-13-requires-android-5-818bb78d07ce) con versiones de Android anteriores a 5.0. No obstante, puedes adaptar nuestro [SentryOkHttpInterceptor](https://github.com/getsentry/sentry-java/blob/main/sentry-okhttp/src/main/java/io/sentry/okhttp/SentryOkHttpInterceptor.kt) si usas una versión de `okhttp` anterior.
</Alert>

<div id="auto-installation-with-the-sentry-android-gradle-plugin">
  ## Instalación automática con el plugin de Sentry para Android Gradle
</div>

A partir de la versión `3.1.0`, el plugin de Sentry para Android Gradle agregará automáticamente la dependencia `sentry-okhttp` e instrumentará todas tus instancias de `OkHttpClient` mediante manipulación de bytecode. El plugin solo agregará la dependencia `sentry-okhttp` si se detecta una dependencia de `okhttp` en el classpath.
A partir de la versión `3.11.0`, el plugin de Sentry para Android Gradle también agregará automáticamente `SentryOkHttpEventListener` a tus instancias de `OkHttpClient` mediante manipulación de bytecode.

<div id="install">
  ### Instalación
</div>

Añade el complemento de Gradle de Sentry para Android en `build.gradle`:

```groovy
plugins {
  id "io.sentry.android.gradle" version "{{@inject packages.version('sentry.java.android.gradle-plugin', '3.0.0') }}"
}
```

```kotlin
plugins {
  id("io.sentry.android.gradle") version "{{@inject packages.version('sentry.java.android.gradle-plugin', '3.0.0') }}"
}
```

Luego, configura el [SDK de Android](/es/platforms/android/#configure).

<div id="disable">
  ### Desactivar
</div>

Si quieres desactivar la instrumentación de OkHttp, dispones de una opción de configuración para hacerlo:

```groovy
import io.sentry.android.gradle.extensions.InstrumentationFeature

sentry {
  tracingInstrumentation {
    enabled = true
    features = EnumSet.allOf(InstrumentationFeature) - InstrumentationFeature.OKHTTP
  }
}
```

```kotlin
import java.util.EnumSet
import io.sentry.android.gradle.extensions.InstrumentationFeature

sentry {
  tracingInstrumentation {
    enabled.set(true)
    features.set(EnumSet.allOf(InstrumentationFeature::class.java) - InstrumentationFeature.OKHTTP)
  }
}
```

<Alert>
  Obtén más información sobre el complemento Sentry para Android Gradle en nuestra documentación de [Gradle](/es/platforms/android/configuration/gradle/).
</Alert>

<div id="manual-installation">
  ## Instalación manual
</div>

<div id="install">
  ### Instalación
</div>

Sentry captura datos añadiendo un `OkHttp Interceptor` y un `OkHttp EventListener`. Para añadir la integración de OkHttp, primero inicializa el [SDK de Android](/es/platforms/android/) y luego agrega la dependencia `sentry-okhttp` con Gradle:

```groovy
implementation 'io.sentry:sentry-android:{{@inject packages.version('sentry.java.android', '5.0.0') }}'
implementation 'io.sentry:sentry-okhttp:{{@inject packages.version('sentry.java.okhttp', '5.0.0') }}'
```

<div id="configure">
  ### Configuración
</div>

<Alert>
  SentryOkHttpEventListener está disponible a partir de la versión `6.20.0` del SDK de Android de Sentry.
</Alert>

La configuración debe realizarse al crear tu instancia de `OkHttpClient`.

```kotlin
import okhttp3.OkHttpClient
import io.sentry.okhttp.SentryOkHttpEventListener
import io.sentry.okhttp.SentryOkHttpInterceptor

private val client = OkHttpClient.Builder()
  .addInterceptor(SentryOkHttpInterceptor())
  .eventListener(SentryOkHttpEventListener())
  .build()
```

```java
import okhttp3.OkHttpClient;
import io.sentry.okhttp.SentryOkHttpEventListener;
import io.sentry.okhttp.SentryOkHttpInterceptor;

private final OkHttpClient client = new OkHttpClient.Builder()
  .addInterceptor(new SentryOkHttpInterceptor())
  .eventListener(new SentryOkHttpEventListener())
  .build();
```

El SDK utiliza `SentryOkHttpInterceptor` para admitir el [trazado distribuido](/es/product/sentry-basics/tracing/distributed-tracing/) y crea un span para cualquier llamada HTTP.
El SDK puede ofrecer información más detallada mediante `SentryOkHttpEventListener`, creando un span para cada operación reportada por OkHttp, incluidas: configuración de DNS, selección de proxy, conexión HTTP, configuración de SSL, envío de encabezados de solicitud, envío del cuerpo de la solicitud, recepción de encabezados de respuesta y recepción del cuerpo de la respuesta.

<div id="verify">
  ## Verificar
</div>

Este fragmento incluye una solicitud HTTP y captura un mensaje intencional, para que puedas comprobar que todo funciona en cuanto lo configures:

```kotlin
import io.sentry.okhttp.SentryOkHttpEventListener
import io.sentry.okhttp.SentryOkHttpInterceptor
import io.sentry.Sentry
import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.Request

@Throws(IOException::class)
fun run(url: String): String? {
  val request = Request.Builder()
    .url(url)
    .build()

  val bodyStr = client
    .newCall(request)
    .execute()
    .body?.toString()

  Sentry.captureMessage("Mensaje: $bodyStr")

  return bodyStr
}
```

```java
import io.sentry.okhttp.SentryOkHttpEventListener
import io.sentry.okhttp.SentryOkHttpInterceptor;
import io.sentry.Sentry
import java.io.IOException;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.ResponseBody;

String run(String url) throws IOException {
  Request request = new Request.Builder()
    .url(url)
    .build();

  ResponseBody body = client
    .newCall(request)
    .execute()
    .body();

  String bodyStr = body != null ? body.toString() : null;

  Sentry.captureMessage("Mensaje: " + bodyStr);

  return bodyStr;
}
```

<Alert>
  Obtén más información sobre cómo capturar manualmente un error o un mensaje en nuestra <PlatformLink to="/usage/">documentación de uso</PlatformLink>.
</Alert>

Para ver y resolver el mensaje registrado, inicia sesión en [sentry.io](https://sentry.io) y abre tu proyecto. Al hacer clic en el título del error, se abrirá una página donde podrás ver información detallada y marcarlo como resuelto.

<div id="customize-the-recorded-span">
  ## Personalizar el tramo registrado
</div>

El tramo capturado puede personalizarse o descartarse con un `BeforeSpanCallback`:

```kotlin
import io.sentry.ISpan
import io.sentry.okhttp.SentryOkHttpInterceptor
import okhttp3.Request
import okhttp3.Response

class CustomBeforeSpanCallback : SentryOkHttpInterceptor.BeforeSpanCallback {
  override fun execute(span: ISpan, request: Request, response: Response?): ISpan? {
    return if (request.url.toUri().toString().contains("/admin")) {
      null
    } else {
      span
    }
  }
}
```

```java
import io.sentry.ISpan;
import io.sentry.okhttp.SentryOkHttpInterceptor;
import okhttp3.Request;
import okhttp3.Response;

class CustomBeforeSpanCallback implements SentryOkHttpInterceptor.BeforeSpanCallback {
  public ISpan execute(ISpan span, Request request, Response response) {
    if (request.getUrl().toUri().toString().contains("/admin")) {
      return null;
    } else {
      return span;
    }
  }
}
```

Debes establecer la instancia del callback en `SentryOkHttpInterceptor` después de crear tu instancia de `OkHttpClient`.

```kotlin
import okhttp3.OkHttpClient
import io.sentry.okhttp.SentryOkHttpEventListener
import io.sentry.okhttp.SentryOkHttpInterceptor

private val client = OkHttpClient.Builder()
  .eventListener(SentryOkHttpEventListener())
  .addInterceptor(SentryOkHttpInterceptor(CustomBeforeSpanCallback()))
  .build()
```

```java
import okhttp3.OkHttpClient;
import io.sentry.okhttp.SentryOkHttpEventListener;
import io.sentry.okhttp.SentryOkHttpInterceptor;

private final OkHttpClient client = new OkHttpClient.Builder()
  .eventListener(new SentryOkHttpEventListener())
  .addInterceptor(new SentryOkHttpInterceptor(new CustomBeforeSpanCallback()))
  .build();
```

<div id="using-multiple-event-listeners">
  ## Uso de múltiples listeners de eventos
</div>

El listener de eventos puede propagar llamadas a otro `EventListener` o `EventListener.Factory` configurado en `SentryOkHttpEventListener` una vez que creas tu instancia de `OkHttpClient`.

```kotlin
import okhttp3.OkHttpClient
import io.sentry.okhttp.SentryOkHttpEventListener
import io.sentry.okhttp.SentryOkHttpInterceptor

private val client = OkHttpClient.Builder()
  .eventListener(SentryOkHttpEventListener(MyEventListener()))
  .addInterceptor(SentryOkHttpInterceptor(CustomBeforeSpanCallback()))
  .build()
```

```java
import okhttp3.OkHttpClient;
import io.sentry.okhttp.SentryOkHttpEventListener;
import io.sentry.okhttp.SentryOkHttpInterceptor;

private final OkHttpClient client = new OkHttpClient.Builder()
  .eventListener(new SentryOkHttpEventListener(new MyEventListener()))
  .addInterceptor(new SentryOkHttpInterceptor(new CustomBeforeSpanCallback()))
  .build();
```

<div id="http-client-errors">
  ## Errores del cliente HTTP
</div>

Esta función captura automáticamente los errores del cliente HTTP (como códigos de respuesta no válidos) como eventos de error y los envía a Sentry. El evento de error incluirá los datos de `request` y `response`, como la `url`, el `status_code`, y demás.

A partir de la versión `7.0.0` del SDK, la captura de errores del cliente HTTP está habilitada de forma predeterminada. En versiones anteriores del SDK, esta función es opcional y puede habilitarse configurando la opción `captureFailedRequests` en `true`:

```kotlin
import okhttp3.OkHttpClient
import io.sentry.okhttp.SentryOkHttpEventListener
import io.sentry.okhttp.SentryOkHttpInterceptor

private val client = OkHttpClient.Builder()
  .eventListener(SentryOkHttpEventListener())
  .addInterceptor(SentryOkHttpInterceptor(captureFailedRequests = true))
  .build()
```

```java
import okhttp3.OkHttpClient;
import io.sentry.HttpStatusCodeRange;
import io.sentry.Sentry;
import io.sentry.okhttp.SentryOkHttpEventListener;
import io.sentry.okhttp.SentryOkHttpInterceptor;
import java.util.Collections;

private final List<HttpStatusCodeRange> codeRanges = Collections.singletonList(new HttpStatusCodeRange(HttpStatusCodeRange.DEFAULT_MIN, HttpStatusCodeRange.DEFAULT_MAX));
private final List<String> failedRequestTargets = Collections.singletonList(".*");
private final OkHttpClient client = new OkHttpClient.Builder()
  .eventListener(new SentryOkHttpEventListener())
  .addInterceptor(new SentryOkHttpInterceptor(
    Sentry.getCurrentHub(),
    null,
    true,
    codeRanges,
    failedRequestTargets
  ))
  .build();
```

De forma predeterminada, solo se registran como eventos de error las respuestas HTTP con códigos entre `500` y `599`, pero puedes modificar este comportamiento configurando la opción `failedRequestStatusCodes`:

```kotlin
import okhttp3.OkHttpClient
import io.sentry.okhttp.SentryOkHttpEventListener
import io.sentry.okhttp.SentryOkHttpInterceptor
import io.sentry.HttpStatusCodeRange

private val client = OkHttpClient.Builder()
  .eventListener(SentryOkHttpEventListener())
  .addInterceptor(SentryOkHttpInterceptor(
    captureFailedRequests = true,
    failedRequestStatusCodes = listOf(HttpStatusCodeRange(400, 599))))
  .build()
```

```java
import okhttp3.OkHttpClient;
import io.sentry.HttpStatusCodeRange;
import io.sentry.Sentry;
import io.sentry.okhttp.SentryOkHttpEventListener;
import io.sentry.okhttp.SentryOkHttpInterceptor;
import java.util.Collections;

private final List<HttpStatusCodeRange> codeRanges = Collections.singletonList(new HttpStatusCodeRange(400, 599));
private final List<String> failedRequestTargets = Collections.singletonList(".*");
private final OkHttpClient client = new OkHttpClient.Builder()
  .eventListener(new SentryOkHttpEventListener())
  .addInterceptor(new SentryOkHttpInterceptor(
    Sentry.getCurrentHub(),
    null,
    true,
    codeRanges,
    failedRequestTargets
  ))
  .build();
```

Los errores de cliente HTTP de todos los destinos (expresión regular `.*`) se capturan automáticamente, pero puedes cambiar este comportamiento configurando la opción `failedRequestTargets` con una expresión regular o con una cadena (`String`) simple. Una cadena simple debe contener al menos uno de los elementos de la lista. Las cadenas simples no tienen que ser coincidencias exactas; es decir, la URL de una solicitud coincide cuando contiene una cadena proporcionada mediante la opción.

```kotlin
import okhttp3.OkHttpClient
import io.sentry.okhttp.SentryOkHttpEventListener
import io.sentry.okhttp.SentryOkHttpInterceptor
import io.sentry.HttpStatusCodeRange

private val client = OkHttpClient.Builder()
  .eventListener(SentryOkHttpEventListener())
  .addInterceptor(SentryOkHttpInterceptor(
    captureFailedRequests = true,
    failedRequestTargets = listOf("myapi.com")))
  .build()
```

```java
import okhttp3.OkHttpClient;
import io.sentry.HttpStatusCodeRange;
import io.sentry.Sentry;
import io.sentry.okhttp.SentryOkHttpEventListener;
import io.sentry.okhttp.SentryOkHttpInterceptor;
import java.util.Collections;

private final List<HttpStatusCodeRange> codeRanges = Collections.singletonList(new HttpStatusCodeRange(HttpStatusCodeRange.DEFAULT_MIN, HttpStatusCodeRange.DEFAULT_MAX));
private final List<String> failedRequestTargets = Collections.singletonList("myapi.com");
private final OkHttpClient client = new OkHttpClient.Builder()
  .eventListener(new SentryOkHttpEventListener())
  .addInterceptor(new SentryOkHttpInterceptor(
    Sentry.getCurrentHub(),
    null,
    true,
    codeRanges,
    failedRequestTargets
  ))
  .build();
```

De forma predeterminada, los eventos de error no incluirán ningún dato de PII, como `Headers` y `Cookies`. Puedes cambiar este comportamiento configurando la opción `sendDefaultPii` en `true`:

```xml {filename:AndroidManifest.xml}
<application>
  <meta-data android:name="io.sentry.send-default-pii" android:value="true" />
</application>
```

Esos eventos son buscables y puedes configurar alertas para ellos si usas las propiedades `http.url` y `http.status_code`. Obtén más información en nuestra documentación completa sobre [Propiedades buscables](/es/concepts/search/searchable-properties/).

<div id="customize-or-drop-the-error-event">
  ### Personalizar o descartar el evento de error
</div>

Para personalizar o descartar el evento de error, debes realizar una [inicialización manual](/es/platforms/android/configuration/manual-init/#manual-initialization) del SDK de Sentry para Android.

El evento de error capturado puede personalizarse o descartarse con un `BeforeSendCallback`:

```kotlin
import io.sentry.android.core.SentryAndroid
import io.sentry.SentryOptions.BeforeSendCallback
import io.sentry.TypeCheckHint.OKHTTP_REQUEST
import io.sentry.TypeCheckHint.OKHTTP_RESPONSE
import okhttp3.Request
import okhttp3.Response

SentryAndroid.init(this) { options ->
  // Agrega un callback que se ejecutará antes de enviar el evento a Sentry.
  // Con este callback, puedes modificar el evento o descartarlo devolviendo null.
  options.beforeSend = BeforeSendCallback { event, hint ->
    val request = hint.getAs(OKHTTP_REQUEST, Request::class.java)
    val response = hint.getAs(OKHTTP_RESPONSE, Response::class.java)

    // personaliza o descarta el evento
    event
  }
}
```

```java
import io.sentry.android.core.SentryAndroid
import io.sentry.TypeCheckHint.OKHTTP_REQUEST
import io.sentry.TypeCheckHint.OKHTTP_RESPONSE
import okhttp3.Request
import okhttp3.Response

SentryAndroid.init(this, (options) -> {
  // Agrega un callback que se usará antes de enviar el evento a Sentry.
  // Con este callback, puedes modificar el evento o, si devuelves null, descartarlo.
  options.setBeforeSend((event, hint) -> {
    Request request = hint.getAs(OKHTTP_REQUEST, Request.class);
    Response response = hint.getAs(OKHTTP_RESPONSE, Response.class);

    // personaliza o descarta el evento
    return event;
  });
});
```

<div id="automatically-captured-http-client-errors-and-manually-captured-errors">
  ### Errores del cliente HTTP capturados automáticamente y errores capturados manualmente
</div>

Cuando `captureFailedRequests` está habilitado, algunas bibliotecas de cliente HTTP arrojan excepciones no comprobadas, como `retrofit2.HttpException`. En ese caso, el evento de error se captura dos veces: una por la biblioteca de cliente HTTP y otra por el SDK de Sentry para Android:

```kotlin
import io.sentry.Sentry
import retrofit2.HttpException

try {
  // Si esta llamada a la API devuelve 500, el `SentryOkHttpInterceptor` la registrará como un evento de error.
  return GitHubAPI.service.listReposAsync("getsentry")
} catch (e: HttpException) {
  // No captures esta excepción manualmente para evitar eventos de error duplicados.
  // Sentry.captureException(e)
}
```

```java
import io.sentry.Sentry
import retrofit2.HttpException

try {
  // Si esta llamada a la API devuelve un 500, `SentryOkHttpInterceptor` lo registrará como un evento de error.
  return GitHubAPI.getService().listReposAsync("getsentry");
} catch (HttpException e) {
  // No captures esta excepción de forma manual para evitar eventos de error duplicados.
  // Sentry.captureException(e)
}
```

Recomendamos identificar esos errores y **no** capturarlos manualmente con el método `Sentry.captureException`.

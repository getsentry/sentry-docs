---
title: "Depurar formatos de archivo"
description: "Conoce los formatos de archivo específicos de cada plataforma y la información de depuración que contienen."
sidebar_order: 1
---

Sentry distingue cuatro tipos de información de depuración:

* **Información de depuración:** Proporciona nombres de funciones, rutas a archivos fuente, números de línea y frames en línea. El proceso de resolver esta información a partir de direcciones de instrucción se llama “symbolication”. Esta información es relativamente grande en comparación con el ejecutable y, por lo general, se coloca en un archivo aparte. En Sentry, estos archivos se denominan *debug companions* y muestran la etiqueta `debug`.

* **Tablas de símbolos:** Si no hay información de depuración disponible para una biblioteca determinada, Sentry puede usar tablas de símbolos como alternativa para recuperar nombres de funciones. Las tablas de símbolos suelen incluirse tanto en el ejecutable como en los archivos de acompañamiento de depuración. Sin embargo, no contienen información suficiente para resolver funciones en línea ni nombres de archivo y números de línea. La etiqueta `symtab` indica tablas de símbolos.

* **Código fuente:** Por convención, el código fuente no forma parte de los archivos habituales de información de depuración. Sentry CLI puede empaquetar el código fuente de tu aplicación y subirlo para mostrar el contexto de código en los stack traces en Sentry. Estos paquetes aparecen con la etiqueta `sources`.

* **Información de desenrollado:** Permite a Sentry extraer stack traces de Minidumps y otros formatos binarios de fallos en compilaciones optimizadas. Este proceso se conoce como “stack unwinding” o “stack walking”. Como esto también se requiere al lanzar excepciones en C++, esta información suele incluirse en el ejecutable o la biblioteca. Si un archivo subido contiene esta información, muestra la etiqueta `unwind`. Ten en cuenta que en algunas plataformas no se realiza un desenrollado real. Por ejemplo, WebAssembly actualmente no tiene el equivalente de minidumps, lo que significa que no se requiere ese tipo de información en esos casos.

Los compiladores colocan la información de depuración anterior en diferentes archivos según la plataforma de destino, la arquitectura, las flags de compilación o el nivel de optimización. En consecuencia, Sentry podría no necesitar toda la información anterior para procesar informes de fallos. Aun así, siempre es buena idea proporcionar toda la información de depuración disponible.

`sentry-cli` se puede usar para listar propiedades de los archivos de depuración compatibles y validar su contenido. Consulta [*Archivos de información de depuración en sentry-cli*](/es/cli/dif/) para obtener más información.

<div id="mach-o-and-dsym">
  ## Mach-O y dSYM
</div>

Los ejecutables, las bibliotecas dinámicas y los compañeros de depuración en todas las plataformas de Apple usan el formato contenedor *Mach Object*, o *Mach-O* para abreviar. Esto aplica a iOS, iPadOS, tvOS, watchOS, macOS y visionOS.

* **Los ejecutables** no llevan extensión de archivo. En aplicaciones de escritorio, a menudo se colocan en estructuras de paquetes de apps con el sufijo `.app`. A menos que se elimine manualmente, los ejecutables contienen información de desenrollado (unwind) y una tabla de símbolos. La información de depuración nunca se almacena en los ejecutables.

* **Las bibliotecas dinámicas** usan la extensión `.dylib` y, por lo demás, se comportan exactamente igual que los ejecutables.

* **Los compañeros de depuración** se colocan en una estructura de carpetas con la extensión `.dSYM` y se encuentran en `<name>.dSYM/Contents/Resources/DWARF/<name>`. Suelen contener una tabla de símbolos e información de depuración, pero rara vez información de desenrollado.

Al compilar una aplicación con Xcode o con el compilador `clang`, la información de depuración se coloca automáticamente en un archivo dSYM. Sin embargo, al enlazar manualmente, el archivo dSYM debe crearse con el siguiente comando:

```bash
dsymutil /ruta/a/salida[.dylib]
```

<div id="executable-and-linkable-format-elf">
  ## Formato Ejecutable y Enlazable (ELF)
</div>

En las distribuciones de Linux, los ejecutables y la información de depuración se almacenan en contenedores *ELF*. A diferencia de otras plataformas, no existe un contenedor ni un especificador específico para archivos de depuración acompañantes.

La información de depuración forma parte del binario (ejecutable o biblioteca) y se elimina al generar compilaciones de producción debido a su tamaño. No obstante, es posible conservarla en un archivo aparte (ya sea en otra ubicación o con la extensión `.debug`):

```bash
# Hay un ejecutable llamado "binary" en el CWD
objcopy --only-keep-debug binary binary.debug
objcopy --strip-debug --strip-unneeded binary
objcopy --add-gnu-debuglink=binary.debug binary
```

Esto da como resultado la siguiente estructura:

* **Ejecutables** no llevan extensión de archivo. Si se les aplica stripping como arriba,
  los ejecutables contienen una tabla de símbolos, pero no información de depuración. Si en la
  compilación se omiten los frame pointers, también se conservará la información de unwinding. Ambas pueden
  eliminarse aún más usando flags como `--strip-all`.

* **Bibliotecas compartidas** usan la extensión `.so` y, por lo demás, se comportan exactamente
  igual que los ejecutables.

* **Archivos de depuración** no llevan una extensión de archivo estándar, pero a menudo
  se llaman `.debug`. Si se les aplica stripping como arriba, estos archivos contienen información de
  unwinding, información de depuración y una tabla de símbolos.

Las bibliotecas compartidas instaladas mediante gestores de paquetes normalmente proporcionan su información de
depuración en paquetes `*-dev` separados y la colocan en ubicaciones como
`/usr/local/debug/...`. Para recibir trazas de pila simbolizadas de esas
bibliotecas, asegúrate de subir también sus símbolos además de los símbolos de tu app.

ELF admite la compresión de la información de depuración, lo que puede reducir significativamente
el tiempo necesario para subir los archivos de información de depuración a Sentry y así mejorar
los tiempos de compilación. `gcc` (versión 5 o posterior) y `clang` (versión 5 o posterior) lo admiten
pasando la flag `-gz` tanto al compilador como al enlazador. La forma habitual
de comprimir la información de depuración, sin embargo, es al aplicar stripping al ejecutable:

```bash
# Nota: la opción --compress-debug-sections
objcopy --only-keep-debug --compress-debug-sections=zlib binary binary.debug
```

Esto puede verificarse buscando el indicador `C` en `readelf`, que corresponde a
`SHF_COMPRESSED`:

```bash
readelf -S ruta/al/archivo
  ...
  [21] .debug_info       PROGBITS         0000000000000000  00000370
       000000000000e133  0000000000000000   C       0     0     1
```

<div id="pe-and-pdb">
  ## PE y PDB
</div>

Los ejecutables y las bibliotecas dinámicas en Microsoft Windows, y los creados por la
plataforma .NET en todos los sistemas operativos, usan el formato de contenedor *Portable Executable* (*PE*).
La información de depuración asociada se almacena en archivos *Program Database*
(*PDB*).

* Los **ejecutables** usan la extensión de archivo `.exe`. Solo cuando se compilan para arquitecturas de 64 bits
  incluyen información de desenrollado. De lo contrario, no contienen
  información utilizable y se omitirán al cargarla en Sentry.

* Las **bibliotecas dinámicas** usan la extensión `.dll` y, por lo demás, se comportan
  exactamente igual que los ejecutables.

* Los **archivos de depuración asociados** se almacenan en archivos `.pdb`. Por lo general, incluyen información de depuración
  y, en la mayoría de los casos, tablas de símbolos. En los programas de 32 bits, también
  incluyen información de desenrollado. En casos poco frecuentes, podrían tener nombres de archivo distintos de los de su ejecutable correspondiente.

* La plataforma .NET usa una variación de este formato, llamada [Portable PDBs](https://github.com/dotnet/core/blob/main/Documentation/diagnostics/portable_pdb.md).
  Las Portable PDBs son compatibles a partir de Sentry 22.11.0 (o Sentry CLI 2.8.0, o Symbolic 10.0.0).

<div id="breakpad-symbols">
  ## Símbolos de Breakpad
</div>

La biblioteca Google Breakpad ha establecido un formato ASCII independiente de la plataforma
para almacenar información de depuración. Estos archivos suelen generarse para aplicaciones
que usan Breakpad, Crashpad o el framework Electron.

El repositorio de Breakpad incluye la herramienta `dump_syms` para cada plataforma, que puede
convertir archivos de depuración nativos en símbolos de Breakpad. Estos conversores agrupan toda
la información disponible en un único archivo, de modo que solo sea necesario subir un archivo.

A diferencia de los archivos de depuración nativos, los símbolos de Breakpad descartan mucha información
que no se requiere para procesar minidumps. En particular, no se declaran las funciones inline, por lo que Sentry no puede mostrar marcos inline en los rastreos de pila.

<div id="wasm">
  ## WASM
</div>

Para WebAssembly, admitimos [DWARF en contenedores WASM](https://yurydelendik.github.io/webassembly-dwarf/).
Ten en cuenta que no admitimos los source maps, que también son un formato usado para la depuración de WASM, pero que tienen limitaciones que los vuelven poco prácticos para una herramienta de informes de fallos como Sentry.

[WebAssembly admite IDs de compilación](https://github.com/WebAssembly/tool-conventions/blob/main/BuildId.md) como una
[sección personalizada](https://webassembly.github.io/spec/core/binary/modules.html#custom-section). Esta sección
es compatible con `LLVM` [desde la versión 17](https://github.com/llvm/llvm-project/commit/c7af9ae577bb04c5fe120fc07844a500818c8f47) (y, con ello, la cadena de herramientas correspondiente de `emscripten`).

Además, proporcionamos una herramienta llamada [wasm-split](https://github.com/getsentry/symbolicator/blob/master/crates/wasm-split) para añadir IDs de compilación y dividir archivos,
que te ayuda a crear un archivo de depuración complementario listo para subir a Sentry,
mientras se elimina toda la información de depuración del binario de la versión.

<div id="proguard-mappings">
  ## Mapas de ProGuard
</div>

<Alert>
  El método recomendado para [usuarios de Android es usar el complemento de Gradle](/es/platforms/android/configuration/gradle/).
</Alert>

Los archivos de mapas de ProGuard permiten que Sentry convierta rutas de clases y nombres de métodos de Java ofuscados a su forma original. En ese sentido, actúan como archivos de información de depuración para aplicaciones de Java y Android.
---
title: Identificadores de depuración
description: "Conoce los requisitos de las herramientas de compilación que permiten a Sentry identificar de forma única los archivos de información de depuración entre compilaciones."
sidebar_order: 2
---

Cada archivo de información de depuración especifica un identificador único. Los informes de fallos declaran
estos identificadores para permitir que los depuradores y los sistemas de informes de fallos resuelvan los
archivos correctos. Sentry distingue dos tipos de identificadores:

* **Identificador de código**: El identificador único del ejecutable o de la biblioteca
  dinámica —es decir, el archivo de código—. El contenido de este identificador depende
  de la plataforma: los archivos Mach-O usan un UUID, los archivos ELF usan un hash SHA y los archivos PE
  usan una concatenación de ciertos atributos del encabezado. Para WebAssembly usamos un
  UUID incrustado en la sección `build_id` del archivo.

* **Identificador de depuración**: El identificador único del archivo de depuración asociado. A
  diferencia del identificador de código, Sentry impone la misma estructura en todas las
  plataformas. En Windows, este es el identificador único real del archivo PDB; en todas
  las demás plataformas, es una transformación con pérdida del identificador de código.

Al subir archivos de información de depuración a Sentry, la CLI y el servidor siempre
calcularán un *Identificador de depuración* para cada archivo subido. Este identificador se
asocia con ejecutables y bibliotecas, así como con sus archivos de depuración, para garantizar
que puedan ubicarse de forma única mediante un mecanismo común.

<Alert>
  La información de depuración no tiene que estar asociada a versiones. El identificador de depuración
  único garantiza que Sentry pueda elegir los archivos correctos para cada informe
  de fallo. Sin embargo, sigue siendo recomendable configurar versiones en el cliente para
  aprovechar otras funciones.
</Alert>

Para eventos nativos, la página de detalles de la incidencia muestra una lista de *Imágenes cargadas*.
Esta lista contiene el ejecutable y todas las bibliotecas dinámicas cargadas, incluidos
sus identificadores de depuración. Puedes copiar este identificador y buscar los archivos exactos
que coincidan con él en la pantalla de configuración de *Archivos de depuración*.

`sentry-cli` puede ayudar a mostrar propiedades de los archivos de información de depuración, como su
identificador de depuración. Consulta [*Comprobación de archivos de información de depuración*](/es/cli/dif/#checking-files) para obtener más información.

<div id="gnu-build-identifiers">
  ## Identificadores de compilación GNU
</div>

Para archivos ELF en Linux, Sentry usa el identificador de compilación GNU para calcular el
identificador de depuración. Todos los compiladores y enlazadores recientes admiten la emisión de
IDs de compilación, pero a veces pueden requerir configuración adicional. `gcc` lo hace
de forma predeterminada; para `clang`, usa una de las siguientes opciones:

* `--build-id=uuid` para un identificador aleatorio rápido pero no reproducible.
* `--build-id=sha1` para un identificador más lento pero reproducible generado
  al calcular el hash de la primera página de la sección de código.

*El identificador debe estar presente e idéntico tanto en el binario como en los
archivos de información de depuración depurados (stripped).* Si el ID falta por alguna razón,
sube los archivos antes de depurarlos para que `sentry-cli` pueda calcular un
identificador estable a partir del archivo sin depurar.

<div id="pdb-age-mismatches">
  ## Desajustes de edad en PDB
</div>

Los PDB de Microsoft forman sus identificadores a partir de dos partes: una firma única y
un campo de edad. La firma se genera cuando el PDB se escribe inicialmente y
por lo general cambia con cada compilación. La edad es un contador que se incrementa cada
vez que se modifica el PDB.

Los archivos PE, como ejecutables y bibliotecas dinámicas, especifican el identificador completo
del PDB correspondiente en su Header. Esto incluye la edad. Sin embargo, si el PDB se
modifica después de que se haya generado el PE, su edad podría divergir. Esto
puede dar lugar a identificadores distintos:

```
PE:  3003763b-afcb-4a97-aae3-28de8f188d7c-2
PDB: 3003763b-afcb-4a97-aae3-28de8f188d7c-4
```

`sentry-cli` puede detectar estas diferencias durante el proceso de carga y
asociar el mismo identificador a ambos archivos. Sin embargo, esto requiere que ambos
archivos se carguen en la misma ejecución del comando de carga. De lo contrario, los
identificadores divergirán y Sentry podría no ser capaz de resolver el archivo correcto
para la simbolización.

<div id="wasm-build-ids">
  ## IDs de compilación WASM
</div>

[WebAssembly admite IDs de compilación](https://github.com/WebAssembly/tool-conventions/blob/main/BuildId.md) como una
[sección personalizada](https://webassembly.github.io/spec/core/binary/modules.html#custom-section).

`LLVM` (y, con él, la cadena de herramientas `emscripten`) admite esto [desde la versión 17](https://github.com/llvm/llvm-project/commit/c7af9ae577bb04c5fe120fc07844a500818c8f47).

Nuestra herramienta [`wasm-split`](https://github.com/getsentry/symbolicator/tree/master/crates/wasm-split)
también puede usarse para agregar un ID de compilación si tu cadena de herramientas aún no lo admite. También te permite
dividir y extraer información de depuración de tu archivo `*.wasm`.

<div id="proguard-uuids">
  ## UUID de ProGuard
</div>

A diferencia de otros archivos de información de depuración, los archivos de ProGuard no tienen un identificador único intrínseco. Sentry CLI les asigna un UUID SHA1 basado en la suma de verificación del archivo. Puedes usar `sentry-cli debug-files check` en un archivo de ProGuard para ver el UUID generado.

Si necesitas generar el UUID tú mismo, puedes hacerlo con el siguiente algoritmo (código en Python como referencia):

```python
import uuid

NAMESPACE = uuid.uuid5(uuid.NAMESPACE_DNS, "guardsquare.com")

def get_proguard_uuid(filename):
    with open(filename, 'rb') as f:
        return uuid.uuid5(NAMESPACE, f.read())
```

---
title: "Depurar formatos de archivo"
description: "Conoce los formatos de archivo específicos de cada plataforma y la información de depuración que contienen."
sidebar_order: 1
---

Sentry distingue cuatro tipos de información de depuración:

* **Información de depuración:** Proporciona nombres de funciones, rutas a archivos fuente, números de línea y frames en línea. El proceso de resolver esta información a partir de direcciones de instrucciones se llama &quot;symbolication&quot;. Esta información es relativamente grande en comparación con el ejecutable y, por lo general, se coloca en un archivo aparte. En Sentry, estos archivos se denominan *debug companions* y muestran la etiqueta `debug`.

* **Tablas de símbolos:** Si no hay información de depuración disponible para una determinada biblioteca, Sentry puede usar tablas de símbolos como alternativa para recuperar nombres de funciones. Las tablas de símbolos suelen estar incluidas tanto en el ejecutable como en los archivos *debug companion*. Sin embargo, no contienen información suficiente para resolver funciones en línea ni nombres de archivos y números de línea. La etiqueta `symtab` indica tablas de símbolos.

* **Código fuente:** Por convención, el código fuente no forma parte de los archivos habituales de información de depuración. Sentry CLI puede empaquetar el código fuente de tu aplicación y subirlo para mostrar el contexto de código fuente en los stack traces en Sentry. Estos paquetes aparecen con la etiqueta `sources`.

* **Información de unwind:** Permite a Sentry extraer stack traces de Minidumps y otros formatos binarios de fallos en compilaciones optimizadas. A este proceso se le conoce como &quot;stack unwinding&quot; o &quot;stack walking&quot;. Dado que esto también se requiere al lanzar excepciones en C++, esta información a menudo está incluida en el ejecutable o la biblioteca. Si un archivo subido contiene esta información, muestra la etiqueta `unwind`. Ten en cuenta que en algunas plataformas no se realiza un unwind real. Por ejemplo, actualmente WebAssembly no tiene el equivalente de minidumps, lo que significa que no requerimos ese tipo de información en esos casos.

Los compiladores colocan la información de depuración anterior en distintos archivos según la plataforma de destino, la arquitectura, las banderas de compilación o el nivel de optimización. En consecuencia, Sentry puede no necesitar toda la información anterior para procesar informes de fallos. Aun así, siempre es buena idea proporcionar toda la información de depuración disponible.

`sentry-cli` se puede usar para listar propiedades de archivos de depuración compatibles y validar su contenido. Consulta [*Archivos de información de depuración en sentry-cli*](/es/cli/dif/) para obtener más información.

<div id="mach-o-and-dsym">
  ## Mach-O y dSYM
</div>

Los ejecutables, las bibliotecas dinámicas y los acompañantes de depuración en todas las plataformas de Apple usan el formato contenedor *Mach Object*, o *Mach-O* para abreviar. Esto aplica a iOS, iPadOS, tvOS, watchOS, macOS y visionOS.

* **Ejecutables** no llevan extensión de archivo. En aplicaciones de escritorio, a menudo se colocan en estructuras de paquete de app con el sufijo `.app`. A menos que se elimine manualmente, los ejecutables incluyen información de unwind y una tabla de símbolos. La información de depuración nunca se almacena en los ejecutables.

* **Bibliotecas dinámicas** usan la extensión `.dylib` y, por lo demás, se comportan exactamente igual que los ejecutables.

* **Acompañantes de depuración** se colocan en una estructura de carpetas con la extensión `.dSYM`, y se ubican en `<name>.dSYM/Contents/Resources/DWARF/<name>`. Por lo general, contienen una tabla de símbolos e información de depuración, pero rara vez información de unwind.

Al compilar una aplicación con Xcode o con el compilador `clang`, la información de depuración se coloca automáticamente en un archivo dSYM. Sin embargo, al enlazar manualmente, el archivo dSYM debe crearse usando el siguiente comando:

```bash
dsymutil /ruta/a/salida[.dylib]
```

<div id="executable-and-linkable-format-elf">
  ## Formato ejecutable y enlazable (ELF)
</div>

En las distribuciones de Linux, los ejecutables y la información de depuración se almacenan en contenedores *ELF*. A diferencia de otras plataformas, no existe un contenedor ni un especificador específicos para archivos de depuración complementarios.

La información de depuración forma parte del binario (ejecutable o biblioteca) y se elimina al generar compilaciones de lanzamiento debido a su tamaño. No obstante, es posible conservarla en un archivo aparte (ya sea en otra ubicación o con la extensión `.debug`):

```bash
# Hay un ejecutable llamado "binary" en el CWD
objcopy --only-keep-debug binary binary.debug
objcopy --strip-debug --strip-unneeded binary
objcopy --add-gnu-debuglink=binary.debug binary
```

Esto da como resultado la siguiente estructura:

* **Ejecutables** no llevan extensión de archivo. Si se “strippan” como arriba,
  los ejecutables contienen una tabla de símbolos, pero no información de depuración. Si en la compilación
  se omiten los punteros de marco, también se conservará la información de desenrollado (unwind). Ambos pueden
  reducirse aún más usando opciones como `--strip-all`.

* **Bibliotecas compartidas** usan la extensión `.so` y, por lo demás, se comportan exactamente
  igual que los ejecutables.

* **Archivos de depuración** no llevan una extensión estándar, pero a menudo
  se nombran como `.debug`. Si se “strippan” como arriba, estos archivos contienen información de
  desenrollado (unwind), información de depuración y una tabla de símbolos.

Las bibliotecas compartidas instaladas mediante gestores de paquetes suelen proporcionar su información de
depuración en paquetes `*-dev` separados y colocarla en ubicaciones como
`/usr/local/debug/...`. Para obtener trazas de pila simbolizadas de esas
bibliotecas, asegúrate de subir también sus símbolos además de los de tu aplicación.

ELF admite la compresión de la información de depuración, lo que puede reducir significativamente
el tiempo necesario para subir archivos de información de depuración a Sentry y así mejorar
los tiempos de compilación. `gcc` (versión 5 o posterior) y `clang` (versión 5 o posterior) lo admiten
pasando la opción `-gz` tanto al compilador como al enlazador. La forma habitual
de comprimir la información de depuración, sin embargo, es al “strippear” el ejecutable:

```bash
# Nota: la opción --compress-debug-sections
objcopy --only-keep-debug --compress-debug-sections=zlib binary binary.debug
```

Esto se puede verificar buscando la marca `C` en `readelf`, correspondiente a
`SHF_COMPRESSED`:

```bash
readelf -S ruta/al/archivo
  ...
  [21] .debug_info       PROGBITS         0000000000000000  00000370
       000000000000e133  0000000000000000   C       0     0     1
```

<div id="pe-and-pdb">
  ## PE y PDB
</div>

Los ejecutables y las bibliotecas dinámicas en Microsoft Windows, y los creados por la
plataforma .NET en todos los sistemas operativos, usan el formato de contenedor *Portable Executable* (*PE*).
La información de depuración asociada se almacena en archivos *Program Database*
(*PDB*).

* **Ejecutables** usan la extensión de archivo `.exe`. Solo cuando se compilan para arquitecturas
  de 64 bits contienen información de desenrollado (unwind). De lo contrario, no contienen
  información útil y se omitirán al subirlos a Sentry.

* **Bibliotecas dinámicas** usan la extensión `.dll` y, por lo demás, se comportan
  exactamente igual que los ejecutables.

* **Archivos de depuración** se almacenan en archivos `.pdb`. Suelen contener información
  de depuración y, en la mayoría de los casos, tablas de símbolos. En programas de 32 bits,
  también incluyen información de desenrollado (unwind). En casos poco frecuentes, podrían tener nombres de archivo diferentes
  a los de su ejecutable correspondiente.

* La plataforma .NET usa una variación de este formato, llamada [Portable PDBs](https://github.com/dotnet/core/blob/main/Documentation/diagnostics/portable_pdb.md).
  Las Portable PDBs son compatibles a partir de Sentry 22.11.0 (o Sentry CLI 2.8.0, o Symbolic 10.0.0).

<div id="breakpad-symbols">
  ## Símbolos de Breakpad
</div>

La biblioteca Google Breakpad ha establecido un formato ASCII independiente de la plataforma
para almacenar información de depuración. Estos archivos suelen generarse para aplicaciones
que usan Breakpad, Crashpad o el framework Electron.

El repositorio de Breakpad incluye la herramienta `dump_syms` para cada plataforma, que puede
convertir archivos de depuración nativos en símbolos de Breakpad. Estos conversores agrupan toda
la información disponible en un único archivo, de modo que solo sea necesario subir un archivo.

A diferencia de los archivos de depuración nativos, los símbolos de Breakpad descartan mucha información
que no es necesaria para procesar minidumps. En particular, las funciones inline no se
declaran, por lo que Sentry no puede mostrar frames inline en los seguimientos de pila.

<div id="wasm">
  ## WASM
</div>

Para WebAssembly, admitimos [DWARF en contenedores WASM](https://yurydelendik.github.io/webassembly-dwarf/).
Ten en cuenta que no admitimos los source maps, que también son un formato usado para la depuración de WASM,
pero tienen limitaciones que los hacen poco prácticos para una herramienta de informes de fallos como Sentry.

[WebAssembly admite build IDs](https://github.com/WebAssembly/tool-conventions/blob/main/BuildId.md) como una
[sección personalizada](https://webassembly.github.io/spec/core/binary/modules.html#custom-section). Esta sección
es compatible en `LLVM` [desde la versión 17](https://github.com/llvm/llvm-project/commit/c7af9ae577bb04c5fe120fc07844a500818c8f47) (y, con ello, la correspondiente toolchain de `emscripten`).

Además, proporcionamos una herramienta para agregar build IDs y dividir archivos llamada [wasm-split](https://github.com/getsentry/symbolicator/blob/master/crates/wasm-split)
para ayudarte a crear un archivo de depuración complementario listo para subir a Sentry,
mientras se elimina toda la información de depuración del binario de la versión.

<div id="proguard-mappings">
  ## Mapas de ProGuard
</div>

Los archivos de mapeo de ProGuard permiten que Sentry convierta rutas de clases
y nombres de métodos de Java ofuscados a su forma original. En ese sentido, funcionan como archivos de información de depuración para aplicaciones Java y Android.
---
title: Uso avanzado
sidebar_order: 6
description: "Aprende a gestionar el ID de la versión y a personalizar Spring Boot según las necesidades de tu organización."
---

La integración de Spring Boot de Sentry incluye automáticamente la versión y configura las opciones como se describe en las siguientes secciones.

<div id="using-git-commit-id-as-the-release">
  ## Usar el ID de commit de Git como versión
</div>

Cuando Spring Boot está [configurado para generar información de Git](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto-git-info), cada evento enviado por Sentry incluirá un campo `release` con el ID de commit de Git actual, lo que habilitará la función de [salud de la versión](/es/product/releases/health/) de Sentry.

Esta función se puede desactivar en el archivo `application.properties`:

```properties {filename:application.properties}
sentry.use-git-commit-id-as-release=false
```

```yaml {filename:application.yml}
sentry:
  use-git-commit-id-as-release: false
```

<div id="registering-custom-event-processor">
  ## Registrar un procesador de eventos personalizado
</div>

Cualquier bean de Spring que implemente `EventProcessor` se configurará automáticamente en `SentryOptions` durante la autoconfiguración del SDK de Sentry. Puede haber varios procesadores de eventos registrados en una misma aplicación.

```java
import io.sentry.SentryEvent;
import io.sentry.EventProcessor;
import io.sentry.Hint
import org.springframework.stereotype.Component;

@Component
public class CustomEventProcessor implements EventProcessor {
  @Override
  public SentryEvent process(SentryEvent event, Hint hint) {
    // modifica el evento o devuelve null para eliminarlo
    return event;
  }
}
```

```kotlin
import io.sentry.SentryEvent
import io.sentry.EventProcessor
import io.sentry.Hint
import org.springframework.stereotype.Component

@Component
class CustomEventProcessor : EventProcessor {
  override fun process(event: SentryEvent, hint: Hint): SentryEvent? {
    // modifica el evento o devuelve null para descartarlo
    return event
  }
}
```

<div id="registering-custom-before-send-callback">
  ## Registrar un callback personalizado de Before Send
</div>

Cualquier bean de Spring que implemente `BeforeSendCallback` se establecerá automáticamente en `SentryOptions` durante la autoconfiguración del SDK. Ten en cuenta que solo puede haber un único bean establecido de esta manera.

```java
import io.sentry.SentryEvent;
import io.sentry.SentryOptions;
import io.sentry.Hint
import org.springframework.stereotype.Component;

@Component
public class CustomBeforeSendCallback implements SentryOptions.BeforeSendCallback {
  @Override
  public SentryEvent execute(SentryEvent event, Hint hint) {
    // Ejemplo: no enviar nunca el nombre del servidor en los eventos
    event.setServerName(null);
    return event;
  }
}
```

```kotlin
import io.sentry.SentryEvent
import io.sentry.SentryOptions
import io.sentry.Hint
import org.springframework.stereotype.Component

@Component
class CustomBeforeSendCallback : SentryOptions.BeforeSendCallback {
  override fun execute(event: SentryEvent, hint: Hint): SentryEvent? {
    // Ejemplo: nunca enviar el nombre del servidor en los eventos
    event.serverName = null
    return event
  }
}
```

<div id="registering-custom-before-breadcrumb-callback">
  ## Registrar un callback personalizado de Before Breadcrumb
</div>

Cualquier bean de Spring que implemente `BeforeBreadcrumbCallback` se establecerá automáticamente en `SentryOptions` durante la autoconfiguración del SDK. Ten en cuenta que solo puede haber un único bean configurado de esta manera.

```java
import io.sentry.Breadcrumb;
import io.sentry.SentryOptions;
import io.sentry.Hint
import org.springframework.stereotype.Component;

@Component
public class CustomBeforeBreadcrumbCallback implements SentryOptions.BeforeBreadcrumbCallback {

  @Override
  public Breadcrumb execute(Breadcrumb breadcrumb, Hint hint) {
    // No agregues breadcrumbs con un mensaje que contenga:
    if (breadcrumb.getMessage() != null
      && breadcrumb.getMessage().contains("breadcrumb incorrecto")) {
      return null;
    }
    return breadcrumb;
  }
}
```

```kotlin
import io.sentry.Breadcrumb
import io.sentry.SentryOptions
import io.sentry.Hint
import org.springframework.stereotype.Component

@Component
class CustomBeforeBreadcrumbCallback : SentryOptions.BeforeBreadcrumbCallback {
  override fun execute(breadcrumb: Breadcrumb, hint: Hint): Breadcrumb? {
    // No agregues breadcrumbs cuyo mensaje contenga:
    return if (breadcrumb.message?.contains("bad breadcrumb") == true) {
      null
    } else {
      breadcrumb
    }
  }
}
```

<div id="registering-custom-on-discard-callback">
  ## Registrar un callback personalizado para descarte
</div>

Cualquier bean de Spring que implemente `OnDiscardCallback` se establecerá automáticamente en `SentryOptions` durante la autoconfiguración del SDK. Ten en cuenta que solo puede haber un único bean configurado de esta manera.

```java
import io.sentry.SentryOptions;
import io.sentry.clientreport.DiscardReason;
import io.sentry.DataCategory;
import org.springframework.stereotype.Component;

@Component
class CustomOnDiscardCallback implements SentryOptions.OnDiscardCallback {
  @Override 
  public void execute(DiscardReason reason, DataCategory category, Long count) {
    // Solo registra la cantidad de spans perdidos por condiciones de desbordamiento
    if ((reason == DiscardReason.CACHE_OVERFLOW
            || reason == DiscardReason.QUEUE_OVERFLOW)
        && category == DataCategory.Span) {
      System.out.println("Se descartaron " + number + " spans por desbordamiento.");
    }
  }
}
```

```kotlin
import io.sentry.SentryOptions
import io.sentry.clientreport.DiscardReason
import io.sentry.DataCategory
import org.springframework.stereotype.Component

@Component
class CustomOnDiscardCallback : SentryOptions.OnDiscardCallback {
  override fun execute(reason: DiscardReason, category: DataCategory, countToAdd: Long) {
    // Solo registra el número de spans perdidos por desbordamiento
    if ((reason == DiscardReason.CACHE_OVERFLOW
            || reason == DiscardReason.QUEUE_OVERFLOW)
        && category == DataCategory.Span) {
      println("Se descartaron " + number + " spans por desbordamiento.")
    }
  }
}
```

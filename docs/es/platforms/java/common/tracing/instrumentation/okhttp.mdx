---
title: Integración con OkHttp
sidebar_order: 35
sdk: sentry.java.okhttp
description: "Aprende a capturar información de rastreo del cliente OkHttp."
notSupported:
  - java.logback
  - java.log4j2
  - java.jul
---

<Alert>
  Para capturar transacciones, primero debes <PlatformLink to="/tracing/">configurar el tracing</PlatformLink>.
</Alert>

La biblioteca `sentry-okhttp` ofrece compatibilidad con [OkHttp](https://github.com/square/okhttp) para Sentry mediante `SentryOkHttpInterceptor` y `SentryOkHttpEventListener`, que crean un span por cada solicitud HTTP saliente ejecutada con un cliente de OkHttp. El código fuente está disponible [en GitHub](https://github.com/getsentry/sentry-java/tree/main/sentry-okhttp).

<div id="install">
  ## Instalación
</div>

Para instalar la integración:

```xml {tabTitle:Maven}
<dependency>
    <groupId>io.sentry</groupId>
    <artifactId>sentry-okhttp</artifactId>
    <version>{{@inject packages.version('sentry.java.okhttp', '7.0.0') }}</version>
</dependency>
```

```groovy {tabTitle:Gradle}
implementation 'io.sentry:sentry-okhttp:{{@inject packages.version('sentry.java.okhttp', '7.0.0') }}'
```

```scala {tabTitle: SBT}
libraryDependencies += "io.sentry" % "sentry-okhttp" % "{{@inject packages.version('sentry.java.okhttp', '7.0.0') }}"
```

Para otros gestores de dependencias, consulta el [repositorio central de Maven](https://search.maven.org/artifact/io.sentry/sentry-okhttp).

<div id="configure">
  ## Configurar
</div>

La configuración debe hacerse una vez que crees tu instancia de `OkHttpClient`.

```kotlin
import okhttp3.OkHttpClient
import io.sentry.okhttp.SentryOkHttpEventListener
import io.sentry.okhttp.SentryOkHttpInterceptor

private val client = OkHttpClient.Builder()
  .addInterceptor(SentryOkHttpInterceptor())
  .eventListener(SentryOkHttpEventListener())
  .build()
```

```java
import okhttp3.OkHttpClient;
import io.sentry.okhttp.SentryOkHttpEventListener;
import io.sentry.okhttp.SentryOkHttpInterceptor;

private final OkHttpClient client = new OkHttpClient.Builder()
  .addInterceptor(new SentryOkHttpInterceptor())
  .eventListener(new SentryOkHttpEventListener())
  .build();
```

El SDK utiliza `SentryOkHttpInterceptor` para admitir el [trazado distribuido](/es/product/sentry-basics/tracing/distributed-tracing/) y crea un span para cualquier llamada HTTP.
El SDK puede ofrecer información más detallada mediante `SentryOkHttpEventListener`, creando un span para cada operación reportada por OkHttp, incluidas la configuración de DNS, la selección del proxy, la conexión HTTP, la configuración de SSL, el envío de los encabezados de la solicitud, el envío del cuerpo de la solicitud, la recepción de los encabezados de la respuesta y la recepción del cuerpo de la respuesta.

<div id="verify">
  ## Verificar
</div>

Este fragmento incluye una petición HTTP y captura un mensaje intencional, para que puedas comprobar que todo funciona en cuanto lo configures:

```kotlin
import io.sentry.Sentry
import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.Request

@Throws(IOException::class)
fun run(url: String): String? {
  val request = Request.Builder()
    .url(url)
    .build()

  val bodyStr = client
    .newCall(request)
    .execute()
    .body?.toString()

  Sentry.captureMessage("El mensaje $bodyStr")

  return bodyStr
}
```

```java
import io.sentry.Sentry;
import java.io.IOException;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.ResponseBody;

String run(String url) throws IOException {
  Request request = new Request.Builder()
    .url(url)
    .build();

  ResponseBody body = client
    .newCall(request)
    .execute()
    .body();

  String bodyStr = body != null ? body.toString() : null;

  Sentry.captureMessage("El mensaje " + bodyStr);

  return bodyStr;
}
```

Para ver y resolver el mensaje registrado, inicia sesión en [sentry.io](https://sentry.io) y abre tu proyecto. Al hacer clic en el título del error, se abrirá una página donde podrás ver información detallada y marcar el error como resuelto.

<div id="customize-the-recorded-span">
  ## Personaliza el tramo registrado
</div>

El tramo capturado se puede personalizar o descartar con un `BeforeSpanCallback`:

```kotlin
import io.sentry.ISpan
import io.sentry.okhttp.SentryOkHttpInterceptor
import okhttp3.Request
import okhttp3.Response

class CustomBeforeSpanCallback : SentryOkHttpInterceptor.BeforeSpanCallback {
  override fun execute(span: ISpan, request: Request, response: Response?): ISpan? {
    return if (request.url.toUri().toString().contains("/admin")) {
      null
    } else {
      span
    }
  }
}
```

```java
import io.sentry.ISpan;
import io.sentry.okhttp.SentryOkHttpInterceptor;
import okhttp3.Request;
import okhttp3.Response;

class CustomBeforeSpanCallback implements SentryOkHttpInterceptor.BeforeSpanCallback {
  public ISpan execute(ISpan span, Request request, Response response) {
    if (request.getUrl().toUri().toString().contains("/admin")) {
      return null;
    } else {
      return span;
    }
  }
}
```

La instancia de callback debe configurarse en `SentryOkHttpInterceptor` después de crear la instancia de `OkHttpClient`.

```kotlin
import okhttp3.OkHttpClient
import io.sentry.okhttp.SentryOkHttpEventListener
import io.sentry.okhttp.SentryOkHttpInterceptor

private val client = OkHttpClient.Builder()
  .eventListener(SentryOkHttpEventListener())
  .addInterceptor(SentryOkHttpInterceptor(CustomBeforeSpanCallback()))
  .build()
```

```java
import okhttp3.OkHttpClient;
import io.sentry.okhttp.SentryOkHttpEventListener;
import io.sentry.okhttp.SentryOkHttpInterceptor;

private final OkHttpClient client = new OkHttpClient.Builder()
  .eventListener(new SentryOkHttpEventListener())
  .addInterceptor(new SentryOkHttpInterceptor(new CustomBeforeSpanCallback()))
  .build();
```

<div id="using-multiple-event-listeners">
  ## Uso de múltiples listeners de eventos
</div>

El listener de eventos de la integración puede propagar llamadas a otro `EventListener` o `EventListener.Factory` configurado en `SentryOkHttpEventListener` una vez que crees tu instancia de `OkHttpClient`.

```kotlin
import okhttp3.OkHttpClient
import io.sentry.okhttp.SentryOkHttpEventListener
import io.sentry.okhttp.SentryOkHttpInterceptor

private val client = OkHttpClient.Builder()
  .eventListener(SentryOkHttpEventListener(MyEventListener()))
  .addInterceptor(SentryOkHttpInterceptor(CustomBeforeSpanCallback()))
  .build()
```

```java
import okhttp3.OkHttpClient;
import io.sentry.okhttp.SentryOkHttpEventListener;
import io.sentry.okhttp.SentryOkHttpInterceptor;

private final OkHttpClient client = new OkHttpClient.Builder()
  .eventListener(new SentryOkHttpEventListener(new MyEventListener()))
  .addInterceptor(new SentryOkHttpInterceptor(new CustomBeforeSpanCallback()))
  .build();
```

<div id="http-client-errors">
  ## Errores del cliente HTTP
</div>

Esta función captura automáticamente los errores del cliente HTTP (como códigos de respuesta no exitosos) como eventos de error y los envía a Sentry. El evento de error incluirá los datos de `request` y `response`, como `url`, `status_code`, entre otros.

Esta función está habilitada de forma predeterminada y puede desactivarse configurando la opción `captureFailedRequests` en `false`:

```kotlin
import okhttp3.OkHttpClient
import io.sentry.okhttp.SentryOkHttpEventListener
import io.sentry.okhttp.SentryOkHttpInterceptor

private val client = OkHttpClient.Builder()
  .eventListener(SentryOkHttpEventListener())
  .addInterceptor(SentryOkHttpInterceptor(captureFailedRequests = false))
  .build()
```

De forma predeterminada, solo los errores de cliente HTTP con un código de respuesta entre `500` y `599` se registran como eventos de error, pero puedes cambiar este comportamiento estableciendo la opción `failedRequestStatusCodes`:

```kotlin
import okhttp3.OkHttpClient
import io.sentry.okhttp.SentryOkHttpEventListener
import io.sentry.okhttp.SentryOkHttpInterceptor
import io.sentry.HttpStatusCodeRange

private val client = OkHttpClient.Builder()
  .eventListener(SentryOkHttpEventListener())
  .addInterceptor(SentryOkHttpInterceptor(
    captureFailedRequests = true,
    failedRequestStatusCodes = listOf(HttpStatusCodeRange(400, 599))))
  .build()
```

Los errores de cliente HTTP de cualquier destino (expresión regular `.*`) se capturan automáticamente, pero puedes cambiar este comportamiento configurando la opción `failedRequestTargets` con una expresión regular o con una cadena (`String`) simple. Una cadena simple debe incluir al menos uno de los elementos de la lista. Las cadenas simples no tienen que ser coincidencias exactas: la URL de una solicitud se considera coincidente cuando contiene una cadena proporcionada mediante la opción.

```kotlin
import okhttp3.OkHttpClient
import io.sentry.okhttp.SentryOkHttpEventListener
import io.sentry.okhttp.SentryOkHttpInterceptor
import io.sentry.HttpStatusCodeRange

private val client = OkHttpClient.Builder()
  .eventListener(SentryOkHttpEventListener())
  .addInterceptor(SentryOkHttpInterceptor(
    captureFailedRequests = true,
    failedRequestTargets = listOf("myapi.com")))
  .build()
```

De forma predeterminada, los eventos de error no incluirán datos personales (PII), como `Headers` y `Cookies`. Puedes cambiar este comportamiento estableciendo la opción `sendDefaultPii` en `true`:

```kotlin
Sentry.init { options ->
  options.isSendDefaultPii = true
}
```

Los errores de cliente HTTP enviados a Sentry se pueden buscar, y puedes configurar alertas si utilizas las propiedades `http.url` y `http.status_code`. Obtén más información en nuestra documentación completa sobre [Propiedades buscables](/es/concepts/search/searchable-properties/).

<div id="customize-or-drop-the-error-event">
  ### Personalizar o descartar el evento de error
</div>

El evento de error capturado puede personalizarse o descartarse con un `BeforeSendCallback`:

```kotlin
import io.sentry.Sentry
import io.sentry.SentryOptions.BeforeSendCallback
import okhttp3.Request
import okhttp3.Response
import io.sentry.TypeCheckHint.OKHTTP_REQUEST
import io.sentry.TypeCheckHint.OKHTTP_RESPONSE

Sentry.init { options ->
  // Agrega un callback que se utilizará antes de enviar el evento a Sentry.
  // Con este callback, puedes modificar el evento o descartarlo devolviendo null.
  options.beforeSend = BeforeSendCallback { event, hint ->
    val request = hint.getAs(OKHTTP_REQUEST, Request::class.java)
    val response = hint.getAs(OKHTTP_RESPONSE, Response::class.java)

    // personaliza o descarta el evento
    event
  }
}
```

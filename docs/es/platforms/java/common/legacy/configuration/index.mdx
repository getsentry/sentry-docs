---
title: Configuración
sidebar_order: 10
description: "Obtén más información sobre cómo configurar el SDK. Estas opciones se establecen cuando el SDK se inicializa por primera vez y se pasan al método init como un objeto."
---

<Alert level="warning" title="Nota">
  Un nuevo SDK de Java ha sustituido a esta versión en desuso. Sentry conserva esta documentación para clientes que usan el cliente antiguo. Recomendamos usar el [SDK de Java actualizado](/es/platforms/java/) para proyectos nuevos.
</Alert>

<div id="setting-the-dsn-data-source-name">
  ## Configuración del DSN (Data Source Name)
</div>

El DSN es lo primero y lo más importante que debes configurar porque le indica al SDK adónde enviar los eventos. Puedes encontrar el DSN de tu proyecto en la sección “Client Keys” de tus “Project Settings” en Sentry. Puede configurarse de varias maneras. Las [métodos de configuración se detallan a continuación](#configuration-methods).

En un archivo de propiedades en tu sistema de archivos o en el classpath (valor predeterminado: `sentry.properties`):

```text {tabTitle:Properties File} {filename:sentry.properties}
dsn=___PUBLIC_DSN___
```

Mediante las propiedades del sistema de Java *(no disponible en Android)*:

```bash {tabTitle:Java System Properties}
java -Dsentry.dsn=___PUBLIC_DSN___ -jar app.jar
```

Mediante una variable de entorno del sistema *(no disponible en Android)*:

```bash {tabTitle:System Environment Variable}
SENTRY_DSN=___PUBLIC_DSN___ java -jar app.jar
```

En el código:

```java
import io.sentry.Sentry;

Sentry.init("___PUBLIC_DSN___");
```

```kotlin
import io.sentry.Sentry

Sentry.init("___PUBLIC_DSN___")
```

<div id="configuration-methods">
  ## Métodos de configuración
</div>

Hay varias formas de configurar el SDK de Java, pero todas aceptan las mismas opciones. Consulta a continuación cómo usar cada método de configuración y cómo pueden diferir los nombres de las opciones entre ellos.

<div id="configuration-via-properties-file">
  ### Configuración mediante archivo de propiedades
</div>

El SDK de Java se puede configurar mediante un [archivo .properties](https://en.wikipedia.org/wiki/.properties) ubicado en el sistema de archivos o en el classpath de tu aplicación. De forma predeterminada, el SDK buscará un archivo `sentry.properties` en el directorio de trabajo actual de la aplicación o en la raíz del classpath. En la mayoría de las aplicaciones del lado del servidor, el directorio predeterminado para agregar recursos al classpath es `src/main/resources/`, y en Android el predeterminado es `app/src/main/resources/`. Puedes anular la ubicación del archivo de propiedades usando la propiedad del sistema de Java `sentry.properties.file` o la variable de entorno del sistema `SENTRY_PROPERTIES_FILE`.

Dado que este archivo a menudo se incluye junto con tu aplicación, los valores no se pueden cambiar fácilmente una vez que tu aplicación se ha empaquetado. Por este motivo, el archivo de propiedades es útil para establecer valores predeterminados u opciones que no esperas cambiar con frecuencia. El archivo de propiedades es el último lugar que se consulta para cada opción, por lo que la configuración en tiempo de ejecución (descrita a continuación) lo reemplazará si está disponible.

Los nombres de las opciones en el archivo de propiedades coinciden exactamente con los ejemplos que se muestran a continuación. Por ejemplo, para habilitar el muestreo, en tu archivo de propiedades:

```properties
sample.rate=0.75
```

<div id="configuration-via-the-runtime-environment">
  ### Configuración mediante el entorno de ejecución
</div>

Este es el método más flexible para configurar el cliente de Sentry, ya que puede ajustarse fácilmente según el entorno en el que ejecutes tu aplicación. *Ni las propiedades del sistema de Java ni las variables de entorno del sistema están disponibles en aplicaciones de Android. Configura Sentry para Android mediante código o con el archivo de propiedades.*

Hay dos métodos disponibles para la configuración en tiempo de ejecución, comprobados en este orden: propiedades del sistema de Java y variables de entorno del sistema.

Los nombres de las opciones de las propiedades del sistema de Java son exactamente como los ejemplos que se muestran a continuación, salvo que van precedidos por `sentry.`. Por ejemplo, para habilitar el muestreo:

```bash
java -Dsentry.sample.rate=0.75 -jar app.jar
```

Los nombres de las opciones de variables de entorno del sistema requieren reemplazar `.` por `_`, escribirlos en mayúsculas y agregar el prefijo `SENTRY_`. Por ejemplo, para habilitar el muestreo:

```bash
SENTRY_SAMPLE_RATE=0.75 java -jar app.jar
```

<div id="configuration-via-code">
  ### Configuración mediante código
</div>

El DSN también puede configurarse directamente en el código:

```java
import io.sentry.Sentry;

Sentry.init("___PUBLIC_DSN___");
```

```kotlin
import io.sentry.Sentry

Sentry.init("___PUBLIC_DSN___")
```

Sentry **no podrá** hacer nada con los eventos hasta que se ejecute esta línea, por lo que no se recomienda este método de configuración si pueden producirse errores durante el inicio. Además, al usar un DSN codificado de forma rígida, ya no podrás sobrescribir el DSN en tiempo de ejecución mediante las propiedades del sistema de Java o las variables de entorno del sistema.

<div id="configuration-via-the-dsn">
  ### Configuración mediante el DSN
</div>

El SDK también puede configurarse añadiendo parámetros de query string en el propio DSN. Es algo recursivo, porque el DSN en sí es una opción que debes configurar en algún lugar (¡y no dentro del DSN!).

Los nombres de las opciones en el DSN coinciden exactamente con los ejemplos que se indican a continuación. Por ejemplo, para habilitar el muestreo si configuras tu DSN mediante variables de entorno:

```bash
SENTRY_DSN={DSN}/1?sample.rate=0.75 java -jar app.jar
```

Por supuesto, también puedes pasar este DSN usando los otros métodos descritos anteriormente.

<div id="options">
  ## Opciones
</div>

Todas las siguientes opciones pueden configurarse como se indicó arriba: mediante un archivo `sentry.properties`, mediante propiedades del sistema de Java, mediante variables de entorno del sistema o mediante el DSN.

<div id="release">
  ### Versión
</div>

Para definir la versión de la aplicación que se enviará con cada evento, usa la opción `release`:

```
release=my-project-name@2.3.12
```

<div id="distribution">
  #### Distribución
</div>

Para establecer la distribución de la aplicación que se enviará con cada evento, usa la opción `dist`:

```
release=my-project-name@2.3.12
dist=x86
```

La distribución solo es útil (y se utiliza) si también se ha establecido `release`.

<div id="environment">
  ### Entorno
</div>

Para establecer el entorno de la aplicación que se enviará con cada evento, utiliza la opción `environment`:

```
entorno=staging
```

<div id="server-name">
  ### Nombre del servidor
</div>

Para configurar el nombre del servidor que se enviará con cada evento, usa la opción `servername`:

```
servername=host1
```

<div id="tags">
  ### Etiquetas
</div>

Para definir etiquetas que se enviarán con cada evento, usa la opción `tags` con pares de clave y valor separados por comas y unidos por dos puntos:

```
tags=tag1:valor1,tag2:valor2
```

<div id="mdc-tags">
  ### Etiquetas MDC
</div>

Para definir nombres de etiquetas extraídas del sistema MDC de SLF4J, usa la opción `mdctags` con los nombres de las claves separados por comas. Esta opción solo resulta útil cuando usas una de las integraciones de registro.

```
mdctags=foo,bar
```

```java
import org.slf4j.MDC;

MDC.put("foo", "value1");
MDC.put("bar", "value2");

// Esto envía un evento en el que los valores MDC de 'foo' y 'bar' se establecen como etiquetas adicionales
logger.error("Esta es una prueba");
```

```kotlin
import org.slf4j.MDC

MDC.put("foo", "value1")
MDC.put("bar", "value2")

// Envía un evento en el que los valores MDC 'foo' y 'bar' se establecen como etiquetas adicionales
logger.error("Esto es una prueba")
```

<div id="extra-data">
  ### Datos adicionales
</div>

Para definir datos adicionales que se enviarán con cada evento (pero no como etiquetas), usa la opción `extra` con pares de clave y valor separados por comas y unidos por dos puntos:

```
extra=key1:value1,key2:value2
```

<div id="in-application-stack-frames">
  ### Marcos de pila “en la aplicación”
</div>

Sentry diferencia los marcos de pila directamente relacionados con tu aplicación (“en la aplicación”) de los que provienen de otros paquetes, como la biblioteca estándar, frameworks u otras dependencias. Esta diferencia se muestra en la interfaz web de Sentry, donde, de forma predeterminada, solo se visualizan los marcos “en la aplicación”.

Puedes configurar qué prefijos de paquetes usa tu aplicación con la opción `stacktrace.app.packages`, que acepta una lista separada por comas.

```
stacktrace.app.packages=com.mycompany,com.other.name
```

Si no quieres usar esta función pero deseas desactivar la advertencia, simplemente establécela como una cadena vacía:

```
stacktrace.app.packages=
```

<div id="same-frame-as-enclosing-exception">
  #### Mismo frame que la excepción que lo contiene
</div>

Sentry puede usar el sistema “in application” para ocultar frames en excepciones encadenadas. Por lo general, cuando se imprime un StackTrace, el resultado se ve así:

```
Excepción de alto nivel: Excepción de nivel medio: Excepción de bajo nivel
        at Main.a(Main.java:13)
        at Main.main(Main.java:4)
Causada por: Excepción de nivel medio: Excepción de bajo nivel
        at Main.c(Main.java:23)
        at Main.b(Main.java:17)
        at Main.a(Main.java:11)
        ... 1 más
Causada por: Excepción de bajo nivel
        at Main.e(Main.java:30)
        at Main.d(Main.java:27)
        at Main.c(Main.java:21)
        ... 3 más
```

Algunos frames se reemplazan por la línea `... N more` porque son los mismos frames que en la excepción que los contiene.

Un comportamiento similar está activado de forma predeterminada en Sentry. Para desactivarlo, usa la opción `stacktrace.hidecommon`.

```
stacktrace.hidecommon=falso
```

<div id="event-sampling">
  ### Muestreo de eventos
</div>

Puedes configurar Sentry para realizar muestreo de eventos con la opción `sample.rate`:

```
sample.rate=0.75
```

Esta opción acepta un número de 0.0 a 1.0, que representa el porcentaje de eventos que se permitirán pasar al servidor (del 0% al 100%). De forma predeterminada, todos los eventos se enviarán al servidor de Sentry.

<div id="uncaught-exception-handler">
  ### Manejador de excepciones no capturadas
</div>

De forma predeterminada, se configura un `UncaughtExceptionHandler` que intentará enviar las excepciones a Sentry. Para desactivarlo, utiliza la opción `uncaught.handler.enabled`. Las excepciones se envían de forma asíncrona de manera predeterminada, y **no hay garantía** de que se envíen antes de que finalice la JVM. Es recomendable usar esta opción junto con el sistema de almacenamiento en disco descrito a continuación.

```
uncaught.handler.enabled=false
```

<div id="buffering-events-to-disk">
  ### Almacenamiento en búfer de eventos en disco
</div>

Sentry se puede configurar para escribir eventos en un directorio específico del disco cuando falle la comunicación con el servidor de Sentry mediante la opción `buffer.dir`. Si el directorio no existe, Sentry intentará crearlo al iniciarse y, por lo tanto, podría necesitar permiso de escritura en el directorio superior. Sentry siempre requiere permiso de escritura en el propio directorio del búfer. Esto está habilitado de forma predeterminada si se utiliza `AndroidSentryClientFactory`.

```
buffer.dir=sentry-events
```

El número máximo de eventos que se almacenarán en disco es 10 de forma predeterminada, pero también puede configurarse con la opción `buffer.size`:

```
buffer.size=100
```

Si se proporciona un directorio de búfer, un hilo en segundo plano intentará periódicamente volver a enviar los eventos que se encuentren en el disco. De forma predeterminada, intentará enviar eventos cada 60 segundos. Puedes cambiar esto con la opción `buffer.flushtime` (en milisegundos):

```
buffer.flushtime=10000
```

<Alert level="warning" title="Advertencia de seguridad">
  El SDK de Java utiliza actualmente el sistema nativo de serialización de Java para escribir eventos en el sistema de archivos cuando el almacenamiento en búfer está habilitado. Debido a debilidades en dicho sistema, los usuarios con acceso de escritura al directorio `buffer.dir` podrían provocar que el SDK de Java deserialice clases de Java arbitrarias. En casos extremos, esto podría permitir la ejecución de código.
</Alert>

<div id="graceful-shutdown-of-buffering-advanced">
  #### Apagado ordenado del almacenamiento en búfer (avanzado)
</div>

Para detener correctamente el hilo que vacía el búfer, se crea un `ShutdownHook`. De forma predeterminada, se le concede 1 segundo para cerrarse de manera ordenada, pero puede ajustarse mediante `buffer.shutdowntimeout` (en milisegundos):

```
buffer.shutdowntimeout=5000
```

El valor especial `-1` puede usarse para desactivar el tiempo de espera y esperar indefinidamente a que el executor finalice.

El `ShutdownHook` podría provocar pérdidas de memoria en un entorno donde el ciclo de vida de Sentry no coincida con el de la JVM.

Un ejemplo sería un entorno JEE donde la aplicación que usa Sentry pueda desplegarse y retirarse con regularidad.

Para evitar este comportamiento, se puede desactivar el apagado ordenado configurando la opción `buffer.gracefulshutdown`:

```
buffer.gracefulshutdown=false
```

<div id="async-connection">
  ### Conexión asíncrona
</div>

Para evitar problemas de rendimiento por la generación de muchos registros o por una conexión lenta al servidor de Sentry, se configura una conexión asíncrona usando un grupo de subprocesos de baja prioridad para enviar eventos a Sentry.

Para desactivar el modo asíncrono, agrega `async=false` a tus opciones:

```
async=false
```

<div id="graceful-shutdown-of-async-advanced">
  #### Apagado ordenado de Async (avanzado)
</div>

Para apagar la conexión asíncrona de forma ordenada, se crea un `ShutdownHook`. De forma predeterminada, la conexión asíncrona dispone de 1 segundo para apagarse de manera ordenada, pero esto se puede ajustar mediante `async.shutdowntimeout` (en milisegundos):

```
async.shutdowntimeout=5000
```

El valor especial `-1` puede usarse para desactivar el tiempo de espera y esperar indefinidamente a que el ejecutor termine.

El `ShutdownHook` podría provocar fugas de memoria en un entorno donde el ciclo de vida de Sentry no coincida con el de la JVM.

Un ejemplo sería en un entorno JEE, donde la aplicación que usa Sentry podría desplegarse y retirarse con regularidad.

Para evitar este comportamiento, es posible desactivar el apagado ordenado. Esto podría provocar la pérdida de algunas entradas de registro si la aplicación de logging no apaga correctamente la instancia de `SentryClient`.

La opción para hacerlo es `async.gracefulshutdown`:

```
async.gracefulshutdown=false
```

<div id="async-queue-size-advanced">
  #### Tamaño de la cola asíncrona (avanzado)
</div>

La cola predeterminada para almacenar eventos sin procesar está limitada a 50 elementos. Los elementos adicionales que se agreguen cuando la cola esté llena se descartarán y nunca se enviarán al servidor de Sentry. Dependiendo del entorno (si la memoria es limitada), es importante poder controlar el tamaño de esa cola para evitar problemas de memoria.

Es posible establecer un máximo con la opción `async.queuesize`:

```
async.queuesize=100
```

Esto significa que, si la conexión con el servidor de Sentry se cae, solo se almacenarán los 100 eventos más recientes y se procesarán en cuanto el servidor vuelva a estar operativo.

El valor especial `-1` puede usarse para habilitar una cola ilimitada. Ten en cuenta que los problemas de conectividad de red o del servidor de Sentry podrían hacer que tu proceso se quede sin memoria.

<div id="async-threads-count-advanced">
  #### Recuento de hilos asíncronos (avanzado)
</div>

De forma predeterminada, el pool de hilos que usa la conexión asíncrona contiene un hilo por procesador disponible para la JVM.

Puedes establecer manualmente la cantidad de hilos (por ejemplo, si quieres usar solo uno) con la opción `async.threads`:

```
async.threads=1
```

<div id="async-threads-priority-advanced">
  #### Prioridad de los hilos asíncronos (avanzado)
</div>

En la mayoría de los casos, enviar registros a Sentry no es tan importante como que la aplicación funcione con fluidez, por lo que los hilos tienen [prioridad mínima](http://docs.oracle.com/javase/6/docs/api/java/lang/Thread.html#MIN_PRIORITY).

Es posible personalizar este valor para aumentar la prioridad de estos hilos con la opción `async.priority`:

```
async.priority=10
```

<div id="compression">
  ### Compresión
</div>

De forma predeterminada, el contenido que se envía a Sentry se comprime antes del envío. Sin embargo, comprimir y codificar los datos conlleva un pequeño consumo de CPU y memoria que podría no compensar si la conexión con Sentry es rápida y fiable.

Según las limitaciones del proyecto (por ejemplo, una aplicación móvil con conexión limitada o Sentry alojado en una red externa), puede resultar útil comprimir los datos de antemano o no hacerlo.

Es posible habilitar o deshabilitar manualmente la compresión con la opción `compression`

```
compression=false
```

<div id="max-message-size">
  ### Tamaño máximo del mensaje
</div>

De forma predeterminada, solo se enviarán al servidor los primeros 1000 caracteres de un mensaje. Esto se puede cambiar con la opción `maxmessagelength`.

```
maxmessagelength=1500
```

<div id="timeout-advanced">
  ### Tiempo de espera (avanzado)
</div>

Se define un tiempo de espera para evitar bloquear los hilos de Sentry cuando el establecimiento de la conexión tarda demasiado.

Puedes ajustar manualmente la duración del tiempo de espera con `timeout` (en milisegundos):

```
timeout=10000
```

<div id="using-a-proxy">
  ### Uso de un proxy
</div>

Si tu aplicación necesita enviar solicitudes salientes a través de un proxy HTTP, puedes configurar los datos del proxy mediante las propiedades de red de la JVM o como una opción de Sentry.

Por ejemplo, usando las propiedades de red de la JVM (afecta a todo el proceso de la JVM),

```bash
java \
  # si usas el protocolo HTTP \
  -Dhttp.proxyHost=proxy.example.com \
  -Dhttp.proxyPort=8080 \
  \
  # si usas el protocolo HTTPS \
  -Dhttps.proxyHost=proxy.example.com \
  -Dhttps.proxyPort=8080 \
  \
  # aplica tanto a HTTP como a HTTPS
  -Dhttp.nonProxyHosts="localhost|host.example.com" \
  \
  MyApp
```

Consulta [Java Networking and Proxies](http://docs.oracle.com/javase/8/docs/technotes/guides/net/proxies.html) para obtener más información sobre las propiedades del proxy.

Como alternativa, usando las opciones de Sentry (solo afecta al cliente HTTP de Sentry; útil en contenedores de aplicaciones compartidas),

```
http.proxy.host=proxy.example.com
http.proxy.port=8080
```

<div id="custom-functionality">
  ## Funcionalidad personalizada
</div>

En ocasiones, es posible que necesites una funcionalidad personalizada que no está incluida en el SDK de Java. La forma más común de lograrlo es crear tu propia instancia de `SentryClientFactory`, como se muestra en el siguiente ejemplo.

<div id="implementation">
  ### Implementación
</div>

```java
public class MySentryClientFactory extends DefaultSentryClientFactory {
  @Override
  public SentryClient createSentryClient(Dsn dsn) {
    SentryClient sentryClient = new SentryClient(createConnection(dsn), getContextManager(dsn));

    /*
     Crea y usa ForwardedAddressResolver, que utilizará el encabezado X-FORWARDED-FOR para la dirección remota si existe.
     X-FORWARDED-FOR header for the remote address if it exists.
     */
    ForwardedAddressResolver forwardedAddressResolver = new ForwardedAddressResolver();
    sentryClient.addBuilderHelper(new HttpEventBuilderHelper(forwardedAddressResolver));

    sentryClient.addBuilderHelper(new ContextBuilderHelper(sentryClient));
    return configureSentryClient(sentryClient, dsn);
  }
}
```

```kotlin
class MySentryClientFactory : DefaultSentryClientFactory() {
  override fun createSentryClient(dsn: Dsn): SentryClient {
    val sentryClient = SentryClient(createConnection(dsn), getContextManager(dsn))

    /*
     Crea y usa ForwardedAddressResolver, que utilizará la
     cabecera X-FORWARDED-FOR para la dirección remota si existe.
     */
    val forwardedAddressResolver = ForwardedAddressResolver()
    sentryClient.addBuilderHelper(HttpEventBuilderHelper(forwardedAddressResolver))
    sentryClient.addBuilderHelper(ContextBuilderHelper(sentryClient))
    return configureSentryClient(sentryClient, dsn)
  }
}
```

<div id="usage">
  ### Uso
</div>

Para usar tu implementación personalizada de `SentryClientFactory`, utiliza la opción `factory`:

```
factory=my.company.MySentryClientFactory
```

Tu clase factory deberá estar disponible en el classpath con un constructor sin argumentos; de lo contrario, se producirá un error.

<div id="linter-configuration">
  ## Configuración del linter
</div>

A veces, los linters pueden advertir sobre tipos usados por el SDK que no están disponibles en tu app. Esto puede ocurrir, por ejemplo, al usar la integración de Android, ya que el SDK base incluye una búsqueda JNDI que no tiene efecto en Android.

Para eliminar la advertencia, configura tu `lint.xml` de la siguiente manera:

```xml
<lint>
    <issue id="InvalidPackage">
        <ignore path="**/sentry*.jar"/>
    </issue>
</lint>
```

Y en tu complemento de Gradle:

```groovy
android {
    lintOptions {
        lintConfig file("ruta/a/lint.xml")
    }
}
```

Donde `path/to/lint.xml` es la ruta al archivo de configuración de linting mencionado arriba.

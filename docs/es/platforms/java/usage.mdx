---
title: Uso
sidebar_order: 10
description: "Obtén más información sobre cómo pasar opciones de configuración al método estático Sentry#init de Sentry."
---

<div id="installation">
  ## Instalación
</div>

```xml {tabTitle:Maven}
<dependency>
    <groupId>io.sentry</groupId>
    <artifactId>sentry</artifactId>
    <version>{{@inject packages.version('sentry.java', '4.2.0') }}</version>
</dependency>
```

```groovy {tabTitle:Gradle}
implementation 'io.sentry:sentry:{{@inject packages.version('sentry.java', '4.2.0') }}'
```

```scala {tabTitle:SBT}
libraryDependencies += "io.sentry" % "sentry" % "{{@inject packages.version('sentry.java', '4.2.0') }}"
```

Para otros gestores de dependencias, consulta el [repositorio central de Maven](https://search.maven.org/artifact/io.sentry/sentry).

{/* <!--TODO - evaluar estas instrucciones de instalación. ¿Son más completas que las que ofrecemos actualmente en includes/getting-started-install/java.mdx? --> */}

<div id="configuration">
  ## Configuración
</div>

{/* <!--TODO - evaluar estos ejemplos de código. ¿Conviene simplificarlos? --> */}

Cuando se utiliza Sentry de manera manual, las opciones de configuración deben pasarse al método estático `Sentry#init`:

```java {tabTitle:Java}
import io.sentry.Sentry;

public class MyClass {
  public static void main(String... args) {
    Sentry.init(options -> {
      // NOTA: Reemplaza el DSN de prueba a continuación con TU PROPIO DSN para ver los eventos de esta aplicación en
      // tu proyecto/panel de Sentry
      options.setDsn("___PUBLIC_DSN___");

      // Todos los eventos se asignan a la versión. Más información en
      // https://docs.sentry.io/workflow/releases/
      options.setRelease("io.sentry.samples.console@4.2.0+1");

      // Modificaciones al evento antes de enviarse. Podría reemplazar el evento por completo
      options.setBeforeSend((event, hint) -> {
        // Descartar un evento por completo:
        if (event.getTag("SomeTag") != null) {
          return null;
        }
        return event;
      });

      // Permite inspeccionar y modificar, devolviendo uno nuevo o simplemente rechazándolo (devolviendo null)
      options.setBeforeBreadcrumb((breadcrumb, hint) -> {
        // No agregar breadcrumbs con mensajes que contengan:
        if (breadcrumb.getMessage() != null
            && breadcrumb.getMessage().contains("bad breadcrumb")) {
          return null;
        }
        return breadcrumb;
      });

      // Configura el worker en segundo plano que envía eventos a Sentry:
      // Espera hasta 5 segundos antes del cierre mientras haya eventos pendientes de envío.
      options.setShutdownTimeout(5000);

      // Habilita el registro del SDK con nivel Debug
      options.setDebug(true);
      // Para cambiar el nivel de detalle, usa:
      options.setDiagnosticLevel(
          // Por defecto es DEBUG.
          // Una buena opción para tener el registro de debug del SDK en producción es usar solo el nivel
          // ERROR aquí.
          SentryLevel.ERROR
      );

      // Excluye frames de algunos paquetes para que no sean "inApp" y estén ocultos por defecto en la
      // interfaz de Sentry:
      options.addInAppExclude("org.jboss");
    });
  }
}
```

```kotlin {tabTitle:Kotlin}
import io.sentry.SentryOptions.BeforeBreadcrumbCallback
import io.sentry.SentryOptions.BeforeSendCallback
import io.sentry.Hint

fun main() {
  Sentry.init { options ->
    // NOTA: Reemplaza el DSN de prueba a continuación con TU PROPIO DSN para ver los eventos de esta aplicación en
    // tu proyecto/panel de Sentry
    options.dsn = "___PUBLIC_DSN___"

    // Todos los eventos se asignan al release. Más información en
    // https://docs.sentry.io/workflow/releases/
    options.release = "io.sentry.samples.console@4.2.0+1"

    // Modificaciones al evento antes de enviarse. Podría reemplazar el evento por completo
    options.beforeSend = BeforeSendCallback { event: SentryEvent, hint: Hint ->
      // Descartar un evento por completo:
      if (event.getTag("SomeTag") != null) {
        null
      } else {
        event
      }
    }

    // Permite inspeccionar y modificar, devolver uno nuevo o simplemente rechazar (devolviendo null)
    options.beforeBreadcrumb = BeforeBreadcrumbCallback { breadcrumb: Breadcrumb, hint: Hint ->
      // No agregar breadcrumbs con mensajes que contengan:
      val message = breadcrumb.message
      if (message?.contains("bad breadcrumb") == true) {
        null
      } else {
        breadcrumb
      }
    }

    // Configurar el worker en segundo plano que envía eventos a Sentry:
    // Esperar hasta 5 segundos antes del cierre mientras haya eventos pendientes de envío.
    options.shutdownTimeout = 5000

    // Habilitar el registro del SDK con nivel Debug
    options.setDebug(true)
    // Para cambiar el nivel de detalle, usa:
    options.setDiagnosticLevel(
      // Por defecto es DEBUG.
      // Una buena opción para tener el registro de depuración del SDK en producción es usar solo el nivel ERROR aquí.
      SentryLevel.ERROR
    )

    // Excluir frames de algunos paquetes para que no sean "inApp" y estén ocultos por defecto en la
    // interfaz de Sentry:
    options.addInAppExclude("org.jboss")
  }
}
```

Encuentra más opciones de configuración en la sección [Configuración](/es/platforms/java/configuration/).

<div id="capture-an-error">
  ## Capturar un error
</div>

Para reportar un evento manualmente, debes inicializar la clase `Sentry`. Se recomienda usar la API estática a través de la clase `Sentry`. A continuación, se muestra un ejemplo:

```java
import io.sentry.Sentry;
import io.sentry.protocol.User;

public class MyClass {
  public static void main(String... args) {
    Sentry.init(options -> {
      options.setDsn("___PUBLIC_DSN___");
    });

    MyClass myClass = new MyClass();
    myClass.logWithStaticAPI();
  }

  /**
   * Un método de ejemplo que lanza una excepción.
   */
  void unsafeMethod() {
    throw new UnsupportedOperationException("¡No deberías llamar a esto!");
  }

  /**
   * Ejemplos usando la API estática (recomendada).
   */
  void logWithStaticAPI() {
    // Ten en cuenta que todos los campos establecidos en el scope son opcionales. Los datos del scope se copian a
    // todos los eventos futuros en el scope actual (hasta que se limpie el scope).

    // Registra un breadcrumb en el scope actual. Por defecto se mantienen los últimos 100 breadcrumbs.
    Sentry.addBreadcrumb("El usuario realizó una acción");

    // Establece el usuario en el scope actual.
    User user = new User();
    user.setEmail("hello@sentry.io");
    Sentry.setUser(user);

    // Agrega datos adicionales a eventos futuros en este scope.
    Sentry.setExtra("extra", "thing");

    // Agrega una etiqueta adicional a eventos futuros en este scope.
    Sentry.setTag("tagName", "tagValue");

    // Esto envía un evento simple a Sentry usando la instancia almacenada estáticamente
    // que fue creada en el método ``main``.
    Sentry.captureMessage("Esto es una prueba");

    try {
      unsafeMethod();
    } catch (Exception e) {
      // Esto envía un evento de excepción a Sentry usando la instancia almacenada estáticamente
      // que fue creada en el método ``main``.
      Sentry.captureException(e);
    }
  }
}
```

```kotlin
import io.sentry.Sentry
import io.sentry.SentryOptions
import io.sentry.protocol.User

class MyClass {
  fun main(args: Array<String>) {
    // NOTA: Reemplaza el DSN de prueba a continuación con TU PROPIO DSN
    Sentry.init { options ->
      options.dsn = "___PUBLIC_DSN___"
    }

    val myClass = MyClass()
    myClass.logWithStaticAPI()
  }

  /**
   * Un método de ejemplo que lanza una excepción.
   */
  fun unsafeMethod() {
    throw UnsupportedOperationException("¡No deberías llamar a esto!")
  }

  /**
   * Ejemplos usando la API estática (recomendada).
   */
  fun logWithStaticAPI() {
    // Ten en cuenta que todos los campos establecidos en el scope son opcionales. Los datos del scope se copian en
    // todos los eventos futuros del scope actual (hasta que se limpie el scope).

    // Registra un breadcrumb en el scope actual. Por defecto se conservan los últimos 100 breadcrumbs.
    Sentry.addBreadcrumb("El usuario realizó una acción")

    // Establece el usuario en el scope actual.
    val user = User().apply {
      email = "hello@sentry.io"
    }
    Sentry.setUser(user)

    // Agrega datos extra a eventos futuros en este scope.
    Sentry.setExtra("extra", "thing")

    // Agrega una etiqueta adicional a eventos futuros en este scope.
    Sentry.setTag("tagName", "tagValue")

    // Esto envía un evento simple a Sentry usando la instancia almacenada estáticamente
    // que se creó en el método ``main``.
    Sentry.captureMessage("Esto es una prueba")
    try {
      unsafeMethod()
    } catch (e: Exception) {
      // Esto envía un evento de excepción a Sentry usando la instancia almacenada estáticamente
      // que se creó en el método ``main``.
      Sentry.captureException(e)
    }
  }
}
```

<div id="building-more-complex-events">
  ### Creación de eventos más complejos
</div>

Para mensajes más complejos, deberás crear un objeto `SentryEvent`:

```java
import io.sentry.Sentry;
import io.sentry.SentryEvent;
import io.sentry.SentryLevel;
import io.sentry.protocol.Message;

public class MyClass {
  public static void main(String... args) {
    // NOTA: Reemplaza el DSN de prueba a continuación con TU PROPIO DSN
    Sentry.init(options -> {
      options.setDsn("___PUBLIC_DSN___");
    });
  }

  void unsafeMethod() {
    throw new UnsupportedOperationException("¡No deberías llamar a este método!");
  }

  void logSimpleMessage() {
    // Esto envía un evento a Sentry.
    SentryEvent event = new SentryEvent();
    Message message = new Message();
    message.setMessage("Esta es una prueba");
    event.setMessage(message);
    event.setLevel(SentryLevel.INFO);
    event.setLogger(MyClass.class.getName());

    Sentry.captureEvent(event);
  }

  void logException() {
    try {
      unsafeMethod();
    } catch (Exception e) {
      // Esto envía un evento de excepción a Sentry.
      SentryEvent event = new SentryEvent();
      Message message = new Message();
      message.setMessage("Excepción capturada");
      event.setMessage(message);
      event.setLevel(SentryLevel.INFO);
      event.setLogger(MyClass.class.getName());
      event.setThrowable(e);

      Sentry.captureEvent(event);
    }
  }
}
```

```kotlin
import io.sentry.Sentry
import io.sentry.SentryEvent
import io.sentry.SentryLevel
import io.sentry.protocol.Message

class MyClass {

  fun main(args: Array<String>) {
    // NOTA: Reemplaza el DSN de prueba a continuación con TU PROPIO DSN
    Sentry.init { options ->
      options.dsn = "___PUBLIC_DSN___"
    }
  }

  fun unsafeMethod() {
    throw UnsupportedOperationException("¡No deberías llamar esto!")
  }

  fun logSimpleMessage() {
    // Esto envía un evento a Sentry.
    val event = SentryEvent().apply {
      message = Message().apply {
        message = "Esta es una prueba"
      }
      level = SentryLevel.INFO
      logger = MyClass::class.java.name
    }
    Sentry.captureEvent(event)
  }

  fun logException() {
    try {
      unsafeMethod()
    } catch (e: Exception) {
      // Esto envía un evento de excepción a Sentry.
      val event = SentryEvent().apply {
        message = Message().apply {
          message = "Excepción capturada"
        }
        level = SentryLevel.INFO
        logger = MyClass::class.java.name
        throwable = e
      }
      Sentry.captureEvent(event)
    }
  }
}
```

<div id="automatically-enhancing-events">
  ### Mejora automática de eventos
</div>

También puedes implementar un `EventProcessor` que mejore automáticamente los eventos salientes.

```java
import io.sentry.EventProcessor;
import io.sentry.Sentry;
import io.sentry.SentryEvent;
import io.sentry.Hint
import io.sentry.protocol.Message;

public class MyClass {
  public void myMethod() {
    // Agrega un `EventProcessor` al scope actual. Ten en cuenta que
    // este helper procesará *todos* los eventos futuros en este scope.
    Sentry.configureScope(scope -> {
      scope.addEventProcessor(new EventProcessor() {
        @Override
        public SentryEvent process(SentryEvent event, Hint hint) {
          Message message = new Message();
          message.setMessage("¡Sobrescrito por myEventBuilderHelper!");
          event.setMessage(message);
          return event;
        }
      });
    });

    // Envía un evento a Sentry. Durante la construcción del evento, el cuerpo
    // del mensaje será sobrescrito por el procesador de eventos.
    Sentry.captureMessage("¡Hola, mundo!");
  }
}
```

```kotlin
import io.sentry.Sentry
import io.sentry.Hint
import io.sentry.protocol.Message

class MyClass {
  fun myMethod() {
    // Agrega un `EventProcessor` al scope actual. Ten en cuenta que
    // este helper procesará *todos* los eventos futuros en este scope.
    Sentry.configureScope { scope ->
      scope.addEventProcessor(object: EventProcessor {
        override fun process(event: SentryEvent, hint: Hint): SentryEvent? {
          event.message = Message().apply {
            message = "¡Sobrescrito por myEventBuilderHelper!"
          }
          return event
        }
      })
    }

    // Envía un evento a Sentry. Durante la construcción del evento, el cuerpo
    // del mensaje será sobrescrito por el procesador de eventos.
    Sentry.captureMessage("¡Hola, mundo!")
  }
}
```

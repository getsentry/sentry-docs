---
title: Configurar registros en Rust
sidebar_title: Registros
description: "Los registros estructurados te permiten enviar, ver y consultar registros de tus aplicaciones en Sentry."
sidebar_order: 5600
---

Con Sentry Structured Logs, puedes enviar registros de texto desde tus aplicaciones a Sentry. Una vez en Sentry, estos registros pueden verse junto con errores relacionados, buscarse por texto o consultarse usando sus atributos individuales.

<div id="requirements">
  ## Requisitos
</div>

Los logs en Rust son compatibles a partir de la versión `0.42.0` del SDK de Sentry para Rust.
Además, es necesario habilitar la flag de función `logs`.

```toml {filename:Cargo.toml}
[dependencies]
sentry = { version = "{{@inject packages.version('sentry.rust') }}", features = ["logs"] }
```


<div id="setup">
  ## Configuración
</div>

Para habilitar los registros, simplemente agrega la dependencia `sentry` con la marca de característica `logs`.
Esto establecerá `enable_logs: true` de forma predeterminada en `sentry::ClientOptions`.
Puedes desactivar el envío de registros incluso usando la marca de característica `logs` inicializando explícitamente el SDK con `enable_logs: false`.

<div id="usage">
  ## Uso
</div>

Una vez que la función esté habilitada y el SDK inicializado, puedes enviar registros usando las macros de logging.
El crate `sentry` expone macros que admiten seis niveles de log:
`logger_trace`, `logger_debug`, `logger_info`, `logger_warn`, `logger_error` y `logger_fatal`.
Las macros permiten registrar un mensaje simple o un mensaje con parámetros, usando la sintaxis de `format`:

```rust
use sentry::logger_info;

logger_info!("¡Hola, mundo!");
logger_info!("¡Hola, {}!", "mundo");
```

También puedes añadir atributos adicionales a un log usando la sintaxis `key = value` antes del mensaje:

```rust
use sentry::logger_error;

logger_error!(
    database.host = "prod-db-01",
    database.port = 5432,
    database.name = "user_service",
    retry_attempt = 2,
    beta_features = false,
    "Error al conectar con la base de datos"
);
```

Las claves de atributo admitidas pueden ser cualquier cantidad de identificadores válidos de Rust, separados por puntos.
Los atributos que contengan puntos se anidarán bajo su prefijo común cuando se muestren en la interfaz de usuario.

Los valores de atributo admitidos corresponden a aquellos que pueden convertirse en un `serde_json::Value`,
lo que incluye tipos primitivos numéricos, `bool` y tipos de cadena.
A día de hoy, los tipos de arreglo y de objeto se convertirán en cadenas usando su representación JSON.


<div id="integrations">
  ## Integraciones
</div>

<div id="tracing-integration">
  ### Integración de `tracing`
</div>

Para usar la integración de `tracing` con registros, agrega las dependencias necesarias en tu `Cargo.toml`.

```toml {filename:Cargo.toml}
[dependencias]
sentry = { version = "{{@inject packages.version('sentry.rust') }}", features = ["tracing", "logs"] }
tracing = "0.1.41"
tracing-subscriber = "0.3.19"
```

Luego, usa las macros estándar de `tracing` para capturar logs.

```rust {filename:main.rs}
use sentry::integrations::tracing::EventFilter;
use tracing::{error, info, warn};
use tracing_subscriber::prelude::*;

fn main() {
    let _guard = sentry::init((
        "___PUBLIC_DSN___",
        sentry::ClientOptions {
            release: sentry::release_name!(),
            enable_logs: true,
            ..Default::default()
        },
    ));

    tracing_subscriber::registry()
        .with(tracing_subscriber::fmt::layer())
        .with(sentry::integrations::tracing::layer())
        .init();

    info!("¡Hola, mundo!");

    warn!(
        database.host = "prod-db-01",
        database.port = 5432,
        retry_attempt = 2,
        "La conexión a la base de datos es lenta"
    );

    error!(error_code = 500, "Fallo crítico del sistema");
}
```

Los campos de los eventos de `tracing` se capturan automáticamente como atributos en los registros de Sentry.

De forma predeterminada, los eventos de `tracing` de nivel info o superior se capturan como registros de Sentry.

Este comportamiento se puede personalizar aplicando un `event_filter` personalizado al crear la capa.
El siguiente fragmento muestra el `event_filter` predeterminado que se aplica al usar el crate `sentry` con la marca de característica `logs`.

```rust
use sentry::integrations::tracing::EventFilter;

let sentry_layer =
    sentry::integrations::tracing::layer().event_filter(|md| match *md.level() {
        // Registra los eventos de nivel error y warn como logs y eventos en Sentry
        tracing::Level::ERROR => EventFilter::Event | EventFilter::Log,
        // Ignora los eventos de nivel trace, ya que son demasiado verbosos
        tracing::Level::TRACE => EventFilter::Ignore,
        // Capture everything else as both a breadcrumb and a log
        // Registra todo lo demás como breadcrumb y log
    });
```


<div id="log-integration">
  ### Integración de `log`
</div>

Para usar la integración `log` con los logs, agrega las dependencias necesarias a tu `Cargo.toml`.

```toml {filename:Cargo.toml}
[dependencies]
sentry = { version = "{{@inject packages.version('sentry.rust') }}", features = ["log", "logs"] }
log = "0.4"
# opcional: usa cualquier implementación de logging que prefieras
env_logger = "0.11"
```

Luego, usa las macros estándar de `log` para capturar los registros.

```rust {filename:main.rs}
use sentry_log::LogFilter;
use log::{info, warn, error};

fn main() {
    let _guard = sentry::init((
        "___PUBLIC_DSN___",
        sentry::ClientOptions {
            release: sentry::release_name!(),
            enable_logs: true,
            ..Default::default()
        },
    ));

    let logger = sentry::integrations::log::SentryLogger::with_dest(
        env_logger::Builder::from_default_env().build(),
    );
    log::set_boxed_logger(Box::new(logger)).unwrap();
    log::set_max_level(log::LevelFilter::Trace);

    info!("¡Hola, mundo!");
    warn!("Conexión lenta a la base de datos");
    error!("Fallo crítico del sistema");
}
```


<div id="additional-integrations">
  ### Integraciones adicionales
</div>

Siempre buscamos ampliar la compatibilidad de Logs con más integraciones.
Si te gustaría que se admitieran bibliotecas de registro adicionales, abre un [issue nuevo](https://github.com/getsentry/sentry-rust/issues/new/choose) con tu solicitud.

<div id="options">
  ## Opciones
</div>

<div id="before_send_log">
  ### `before_send_log`
</div>

Para filtrar los logs o modificarlos antes de enviarlos a Sentry, puedes usar la opción del cliente `before_send_log`.

```rust
let _guard = sentry::init(("___PUBLIC_DSN___", sentry::ClientOptions {
    release: sentry::release_name!(),
    enable_logs: true,
    before_send_log: Some(std::sync::Arc::new(|log| {
        // filtra todos los registros de nivel trace
        if log.level == sentry::protocol::LogLevel::Trace {
            return None;
        }
        Some(log)
    })),
    ..Default::default()
}));
```


<div id="default-attributes">
  ## Atributos predeterminados
</div>

El SDK de Rust establece automáticamente varios atributos predeterminados en todas las entradas de log para aportar contexto y facilitar la depuración:

<Include name="logs/default-attributes/core" />

<Include name="logs/default-attributes/message-template" />

<Include name="logs/default-attributes/server" />

<Include name="logs/default-attributes/user" />

<Include name="logs/default-attributes/integration" />
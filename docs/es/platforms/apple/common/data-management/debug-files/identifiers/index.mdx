---
title: Identificadores de depuración
description: "Obtén información sobre los requisitos de las herramientas de compilación que permiten a Sentry identificar de forma única los archivos de información de depuración entre compilaciones."
sidebar_order: 2
---

Cada archivo de información de depuración especifica un identificador único. Los informes de fallos declaran
estos identificadores para permitir que los depuradores y los sistemas de reporte de fallos resuelvan los
archivos correctos. Sentry distingue dos tipos de identificadores:

* **Identificador de código**: El identificador único del ejecutable o la biblioteca
  dinámica —es decir, el archivo de código—. El contenido de este identificador depende de la plataforma:
  los archivos Mach-O usan un UUID, los archivos ELF un hash SHA y los archivos PE usan
  una concatenación de ciertos atributos del encabezado. Para WebAssembly, usamos un
  UUID incrustado en la sección `build_id` del archivo.

* **Identificador de depuración**: El identificador único del archivo de depuración complementario. En
  contraste con el identificador de código, Sentry impone la misma estructura en todas las
  plataformas. En Windows, es el identificador único real del archivo PDB; en todas
  las demás plataformas, es una transformación con pérdida del identificador de código.

Al cargar archivos de información de depuración en Sentry, la CLI y el servidor siempre
calcularán un *Identificador de depuración* para cada archivo cargado. Este identificador se
asocia con ejecutables y bibliotecas, así como con sus archivos de depuración complementarios, para garantizar
que puedan ubicarse de forma única mediante un mecanismo común.

<Alert>
  La información de depuración no tiene que estar asociada con versiones. El identificador de depuración
  único garantiza que Sentry pueda elegir los archivos correctos para cada informe
  de fallos. Sin embargo, sigue siendo recomendable configurar versiones en el cliente para
  aprovechar otras funciones.
</Alert>

Para eventos nativos, la página de detalles del issue muestra una lista de *Imágenes cargadas*.
Esta lista incluye el ejecutable y todas las bibliotecas dinámicas cargadas, junto con
sus identificadores de depuración. Puedes copiar este identificador y buscar los archivos exactos
que coincidan con él en la pantalla de configuración de *Archivos de depuración*.

`sentry-cli` puede ayudar a mostrar propiedades de los archivos de información de depuración, como su
identificador de depuración. Consulta [*Comprobación de archivos de información de depuración*](/es/cli/dif/#checking-files) para obtener más información.

<div id="gnu-build-identifiers">
  ## Identificadores de compilación GNU
</div>

Para archivos ELF en Linux, Sentry utiliza el identificador de compilación GNU para calcular el
identificador de depuración. Todos los compiladores y enlazadores recientes admiten la emisión de
IDs de compilación, pero a veces pueden requerir configuración adicional. `gcc` lo hace
de forma predeterminada; para `clang`, usa una de las siguientes opciones:

* `--build-id=uuid` para un identificador aleatorio rápido pero no reproducible.
* `--build-id=sha1` para un identificador más lento pero reproducible generado
  al aplicar un hash a la primera página de la sección de código.

*El identificador debe estar presente e idéntico tanto en el binario como en los
archivos de información de depuración separados.* Si falta el ID por alguna razón,
sube los archivos antes de separar la depuración para que `sentry-cli` pueda calcular un
identificador estable a partir del archivo sin separar.

<div id="pdb-age-mismatches">
  ## Desajustes de edad de PDB
</div>

Los PDB de Microsoft forman sus identificadores a partir de dos partes: una firma única y
un campo de edad. La firma se genera cuando el PDB se escribe por primera vez y
por lo general cambia con cada compilación. La edad es un contador que se incrementa cada
vez que se modifica el PDB.

Los archivos PE, como los ejecutables y las bibliotecas dinámicas, especifican el identificador completo
del PDB correspondiente en su encabezado. Esto incluye la edad. Sin embargo, si el PDB se
modifica después de que se haya generado el PE, su edad podría diferir. Esto
puede dar lugar a identificadores distintos:

```
PE:  3003763b-afcb-4a97-aae3-28de8f188d7c-2
PDB: 3003763b-afcb-4a97-aae3-28de8f188d7c-4
```

`sentry-cli` puede detectar estas diferencias durante el proceso de carga y
asocia el mismo identificador a ambos archivos. Sin embargo, esto requiere que ambos
archivos se carguen en la misma ejecución del comando de carga. De lo contrario, los
identificadores divergen y Sentry podría no ser capaz de resolver el archivo correcto
para la simbolización.

<div id="wasm-build-ids">
  ## IDs de compilación de WASM
</div>

[WebAssembly admite IDs de compilación](https://github.com/WebAssembly/tool-conventions/blob/main/BuildId.md) como
[sección personalizada](https://webassembly.github.io/spec/core/binary/modules.html#custom-section).

`LLVM` (y, con él, la correspondiente cadena de herramientas `emscripten`) admite esto [desde la versión 17](https://github.com/llvm/llvm-project/commit/c7af9ae577bb04c5fe120fc07844a500818c8f47).

Nuestra herramienta [`wasm-split`](https://github.com/getsentry/symbolicator/tree/master/crates/wasm-split)
también puede usarse para añadir un ID de compilación si tu toolchain aún no lo admite. También te permite
dividir y extraer información de depuración de tu archivo `*.wasm`.

<div id="proguard-uuids">
  ## UUID de ProGuard
</div>

A diferencia de otros archivos de información de depuración, los archivos de ProGuard no tienen un identificador único intrínseco. Sentry CLI les asigna un UUID SHA1 basado en la suma de comprobación del archivo. Puedes usar `sentry-cli debug-files check` en un archivo de ProGuard para ver el UUID generado.

Si necesitas generar el UUID tú mismo, puedes hacerlo con el siguiente algoritmo (código en Python como referencia):

```python
import uuid

NAMESPACE = uuid.uuid5(uuid.NAMESPACE_DNS, "guardsquare.com")

def get_proguard_uuid(filename):
    with open(filename, 'rb') as f:
        return uuid.uuid5(NAMESPACE, f.read())
```

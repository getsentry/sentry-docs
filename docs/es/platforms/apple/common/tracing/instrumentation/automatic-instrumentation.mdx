---
title: Instrumentación automática
sidebar_order: 10
description: Aprende qué transacciones se capturan después de habilitar el tracing.
og_image: >-
  /og-images/platforms-apple-common-tracing-instrumentation-automatic-instrumentation.png
---

<Alert>
  Una vez que <PlatformLink to="/tracing/">configures el tracing</PlatformLink>, el SDK habilita las siguientes funciones de forma predeterminada:

  * Tracing de UIViewController
  * Tracing del inicio de la app
  * Fotogramas lentos y congelados
  * Seguimiento de red
  * Tracing de E/S de archivos
  * Tracing de Core Data
  * Tracing de interacción del usuario
</Alert>

<div id="uiviewcontroller-tracing">
  ## Seguimiento de UIViewController
</div>

Esta función está disponible para iOS, tvOS y Mac Catalyst, está habilitada de forma predeterminada y funciona para `UIViewControllers`.

El seguimiento de UIViewController se habilita de forma predeterminada una vez que <PlatformLink to="/tracing/">configuras el tracing</PlatformLink>. Esta función captura transacciones cuando tu app carga un [UIViewController][UIViewController] dentro de la aplicación. Sin embargo, el SDK no captura transacciones para `UIViewControllers` de bibliotecas de terceros ni para SwiftUI.
El SDK establece el nombre de la transacción como el nombre del ViewController, incluido el módulo —por ejemplo, `Your_App.MainViewController`— y la operación de la transacción como `ui.load`.

El SDK crea spans para ofrecer información sobre el tiempo consumido por cada uno de los métodos que se muestran en la captura a continuación. Debido a limitaciones de implementación, el SDK solo agrega un span para loadView si el view controller instrumentado lo implementa. El SDK agrega spans para todos los demás métodos, los implementes o no en tu view controller.

![Transacción de UIViewController](./img/ui-view-controller-transaction.png)

<div id="nested-view-controllers">
  ### Controladores de vista anidados
</div>

El SDK establece una relación padre-hijo para `UIViewController` anidados, comenzando con el primer `UIViewController` que carga tu app. Si no hay una transacción activa en el ámbito, el SDK iniciará una nueva transacción de `UIViewController` y la asociará al ámbito, a menos que ya exista en el ámbito una transacción de [interacción del usuario](#user-interaction-tracing); en ese caso, primero se cerrará y se eliminará.

Mientras haya una transacción de `UIViewController` activa en el ámbito, el SDK añadirá cualquier nuevo span de `UIViewController` como span hijo de esa transacción activa. Esto crea una vista unificada de todos los `UIViewController` en una pantalla dentro de una sola transacción.

Si otra transacción ya está asociada al ámbito (por ejemplo, si se configuró manualmente), el SDK no podrá asociar una nueva transacción de `UIViewController` al ámbito. Esto significa que la nueva transacción funcionará, pero no capturará otros spans autogenerados, como HTTP, E/S de archivos o Core Data, que solo pueden añadirse a transacciones asociadas al ámbito.

Para desactivar el tracing de `UIViewController`:

```swift {tabTitle:Swift}
import Sentry

SentrySDK.start { options in
    options.dsn = "___PUBLIC_DSN___"
    options.enableUIViewControllerTracing = false

    // Antes de la 8.0.0
    options.enableUIViewControllerTracking = false
}
```

```objc {tabTitle:Objective-C}
@import Sentry;

[SentrySDK startWithConfigureOptions:^(SentryOptions *options) {
    options.dsn = @"___PUBLIC_DSN___";
    options.enableUIViewControllerTracing = NO;


    // Antes de la versión 8.0.0
    options.enableUIViewControllerTracking = NO;
}];
```

Puedes desactivar el rastreo para UIViewControllers específicos configurando <PlatformLink to="/configuration/swizzling#skip-swizzling-for-specific-classes">`swizzleClassNameExcludes`</PlatformLink>:

```swift {tabTitle:Swift}
import Sentry

SentrySDK.start { options in
    options.swizzleClassNameExcludes = [
      "MyUIViewController",
    ]
}
```

```objc {tabTitle:Objective-C}
@import Sentry;

[SentrySDK startWithConfigureOptions:^(SentryOptions *options) {
    options.swizzleClassNameExcludes = [NSSet setWithObjects:
      @"MyUIViewController",
      nil
    ];
}];
```

[UIViewController]: https://developer.apple.com/documentation/uikit/uiviewcontroller

<div id="app-start-tracing">
  ## Rastreo del inicio de la app
</div>

Esta función está disponible para iOS, tvOS y Mac Catalyst.

El rastreo del inicio de la app se activa de forma predeterminada una vez que <PlatformLink to="/tracing/">configuras el rastreo</PlatformLink>. Esta función ofrece información sobre cuánto tarda tu aplicación en iniciarse. Agrega spans para distintas fases, desde el lanzamiento de la aplicación hasta la primera transacción de UI autogenerada.

El SDK agrega estos spans a la primera transacción que comienza durante el inicio de la app con la operación `ui.load`, que es la que utiliza el rastreo de UIViewController. Si la duración entre la hora de inicio de la transacción y la marca de tiempo de finalización del inicio de la app supera los 5 segundos, el SDK no adjunta los spans del inicio de la app. Esto ayuda a evitar adjuntarlos a transacciones no relacionadas. Para habilitar esta función, activa `enableAutoPerformanceTracing`.

El SDK distingue entre inicio en frío e inicio en caliente, pero no rastrea inicios/reanudaciones en “hot”.

* **Inicio en frío**: La app se inicia por primera vez, después de un reinicio o actualización. La app no está en memoria y no existe ningún proceso.
* **Inicio en caliente**: La app se ha iniciado al menos una vez, está parcialmente en memoria y no existe ningún proceso.

<Alert>
  La instrumentación de App Start de Sentry busca ser lo más completa y representativa posible de la experiencia del usuario, y se adhiere a las directrices de los proveedores de la plataforma. Por esta razón, los inicios de app reportados por Sentry pueden ser más largos que lo que ves en otras herramientas.

  Por ejemplo, Sentry mide la duración desde el inicio del proceso —incluido el tiempo previo a la inicialización del runtime y antes de que se cargue el primer objeto de la aplicación— hasta que se renderiza el primer frame para el usuario.
</Alert>

El SDK de Cocoa crea los siguientes spans de inicio de la app:

* **Pre Runtime Init**: desde el inicio del proceso hasta la inicialización del runtime.
* **Runtime Init to Pre Main Initializers**: desde la inicialización del runtime hasta los inicializadores previos a main.
* **UIKit Init**: desde los inicializadores previos a main hasta el momento en que se inicia el SDK de Sentry Cocoa.
* **Application Init**: refleja la duración del método `application:didFinishLaunchingWithOptions` de tu AppDelegate o del [inicializador del conformer de App](https://developer.apple.com/documentation/swiftui/app/main\(\)) cuando usas SwiftUI, que va desde que se inicia el SDK de Cocoa hasta la [`didFinishLaunchingNotification`][didfinishlaunching].
* **Initial Frame Render**: desde la [`didFinishLaunchingNotification`][didfinishlaunching] hasta [`UIWindowDidBecomeVisibleNotification`][uiwindow]. Al habilitar la opción `enablePerformanceV2`, va desde la [`didFinishLaunchingNotification`][didfinishlaunching] hasta que la app renderiza su primer frame.

![Transacción de inicio de la app](./img/app-start-transaction.png)

Los inicios en frío y en caliente son Mobile Vitals, sobre los que puedes aprender en la [documentación completa](/es/product/insights/mobile/mobile-vitals).

<div id="prewarmed-app-start-tracing">
  ### Rastreo de inicio de app precalentada
</div>

A partir de iOS 15, el sistema operativo puede [precalentar](https://developer.apple.com/documentation/uikit/app_and_environment/responding_to_the_launch_of_your_app/about_the_app_launch_sequence#3894431) tu app creando el proceso antes de que el usuario la abra. Habilita la función `enablePreWarmedAppStartTracing` para recopilar inicios de app precalentados, lo cual estará habilitado de forma predeterminada en la V9.

Cuando el SO precalienta el proceso de tu app, realiza de antemano algunos pasos de inicialización de un inicio normal, antes de que el usuario toque el ícono de la app. Esto puede ocurrir desde segundos hasta minutos u horas antes de que tu app se inicie por completo. Por lo tanto, el SDK no agrega los spans **Pre Runtime Init** y **Runtime Init to Pre Main Initializers**. Este enfoque acorta la duración del inicio de la app, pero representa el tiempo desde que un usuario toca el ícono de la app hasta que la app responde.

Con esta función, el SDK distingue cuatro tipos de inicio de app, que agrega al contexto de la transacción:

* **Inicio en frío no precalentado** (Consulta la definición de *inicio en frío* arriba.)
* **Inicio en caliente no precalentado** (Consulta la definición de *inicio en caliente* arriba.)
* **Inicio en frío precalentado**
* **Inicio en caliente precalentado**

Puedes filtrar por diferentes tipos de inicio de app en [Discover](/es/product/explore/discover-queries/) con `app_start_type:cold.prewarmed`, `app_start_type:warm.prewarmed`, `app_start_type:cold` y `app_start_type:warm`.

Para habilitar el rastreo de inicio de app precalentada:

```swift {tabTitle:Swift}
import Sentry

SentrySDK.start { options in
    options.dsn = "___PUBLIC_DSN___"
    options.enablePreWarmedAppStartTracing = true
}
```

```objc {tabTitle:Objective-C}
@import Sentry;

[SentrySDK startWithConfigureOptions:^(SentryOptions *options) {
    options.dsn = @"___PUBLIC_DSN___";
    options.enablePreWarmedAppStartTracing = YES;
}];
```

<div id="slow-and-frozen-frames">
  ## Fotogramas lentos y congelados
</div>

Esta función está disponible para iOS, tvOS y Mac Catalyst.

Los fotogramas lentos y congelados se habilitan de forma predeterminada una vez que <PlatformLink to="/tracing/">configuras el tracing</PlatformLink>. Una interfaz que no responde y los tirones en las animaciones molestan a los usuarios y degradan la experiencia. Dos métricas para medir este tipo de experiencias son los *fotogramas lentos* y los *fotogramas congelados*. Si quieres que tu app funcione con fluidez, deberías intentar evitar ambos. El SDK añade estas dos métricas a las transacciones que capturas.

La vista de detalle de la transacción muestra los fotogramas lentos, los congelados y el total de fotogramas:

![Fotogramas lentos y congelados](./img/slow-frozen-frames.png)

Los fotogramas lentos y congelados forman parte de Mobile Vitals, sobre lo que puedes aprender más en la [documentación completa](/es/product/insights/mobile/mobile-vitals).

<div id="network-tracking">
  ## Seguimiento de red
</div>

El seguimiento de red se habilita de forma predeterminada cuando <PlatformLink to="/tracing/">configuras el tracing</PlatformLink>. El SDK de Sentry añade spans de las solicitudes HTTP salientes a las transacciones en curso vinculadas al Scope. Actualmente, el SDK admite solicitudes con [NSURLSession][NSURLSession], pero no con la solución heredada [NSURLConnection][NSURLConnection].

Para desactivar la instrumentación de HTTP:

```swift {tabTitle:Swift}
import Sentry

SentrySDK.start { options in
    options.dsn = "___PUBLIC_DSN___"
    options.enableNetworkTracking = false
}
```

```objc {tabTitle:Objective-C}
@import Sentry;

[SentrySDK startWithConfigureOptions:^(SentryOptions *options) {
    options.dsn = @"___PUBLIC_DSN___";
    options.enableNetworkTracking = NO;
}];
```

[NSURLSession]: https://developer.apple.com/documentation/foundation/nsurlsession

[NSURLConnection]: https://developer.apple.com/documentation/foundation/nsurlconnection

<div id="trace-propagation-targets">
  ### Destinos de propagación de trazas
</div>

Sentry agrega un encabezado adicional con el id de la traza en las solicitudes HTTP salientes para continuar la transacción en el backend.

Puedes configurar la opción `tracePropagationTarget` para filtrar a qué solicitudes Sentry agrega el encabezado adicional.
Por ejemplo, para asegurarte de que solo el backend de tu aplicación reciba el id de la traza.

```swift {tabTitle:Swift}
import Sentry

SentrySDK.start { options in
    options.dsn = "___PUBLIC_DSN___"
    options.tracePropagationTargets = ["MyAppDomain.com"]
}
```

```objc {tabTitle:Objective-C}
@import Sentry;

[SentrySDK startWithConfigureOptions:^(SentryOptions *options) {
    options.dsn = @"___PUBLIC_DSN___";
    options.tracePropagationTargets = @[@"MiDominioDeApp.com"]
}];
```

La opción puede incluir una lista de `NSString` o `NSRegularExpression` con la que se comparan las URL de las solicitudes salientes. Si alguno de los elementos de la lista coincide con la URL de una solicitud saliente, se adjuntarán datos de traza a esa solicitud. Las entradas de tipo cadena no tienen que coincidir por completo: la URL de una solicitud se considera coincidente cuando contiene una cadena proporcionada mediante la opción.

Si no se proporciona `tracePropagationTargets`, se adjuntarán datos de traza a todas las solicitudes salientes del cliente instrumentado.

<div id="file-io-tracing">
  ## Seguimiento de E/S de archivos
</div>

El SDK de Sentry agrega spans para las operaciones de E/S de archivos a las transacciones en curso vinculadas al scope. Actualmente, el SDK admite operaciones con [NSData][NSData], pero muchas otras API como [NSFileManager][NSFileManager], [NSString][NSString] y [NSBundle][NSBundle] utilizan [NSData][NSData].

Desde la versión 8.0.0, esta función está habilitada de forma predeterminada para el seguimiento de operaciones de `NSData`. Para deshabilitarla:

```swift {tabTitle:Swift}
import Sentry

SentrySDK.start { options in
    options.dsn = "___PUBLIC_DSN___"
    options.enableFileIOTracing = false

    // Antes de la versión 8.0.0
    options.enableFileIOTracking = false
}
```

```objc {tabTitle:Objective-C}
@import Sentry;

[SentrySDK startWithConfigureOptions:^(SentryOptions *options) {
    options.dsn = @"___PUBLIC_DSN___";
    options.enableFileIOTracing = NO;

    // Antes de la versión 8.0.0
    options.enableFileIOTracking = NO;
}];
```

A partir de iOS 18, macOS 15 y tvOS 18, `NSFileManager` ya no se basa en `NSData` y debe swizzlearse directamente.
Esta característica es experimental y está desactivada de forma predeterminada.
Para usar el trazado automático de E/S de archivos con `NSFileManager`, debes activarlo:

```swift {tabTitle:Swift}
import Sentry

SentrySDK.start { options in
    options.dsn = "___PUBLIC_DSN___"
    options.enableFileIOTracing = true
    options.experimental.enableFileManagerSwizzling = true
}
```

```objc {tabTitle:Objective-C}
@import Sentry;

[SentrySDK startWithConfigureOptions:^(SentryOptions *options) {
    options.dsn = "___PUBLIC_DSN___"
    options.enableFileIOTracing = YES;
    options.experimental.enableFileManagerSwizzling = YES;
}];
```

A partir de iOS 18, tvOS 18 y macOS 15, las clases de Swift `Data` y `FileManager` ya no están respaldadas por sus equivalentes en Objective-C, `NSData` y `NSFileManager`, y por lo tanto ya no pueden instrumentarse automáticamente. En su lugar, utiliza el [trazado manual de E/S de archivos](#manual-fileio-tracing).

[NSData]: https://developer.apple.com/documentation/foundation/nsdata

[NSFileManager]: https://developer.apple.com/documentation/foundation/nsfilemanager

[NSString]: https://developer.apple.com/documentation/foundation/nsstring

[NSBundle]: https://developer.apple.com/documentation/foundation/nsbundle

<div id="manual-fileio-tracing">
  ### Trazado manual de archivos/E/S
</div>

A partir de la versión 8.48.0, el SDK de Sentry ofrece extensiones para los tipos `Data` y `FileManager` que permiten rastrear la lectura y escritura de datos, así como la creación, el movimiento, la copia y la eliminación de archivos.

Las firmas de los métodos de la extensión se asemejan a las de los tipos originales, pero añaden un span a la transacción actual:

**Operaciones con Data:**

* `Data.init(contentsOfUrlWithSentryTracing:)` para `Data(contentsOf:)`
* `data.writeWithSentryTracing(to:options:)` para `data.write(to:)`

```swift {tabTitle:Swift}
// Leer datos de una URL de archivo
let data = Data(contentsOfUrlWithSentryTracing: url)

// Escribir datos en una URL de archivo
data.writeWithSentryTracing(to: url)
```

**Operaciones de FileManager:**

* `FileManager.createFileWithSentryTracing(atPath:contents:attributes:)` en lugar de `FileManager.createFile(atPath:contents:attributes:)`
* `FileManager.moveItemWithSentryTracing(at:to:)` en lugar de `FileManager.moveItem(at:to:)`
* `FileManager.moveItemWithSentryTracing(atPath:toPath:)` en lugar de `FileManager.moveItem(atPath:toPath:)`
* `FileManager.copyItemWithSentryTracing(at:to:)` en lugar de `FileManager.copyItem(at:to:)`
* `FileManager.copyItemWithSentryTracing(atPath:toPath:)` en lugar de `FileManager.copyItem(atPath:toPath:)`
* `FileManager.removeItemWithSentryTracing(at:)` en lugar de `FileManager.removeItem(at:)`
* `FileManager.removeItemWithSentryTracing(atPath:)` en lugar de `FileManager.removeItem(atPath:)`

```swift {tabTitle:Swift}
let fileManager = FileManager.default

// Crear un archivo con el contenido indicado
fileManager.createFileWithSentryTracing(atPath: path, contents: data)

// Mover un archivo o un directorio
try fileManager.moveItemWithSentryTracing(at: sourceUrl, to: destinationUrl)
try fileManager.moveItemWithSentryTracing(atPath: sourcePath, toPath: destinationPath)

// Copiar un archivo o un directorio
try fileManager.copyItemWithSentryTracing(at: sourceUrl, to: destinationUrl)
try fileManager.copyItemWithSentryTracing(atPath: sourcePath, toPath: destinationPath)

// Eliminar un archivo o un directorio
try fileManager.removeItemWithSentryTracing(at: url)
try fileManager.removeItemWithSentryTracing(atPath: path)
```

Recomendamos desactivar el swizzling de `NSData` y `NSFileManager` cuando uses el rastreo manual de E/S de archivos, ya que el comportamiento interno de estas clases varía entre versiones de la plataforma y puede provocar spans duplicados en tus trazas.

```swift {tabTitle:Swift}
import Sentry

SentrySDK.start { options in
    options.dsn = "___PUBLIC_DSN___";
    options.enableFileIOTracing = true
    options.experimental.enableDataSwizzling = false
    options.experimental.enableFileManagerSwizzling = false
}
```

```objc {tabTitle:Objective-C}
@import Sentry;

[SentrySDK startWithConfigureOptions:^(SentryOptions *options) {
    options.dsn = @"___PUBLIC_DSN___";
    options.enableFileIOTracing = YES;
    options.experimental.enableDataSwizzling = NO;
    options.experimental.enableFileManagerSwizzling = NO;
}];
```

<div id="core-data-tracing">
  ## Rastreo de Core Data
</div>

El SDK de Sentry agrega spans de las operaciones de Core Data a las transacciones activas vinculadas al scope. Actualmente, el SDK admite las operaciones de fetch y save con [NSManagedObjectContext](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext).
Desde la versión 8.0.0, esta función está habilitada de forma predeterminada. Para desactivarla:

```swift {tabTitle:Swift}
import Sentry

SentrySDK.start { options in
    options.dsn = "___PUBLIC_DSN___"
    options.enableCoreDataTracing = false

    // Antes de la 8.0.0
    options.enableCoreDataTracking = false
}
```

```objc {tabTitle:Objective-C}
@import Sentry;

[SentrySDK startWithConfigureOptions:^(SentryOptions *options) {
    options.dsn = @"___PUBLIC_DSN___";
    options.enableCoreDataTracing = NO;

    // Antes de la 8.0.0
    options.enableCoreDataTracking = NO
}];
```

<div id="user-interaction-tracing">
  ## Trazado de interacciones de usuario
</div>

El trazado de interacciones de usuario, una vez habilitado, registra transacciones de clics. Esta función no está disponible en SwiftUI. Desde la versión 8.0.0, está habilitada de forma predeterminada. Para desactivarla:

```swift {tabTitle:Swift}
import Sentry

SentrySDK.start { options in
    options.dsn = "___PUBLIC_DSN___"
    options.enableUserInteractionTracing = false
}
```

```objc {tabTitle:Objective-C}
@import Sentry;

[SentrySDK startWithConfigureOptions:^(SentryOptions *options) {
    options.dsn = @"___PUBLIC_DSN___";
    options.enableUserInteractionTracing = NO;
}];
```

El SDK compone el nombre de la transacción a partir del `UIViewController` anfitrión y del método que invoca el `UIView`; por ejemplo, `YourApp_LoginUIViewController.loginButton`. El SDK establece la operación de la transacción en `ui.action`. Si detecta que el origen de la interacción fue un clic, agrega `click` como sufijo a la operación. La transacción finaliza automáticamente tras alcanzar el [idleTimeout](/es/platforms/apple/guides/ios/configuration/options/#idleTimeout) especificado y cuando todos sus spans secundarios hayan finalizado. El `idleTimeout` tiene un valor predeterminado de `3000` milisegundos (tres segundos).

<Alert>
  Si la transacción de UI queda inactiva pero no se le agregan spans secundarios, el SDK la descartará.
</Alert>

El SDK vincula automáticamente las transacciones de interacción del usuario a `Scope` si no hay otra transacción establecida. Por ello, puedes crear spans mediante instrumentación personalizada y dichos spans se asociarán automáticamente con la transacción de UI en ejecución.

```Swift
import Sentry

func loadUserDataOnClick() {
    let span = SentrySDK.span
    let innerSpan = span?.startChild(operation: "loadUserData")
    // se omite código
    innerSpan?.finish()
}
```

```objc {tabTitle:Objective-C}
@import Sentry;

- (void)loadUserDataOnClick {
    id<SentrySpan> span = SentrySDK.span;
    id<SentrySpan> innerSpan = [span startChildWithOperation:@"loadUserData"];
    // se omitió código
    [innerSpan finish];
}
```

Cuando la transacción de interacción del usuario aún no ha terminado y el usuario realiza una nueva interacción, o el SDK inicia una nueva transacción de UIViewController, el SDK finaliza automáticamente la transacción de interacción anterior. Esto se debe a que solo puede haber una transacción vinculada al ámbito a la vez. Sin embargo, si se vuelve a interactuar con la misma vista (por ejemplo, se hace clic de nuevo en un `UIButton` dentro de la ventana de `idleTimeout`), el temporizador de inactividad se reiniciará y la duración de la transacción se ampliará en el valor de `idleTimeout`.

<div id="time-to-initial-display">
  ## Tiempo hasta la visualización inicial
</div>

<Alert>
  Esta función solo es compatible con UIViewController y no con SwiftUI.
</Alert>

Al agregar un span para un view controller cuando se carga, el tiempo hasta la visualización inicial (TTID) ofrece información sobre cuánto tarda tu view controller en iniciarse y dibujar su primer fotograma de la UI. El SDK establece la operación del span como `ui.load.initial-display` y la descripción del span como el nombre del view controller seguido de `initial display`; por ejemplo, `MainViewController initial display`.

El span comienza cuando se carga la vista de un view controller y no hay otra transacción de view controller en curso en ese momento. El span finaliza después de que la vista aparece en la pantalla. El siguiente gráfico muestra cómo el tiempo hasta la visualización inicial (TTID) y el [tiempo hasta la visualización completa (TTFD)](#time-to-full-display) se correlacionan con las transiciones entre actividades:

![](./img/ttid-ttfd-concept.png)

Desde la versión 8.33.0 del SDK de Cocoa, el SDK no crea spans de tiempo hasta la visualización inicial (TTID) ni de [tiempo hasta la visualización completa (TTFD)](#time-to-full-display) para UIViewController presentados en segundo plano, porque la lógica requiere dibujar fotogramas de la UI.

<div id="time-to-full-display">
  ## Tiempo hasta la visualización completa
</div>

<Alert>
  Esta función solo funciona con UIViewControllers y no con SwiftUI.
</Alert>

Al añadir un span para un controlador de vista cuando se carga, el tiempo hasta la visualización completa (TTFD) ofrece información sobre cuánto tarda tu controlador de vista en iniciarse y cargar todo su contenido. El span comienza cuando se carga la vista de un controlador de vista y no hay ninguna otra transacción de controlador de vista en curso en ese momento. El SDK establece la operación del span en `ui.load.full-display` y la descripción del span en el nombre del controlador de vista, seguido de `full display`; por ejemplo, `MainActivity full display`.

Desde la versión 8.33.0 del SDK de Cocoa, el SDK no crea spans de [tiempo hasta la visualización inicial (TTID)](#time-to-initial-display) ni de tiempo hasta la visualización completa (TTFD) para UIViewControllers presentados en segundo plano, porque la lógica requiere que se dibujen fotogramas de la interfaz.

*El tiempo hasta la visualización completa está deshabilitado de forma predeterminada, pero puedes habilitarlo configurando:*

```swift {tabTitle:Swift}
import Sentry

SentrySDK.start { options in
    options.dsn = "___PUBLIC_DSN___"
    options.enableTimeToFullDisplayTracing = true
}
```

```objc {tabTitle:Objective-C}
@import Sentry;

[SentrySDK startWithConfigureOptions:^(SentryOptions *options) {
    options.dsn = @"___PUBLIC_DSN___";
    options.enableTimeToFullDisplayTracing = YES;
}];
```

No podemos detectar cuándo tu UIViewController ha terminado de cargarse. Solo tú, como usuario, puedes hacerlo. Por lo tanto, debes invocar la API manualmente para obtener estadísticas correctas.
*Puedes hacerlo con el siguiente código:*

```swift {tabTitle:Swift}
import Sentry

SentrySDK.reportFullyDisplayed()
```

```objc {tabTitle:Objective-C}
@import Sentry;

[SentrySDK reportFullyDisplayed];
```

Si el span finaliza a través de la API, su `status` se establece en `SpanStatus.OK`. Si el span no finaliza tras 30 segundos, el SDK lo cerrará automáticamente y su `status` se establecerá en `SpanStatus.DEADLINE_EXCEEDED`; además, su duración coincidirá con la del span `Time to initial display` y la descripción incluirá el sufijo `Deadline Exceeded`.
Si se llama a `reportFullyDisplayed()` antes de que aparezca el controlador de vista, el tiempo informado se ajustará al tiempo medido de `Time to initial display`.

<div id="performance-v2">
  ## Performance V2
</div>

*(Nuevo en la versión 8.18.0), estable desde la 8.42.0.*

Estamos trabajando para actualizar nuestra oferta de **Performance** con el fin de proporcionar mejores información y destacar acciones específicas que puedes realizar para mejorar el rendimiento general de tu app móvil. La opción `performanceV2` cambia el siguiente comportamiento:

* La duración del inicio de la app ahora finalizará cuando se dibuje el primer fotograma, en lugar de cuando el SO publique la notificación `UIWindowDidBecomeVisibleNotification`.

Este cambio será el valor predeterminado en la próxima versión principal.

<div id="opt-out">
  ## Exclusión
</div>

Puedes desactivar todas las instrumentaciones automáticas usando las opciones:

```swift {tabTitle:Swift}
import Sentry

SentrySDK.start { options in
    options.dsn = "___PUBLIC_DSN___"
    options.enableAutoPerformanceTracing = false

    // Antes de la 8.0.0
    options.enableAutoPerformanceTracking = false
}
```

```objc {tabTitle:Objective-C}
@import Sentry;

[SentrySDK startWithConfigureOptions:^(SentryOptions *options) {
    options.dsn = @"___PUBLIC_DSN___";
    options.enableAutoPerformanceTracing = NO;

    // Antes de la versión 8.0.0
    options.enableAutoPerformanceTracking = NO;
}];
```

[UIWindow]: https://developer.apple.com/documentation/uikit/uiwindowdidbecomevisiblenotification

[didFinishLaunching]: https://developer.apple.com/documentation/uikit/uiapplication/1622971-didfinishlaunchingnotification

---
title: Plug y Phoenix
description: "Aprende a capturar errores y su contexto en pipelines de Plug y aplicaciones Phoenix."
sidebar_order: 10
---

Puedes capturar errores en aplicaciones de [Plug](https://github.com/elixir-plug/plug) y [Phoenix](https://phoenixframework.org) con `Sentry.PlugContext` y `Sentry.PlugCapture`.

`Sentry.PlugContext` agrega metadatos contextuales de la solicitud actual a los errores informados que ocurren durante la ejecución de Plug. Para aplicaciones con [Cowboy](https://hex.pm/packages/cowboy), se requiere un plug adicional, `Sentry.PlugCapture`, para garantizar que estos metadatos se propaguen correctamente.

<div id="phoenix-configuration">
  ## Configuración de Phoenix
</div>

Si usas Phoenix, sigue estos pasos para añadir la integración de Plug:

1. Añade `Sentry.PlugContext` debajo de `Plug.Parsers`.

```elixir {diff}
defmodule MyAppWeb.Endpoint
   use Phoenix.Endpoint, otp_app: :my_app

   # ...

   plug Plug.Parsers,
     parsers: [:urlencoded, :multipart, :json],
     pass: ["*/*"],
     json_decoder: Phoenix.json_library()

+  plug Sentry.PlugContext
```

2. Si usas Cowboy, añade `Sentry.PlugCapture` por encima de la línea `use Phoenix.Endpoint` en tu archivo de endpoint.

```elixir {diff}
defmodule MyAppWeb.Endpoint
+  use Sentry.PlugCapture
   use Phoenix.Endpoint, otp_app: :my_app

   # ...
```

Si también usas [Phoenix LiveView](https://github.com/phoenixframework/phoenix_live_view), considera configurar tus LiveViews para usar el hook `Sentry.LiveViewHook` (disponible a partir de la versión `10.5.0` del SDK de Sentry):

```elixir
defmodule MyAppWeb do
  def live_view do
    quote do
      use Phoenix.LiveView

      on_mount Sentry.LiveViewHook
    end
  end
end
```


<div id="capturing-user-feedback">
  ### Captura de comentarios de usuario
</div>

Si quieres <PlatformLink to="/enriching-events/user-feedback/">capturar comentarios de usuarios</PlatformLink>, puedes usar la función `Sentry.get_last_event_id_and_source/0` para comprobar si Sentry ha enviado un evento dentro del proceso Plug actual (y obtener su origen). `:plug` será el origen de los eventos provenientes de `Sentry.PlugCapture`. Las opciones descritas en la documentación de Sentry enlazada arriba también pueden codificarse en la respuesta.

A continuación se muestra un ejemplo de configuración de una aplicación Phoenix que muestra el formulario de comentarios de usuario en respuestas `500` para solicitudes que aceptan HTML:

```elixir
defmodule MyAppWeb.ErrorView do
  # ...

  def render("500.html", _assigns) do
    case Sentry.get_last_event_id_and_source() do
      {event_id, :plug} when is_binary(event_id) ->
        opts = Jason.encode!(%{eventId: event_id})

        ~E"""
        <script src="https://browser.sentry-cdn.com/5.9.1/bundle.min.js" integrity="sha384-/x1aHz0nKRd6zVUazsV6CbQvjJvr6zQL2CHbQZf3yoLkezyEtZUpqUNnOLW9Nt3v" crossorigin="anonymous"></script>
        <script>
          Sentry.init({ dsn: '<%= Sentry.get_dsn() %>' });
          Sentry.showReportDialog(<%= raw opts %>)
        </script>
        """

      _ ->
        "Error"
    end
  end
end
```


<div id="plug-configuration">
  ## Configuración de Plug
</div>

Si tienes una aplicación que no usa Phoenix, sigue estos pasos para configurar la integración de Plug:

1. Añade `Sentry.PlugContext` debajo de `Plug.Parsers` (si está en tu stack).

```elixir {diff}
 defmodule MyApp.Router do
   use Plug.Router

   # ...

   plug Plug.Parsers,
     parsers: [:urlencoded, :multipart]

+  plug Sentry.PlugContext
```

2. Si usas Cowboy, agrega `Sentry.PlugCapture` al principio de tu aplicación Plug.

```elixir {diff}
 defmodule MyApp.Router do
   use Plug.Router
+  use Sentry.PlugCapture

   # ...
```

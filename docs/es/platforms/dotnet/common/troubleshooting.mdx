---
title: Soluci贸n de problemas
sidebar_order: 9000
description: "Obt茅n m谩s informaci贸n sobre c贸mo solucionar problemas comunes con el SDK de .NET. "
---

<PlatformSection supported={["dotnet.maui", "dotnet.apple"]}>
  ## Las trazas de pila no est谩n simbolizadas en iOS, macOS y Mac Catalyst

  Al compilar aplicaciones de .NET MAUI en modo de publicaci贸n (release) para iOS, macOS o Mac Catalyst, es posible que veas trazas de pila sin simbolizar en Sentry, donde los nombres de las funciones aparecen como direcciones de memoria en lugar de nombres de m茅todos legibles.

  Esto se debe a **un problema en el SDK de .NET** que afecta c贸mo se maneja la informaci贸n de depuraci贸n al compilar para plataformas de Apple en modo de publicaci贸n. Este problema se ha reportado a Microsoft y se est谩 haciendo seguimiento en el repositorio del runtime de .NET.

  Si este problema afecta a tu aplicaci贸n:

  1. Visita el [.NET runtime issue](https://github.com/dotnet/runtime/issues/118700)
  2. A帽ade una reacci贸n () para indicar que te afecta
  3. Considera a帽adir un comentario describiendo tu caso de uso

  Esto ayudar谩 a Microsoft a priorizar la correcci贸n seg煤n el impacto en la comunidad.

  ### Soluciones alternativas

  Hasta que el problema se resuelva correctamente, la simbolizaci贸n en plataformas de Apple solo es posible deshabilitando el stripping. Por ejemplo, a帽ade lo siguiente a tus archivos `*.csproj`:

  ```xml
  <PropertyGroup>
    <EnableAssemblyILStripping>false</EnableAssemblyILStripping>
  </PropertyGroup>
  ```

  **Nota importante**: Esto puede aumentar significativamente el tama帽o de tu aplicaci贸n.

  ### Versiones afectadas

  Este problema afecta a:

  * Aplicaciones .NET 9 dirigidas a iOS, macOS y Mac Catalyst
  * Aplicaciones compiladas en modo de publicaci贸n con trimming habilitado
  * Afecta espec铆ficamente a los target frameworks `net9.0-ios*`
</PlatformSection>

<div id="sentry-cli-not-configured">
  ## Sentry CLI no est谩 configurado
</div>

Es posible que aparezca el siguiente mensaje en la salida de tu compilaci贸n:

> Sentry CLI no est谩 completamente configurado con autenticaci贸n, organizaci贸n y proyecto.

Actualmente, el mensaje se muestra solo como informativo, aunque podr铆amos cambiarlo a una advertencia en el futuro.
Esto significa que est谩s compilando con la configuraci贸n `Release` y no has configurado completamente
[MSBuild para Sentry CLI](../configuration/msbuild/). Puedes resolverlo de una de las siguientes maneras:

* Puedes habilitar Sentry CLI en tu compilaci贸n proporcionando los detalles de configuraci贸n, como se describe [en la documentaci贸n](../configuration/msbuild/).

* Puedes evitar que se genere el mensaje estableciendo la propiedad `<UseSentryCLI>false</UseSentryCLI>` en el archivo de tu proyecto .NET,
  o con `/p:UseSentryCLI=false` en la l铆nea de comandos de `dotnet build` o `msbuild`. Sentry CLI se desactivar谩.

* Puedes no hacer nada y simplemente ignorar el mensaje. Sentry CLI se desactivar谩.

Ten en cuenta que, si Sentry CLI est谩 desactivado, los archivos de informaci贸n de depuraci贸n como los s铆mbolos PDB
no se enviar谩n a Sentry. Si Sentry no puede localizar s铆mbolos, no podr谩 realizar la simbolizaci贸n de trazas de pila.
Esto significa que, para algunos tipos de proyectos (seg煤n la configuraci贸n), es posible que no veas nombres de archivo y n煤meros de l铆nea
que te ayuden a ubicar el origen de una excepci贸n.

<div id="detected-package-version-outside-of-dependency-constraint">
  ## Versi贸n de paquete detectada fuera de la restricci贸n de dependencias
</div>

En aplicaciones de .NET para Android, el SDK de Sentry necesita usar un n煤mero limitado de API de Android que forman parte del sistema operativo. De forma impl铆cita, Sentry depende de [varios paquetes de Java](https://github.com/getsentry/sentry-dotnet/blob/ebc1115d6c928ff56244afa3a1ce1d79b078fbf4/src/Sentry.Bindings.Android/Sentry.Bindings.Android.csproj#L45-L56).

Si usas bibliotecas de terceros que dependen de versiones diferentes de esos mismos paquetes de Java, podr铆as ver las advertencias `NU1605`, `NU1608` y/o `NU1107` al intentar ejecutar `dotnet restore`.

Sentry solo especifica una versi贸n m铆nima de los paquetes de Java de los que depende, por lo que es compatible con cualquier versi贸n superior de esos mismos paquetes. Sin embargo, estos paquetes de Java traen sus propias dependencias, que por lo tanto se convierten en dependencias transitivas para Sentry. Las dependencias transitivas del SDK de Sentry a veces pueden ser incompatibles con las dependencias transitivas de otras bibliotecas de terceros, y NuGet no es lo suficientemente inteligente como para resolver esos conflictos sin algo de orientaci贸n.

Estos problemas deben resolverse caso por caso, pero el siguiente ejemplo deber铆a mostrar c贸mo puedes solucionarlos si te los encuentras en tu propia aplicaci贸n.

<div id="example-problem">
  ### Ejemplo de problema
</div>

Si utilizas `Sentry` `5.7.0` en una aplicaci贸n de .NET para Android dirigida a `net9.0-android`, Sentry tendr谩 varias [dependencias directas](https://www.nuget.org/packages/Sentry/5.7.0#dependencies-body-tab). Sin embargo, esas dependencias directas tienen a su vez sus propias dependencias, que en el caso de Sentry son dependencias transitivas.

Si adem谩s usas `Microsoft.Maui.Essentials` en la versi贸n `9.0.50`, en 煤ltima instancia depende de versiones en conflicto de esas mismas dependencias transitivas.

En este escenario ver谩s una advertencia o un error como el siguiente al ejecutar `dotnet restore`:

```
NU1608: Se detect贸 una versi贸n del paquete fuera de la restricci贸n de dependencia: Xamarin.AndroidX.Lifecycle.Common.Java8 2.8.5.1 requiere Xamarin.AndroidX.Lifecycle.Common (>= 2.8.5.1 && < 2.8.6), pero se resolvi贸 la versi贸n Xamarin.AndroidX.Lifecycle.Common 2.8.7.2.
```

<div id="example-solution">
  ### Soluci贸n de ejemplo
</div>

Para resolver el problema anterior, puedes usar [Transitive Pinning](https://learn.microsoft.com/en-us/nuget/consume-packages/central-package-management#transitive-pinning) para fijar versiones expl铆citas de las dependencias transitivas (en lugar de dejar que NuGet las resuelva autom谩ticamente).

Para habilitar Transitive Pinning, agrega lo siguiente a tu archivo `csproj` o `Directory.Build.props`:

```xml
<PropertyGroup>
  <CentralPackageTransitivePinningEnabled>true</CentralPackageTransitivePinningEnabled>
</PropertyGroup>
```

Luego puedes fijar las versiones adecuadas de la dependencia transitiva que te est谩 causando problemas:

```xml
<ItemGroup>
    <PackageReference Include="Xamarin.AndroidX.Lifecycle.Common.Java8" Version="2.8.7.2" />
</ItemGroup>
```

Aunque el SDK de Sentry solo requiere `Xamarin.AndroidX.Lifecycle.Common.Java8 2.8.5.1`, esa versi贸n resulta problem谩tica porque fija la dependencia transitiva `Xamarin.AndroidX.Lifecycle.Common` al rango `(>= 2.8.5.1 && < 2.8.6)`. Al anclar expl铆citamente `Xamarin.AndroidX.Lifecycle.Common.Java8` en `2.8.7.2` para que coincida con la versi贸n usada por `Microsoft.Maui.Essentials`, podemos resolver el conflicto.

<div id="updating-to-4120-broke-my-net-ios-app">
  ## Actualizar a la 4.12.0 rompi贸 mi app .NET para iOS
</div>

Se agreg贸 compatibilidad con Xcode 16.0 en la versi贸n 4.12.0 del Sentry SDK para .NET.
Si usas Xcode 16.0, necesitas actualizar al SDK versi贸n 4.12.0 o posterior.
Si a煤n usas Xcode 15.4 o anterior, debes seguir usando la versi贸n 4.11.0 o anterior.

Usar Xcode 16 para compilar aplicaciones .NET destinadas a iOS y Mac Catalyst requiere la carga de trabajo de .NET para iOS SDK versi贸n 18.0.8303. Compilamos la versi贸n 4.12.0 del SDK con Xcode 16 para admitir este escenario. Eso, lamentablemente, rompe la compatibilidad para quienes usan una versi贸n anterior de Xcode.

Por lo tanto, si usas la versi贸n 4.12.x del SDK y apuntas a iOS o Mac Catalyst, necesitar谩s instalar y usar Xcode 16 y la carga de trabajo iOS SDK 18.0.8303.

Ten en cuenta que .NET 9 tambi茅n admitir谩 Xcode 16 cuando se publique el pr贸ximo mes (nov 2024).

<div id="the-event-is-dropped-by-sentry-because-its-too-large">
  ## Sentry descarta el evento porque es demasiado grande
</div>

> Sentry: (Error) Sentry rechaz贸 el envelope 5bfe4129cb2446c08768b16479865035. C贸digo de estado: RequestEntityTooLarge. Detalle del error: no se pudo leer el cuerpo de la solicitud. Causas del error: una carga 煤til alcanz贸 el l铆mite de tama帽o.

Puedes hacer que el [SDK de .NET de Sentry escriba estos envelopes en una ruta](https://github.com/getsentry/sentry-dotnet/blob/e62013ca63436d2a786fb229570e96f42c7c4044/src/Sentry/Http/HttpTransportBase.cs#L341-L363) para diagnosticar por qu茅 son demasiado grandes.
Establece la variable de entorno `SENTRY_KEEP_LARGE_ENVELOPE_PATH` en el directorio donde quieres que se escriban.
Aseg煤rate de que el proceso en el que se ejecuta el SDK tenga permisos de escritura.

<div id="user-ip-address-in-sentry-shows-up-as-the-server-ip">
  ## La direcci贸n IP del usuario en Sentry aparece como la IP del servidor
</div>

Si usas un servidor proxy que conf铆a en `X-Forwarded-For`, quiz谩 debas [configurar ASP.NET Core para que lo reconozca](https://docs.microsoft.com/aspnet/core/host-and-deploy/proxy-load-balancer).

Consulta [este issue de GitHub](https://github.com/getsentry/sentry-dotnet/issues/258) para m谩s contexto.

<div id="unhandled-exceptions-are-not-captured-when-using-an-async-main-method">
  ## No se capturan las excepciones no controladas al usar un m茅todo `Main` asincr贸nico
</div>

A partir de C# 7.1, el [m茅todo `Main` de un programa](https://docs.microsoft.com/dotnet/csharp/fundamentals/program-structure/main-command-line) puede declararse de forma sincr贸nica o asincr贸nica.
Esto se ampl铆a en C# 9 con el uso de [instrucciones de nivel superior](https://learn.microsoft.com/dotnet/csharp/fundamentals/program-structure/top-level-statements), que tambi茅n pueden declararse de forma sincr贸nica o asincr贸nica.

Al usar cualquiera de estas caracter铆sticas con versiones anteriores del SDK de Sentry .NET, cuando se llama a `SentrySdk.Init` dentro de una instrucci贸n `using`, es posible que no se capturen las excepciones no controladas.
Adem谩s, si usabas un `Main` asincr贸nico, es posible que las transacciones asociadas no se marcaran como fallidas ni se enviaran a Sentry.

Estos problemas se han resuelto por completo a partir de la versi贸n 3.31.0 del SDK de Sentry .NET. Para usar un `Main` asincr贸nico de forma segura, actualiza a la versi贸n m谩s reciente.
Ya no es necesario disponer del resultado de llamar a `SentrySdk.Init`.

<div id="obfuscated-code-and-stack-traces">
  ## C贸digo ofuscado y stack traces
</div>

Es importante definir qu茅 significa ofuscaci贸n. Si obtienes stack traces ilegibles debido a la falta de [archivos de depuraci贸n](/es/platforms/dotnet/data-management/debug-files/), basta con habilitar la carga de archivos de depuraci贸n, que el [SDK de Sentry mediante MSBuild](/es/platforms/dotnet/guides/aspnet/configuration/msbuild/) realiza autom谩ticamente.

Algunas herramientas personalizadas ofuscan el Lenguaje intermedio (IL) de .NET para dificultar la ingenier铆a inversa; Sentry actualmente no admite estas herramientas. Esto se debe a que cada ofuscador utiliza su propia l贸gica a la hora de desofuscar, lo que hace inviable implementar soporte universal.

Si trabajas con c贸digo ofuscado, tienes varias opciones:

1. **Usar un servicio proxy**: Puedes enrutar las excepciones a trav茅s de tu propio servicio web proxy, donde podr谩s desofuscar los stack traces antes de enviarlos a Sentry. Esto te da control total sobre el proceso de desofuscaci贸n.

2. **Conservar los nombres de los m茅todos**: Muchas herramientas de ofuscaci贸n permiten desactivar la ofuscaci贸n de los nombres de los m茅todos mientras se sigue ofuscando el c贸digo dentro de ellos. Este enfoque produce stack traces m谩s legibles y mantiene la protecci贸n del c贸digo. Configura tu ofuscador para conservar los nombres de los m茅todos si este equilibrio entre legibilidad y seguridad se ajusta a tus necesidades.

3. **Contribuir a Symbolic**: [Nuestra biblioteca de symbolication es de c贸digo abierto](https://github.com/getsentry/symbolic). Puedes abrir un ticket para debatir con los mantenedores la posibilidad de a帽adir soporte.

<div id="proxy-server">
  ## Servidor proxy
</div>

A menudo, tu servidor solo puede acceder a Internet a trav茅s de un servidor proxy.
Si ese es el caso, aseg煤rate de que el servidor proxy est茅 configurado para que el `HttpClient`
usado por el SDK de Sentry pueda detectarlo.

```csharp
(SentryOptions options) =>
{
    // Lee la direcci贸n del proxy desde, por ejemplo, tu configuraci贸n
    options.HttpProxy = new WebProxy(new Uri("http://proxyserver:80/"));
};
```

Como alternativa, puedes configurar el proxy predeterminado que usar谩n todas las instancias de `HttpClient` si no se establece expl铆citamente un proxy.

```csharp
System.Net.Http.HttpClient.DefaultProxy = new WebProxy(new Uri("http://proxyserver:80/"));
```

Para obtener m谩s informaci贸n, consulta la [propiedad HttpClient.DefaultProxy](https://learn.microsoft.com/dotnet/api/system.net.http.httpclient.defaultproxy).

<PlatformContent includePath="troubleshooting" />

---
title: FastHTTP
description: "Aprende a añadir instrumentación de Sentry a programas que usan el paquete FastHTTP."
---

Para consulta rápida, hay un [ejemplo completo](https://github.com/getsentry/sentry-go/tree/master/_examples/fasthttp) disponible directamente en el repositorio del código fuente del SDK de Go.

También está disponible la [documentación de la API al estilo Go Dev](https://pkg.go.dev/github.com/getsentry/sentry-go/fasthttp).

<div id="install">
  ## Instalación
</div>

```bash
go get github.com/getsentry/sentry-go
go get github.com/getsentry/sentry-go/fasthttp
```

<Break />


<div id="configure">
  ## Configuración
</div>

<div id="initialize-the-sentry-sdk">
  ### Inicializa el SDK de Sentry
</div>

<PlatformContent includePath="getting-started-config" />

<div id="options">
  ### Opciones
</div>

`sentryfasthttp` acepta una estructura `Options` que te permite configurar cómo se comportará el controlador.

```go
// Repanic configura si Sentry debe volver a generar el pánico después de la recuperación; en la mayoría de los casos, su valor predeterminado es false,
// ya que fasthttp no incluye su propio manejador de recuperación.
Repanic bool
// WaitForDelivery configura si deseas bloquear la solicitud antes de continuar con la respuesta.
// Dado que fasthttp no incluye su propio manejador de `Recovery`, reiniciará la aplicación,
// y el evento no se entregará de otra manera.
WaitForDelivery bool
// Timeout para las solicitudes de entrega de eventos.
Timeout time.Duration
```

<Break />

```go
// Crear una instancia de sentryfasthttp
sentryHandler := sentryfasthttp.New(sentryfasthttp.Options{
    Repanic:         false,
    WaitForDelivery: true,
    Timeout:         5 * time.Second,
})
```


<div id="verify">
  ## Verifica
</div>

```go
// Crear una instancia de sentryfasthttp
sentryHandler := sentryfasthttp.New(sentryfasthttp.Options{
// especifica las opciones aquí...
})

// Después de crear la instancia, puedes adjuntar el manejador como uno de tus middleware
fastHTTPHandler := sentryHandler.Handle(func(ctx *fasthttp.RequestCtx) {
	// capturando un error intencionalmente para simular el uso
	sentry.CaptureMessage("¡Funciona!")
	
	ctx.SetStatusCode(fasthttp.StatusOK)
})

fmt.Println("Escuchando y sirviendo HTTP en :3000")

// Y ejecútalo
if err := fasthttp.ListenAndServe(":3000", fastHTTPHandler); err != nil {
	panic(err)
}
```


<div id="usage">
  ## Uso
</div>

`sentryfasthttp` adjunta una instancia de `*sentry.Hub` (https://pkg.go.dev/github.com/getsentry/sentry-go#Hub) al contexto de la solicitud, lo que la hace disponible durante el resto del ciclo de vida de dicha solicitud.
Puedes acceder a ella usando el método `sentryfasthttp.GetHubFromContext()` sobre el propio contexto en cualquiera de tus middleware y rutas posteriores.
Debe usarse en lugar de las llamadas globales `sentry.CaptureMessage`, `sentry.CaptureException` u otras, ya que mantiene separada la información entre solicitudes.

**Ten en cuenta que `*sentry.Hub` no estará disponible en el middleware que se ejecute antes de `sentryfasthttp`!**

```go
func enhanceSentryEvent(handler fasthttp.RequestHandler) fasthttp.RequestHandler {
	return func(ctx *fasthttp.RequestCtx) {
		if hub := sentryfasthttp.GetHubFromContext(ctx); hub != nil {
			hub.Scope().SetTag("someRandomTag", "maybeYouNeedIt")
		}
		handler(ctx)
	}
}

// Más adelante en el código
sentryHandler := sentryfasthttp.New(sentryfasthttp.Options{
	Repanic: true,
	WaitForDelivery: true,
})

defaultHandler := func(ctx *fasthttp.RequestCtx) {
	if hub := sentryfasthttp.GetHubFromContext(ctx); hub != nil {
		hub.WithScope(func(scope *sentry.Scope) {
			scope.SetExtra("unwantedQuery", "someQueryDataMaybe")
			hub.CaptureMessage("El usuario proporcionó una cadena de consulta no deseada, pero lo manejamos sin problemas")
		})
	}
	ctx.SetStatusCode(fasthttp.StatusOK)
}

fooHandler := enhanceSentryEvent(func(ctx *fasthttp.RequestCtx) {
	panic("y por qué")
})

fastHTTPHandler := func(ctx *fasthttp.RequestCtx) {
	switch string(ctx.Path()) {
	case "/foo":
		fooHandler(ctx)
	default:
		defaultHandler(ctx)
	}
}

fmt.Println("Escuchando y sirviendo HTTP en :3000")

if err := fasthttp.ListenAndServe(":3000", sentryHandler.Handle(fastHTTPHandler)); err != nil {
	panic(err)
}
```


<div id="accessing-context-in-beforesend-callback">
  ### Acceder al contexto en el callback `BeforeSend`
</div>

```go
sentry.Init(sentry.ClientOptions{
	Dsn: "___PUBLIC_DSN___",
	BeforeSend: func(event *sentry.Event, hint *sentry.EventHint) *sentry.Event {
		if hint.Context != nil {
			if ctx, ok := hint.Context.Value(sentry.RequestContextKey).(*fasthttp.RequestCtx); ok {
				// Tienes acceso al contexto original si hubo un panic
				fmt.Println(string(ctx.Request.Host()))
			}
		}
		return event
	},
})
```

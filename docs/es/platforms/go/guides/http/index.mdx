---
title: net/http
description: "El paquete net/http proporciona implementaciones de cliente y servidor HTTP. Aprende a agregar Sentry a programas que usan este paquete."
---

Para una consulta rápida, hay un [ejemplo completo](https://github.com/getsentry/sentry-go/tree/master/_examples/http) en el repositorio del código fuente del SDK de Go.

También está disponible la [documentación de la API al estilo Go Dev](https://pkg.go.dev/github.com/getsentry/sentry-go/http).

<div id="install">
  ## Instalación
</div>

```bash
go get github.com/getsentry/sentry-go
go get github.com/getsentry/sentry-go/http
```

<Break />


<div id="configure">
  ## Configuración
</div>

<div id="initialize-the-sentry-sdk">
  ### Inicializar el SDK de Sentry
</div>

<PlatformContent includePath="getting-started-config" />

<div id="options">
  ### Opciones
</div>

`sentryhttp` acepta una estructura `Options` que te permite configurar el comportamiento del controlador.

```go
// Si Sentry debe volver a entrar en pánico tras la recuperación; en la mayoría de los casos debería establecerse en true,
// y deberías manejar las respuestas HTTP de forma adecuada.
Repanic bool
// Si deseas bloquear la solicitud antes de continuar con la respuesta.
// Útil cuando quieres reiniciar el proceso después de que entre en pánico.
WaitForDelivery bool
// Tiempo de espera para las solicitudes de envío de eventos.
Timeout time.Duration
```

<Break />

```go
// Crea una instancia de sentryhttp
sentryHandler := sentryhttp.New(sentryhttp.Options{
    Repanic:         true,
    WaitForDelivery: false,
    Timeout:         5 * time.Second,
})
```


<div id="verify">
  ## Verificar
</div>

```go
type handler struct{}

func (h *handler) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	// Capturando un error intencionalmente para simular el uso
	sentry.CaptureMessage("¡Funciona!")
	
	rw.WriteHeader(http.StatusOK)
}

// Crea una instancia de sentryhttp
sentryHandler := sentryhttp.New(sentryhttp.Options{
// Especifica las opciones aquí...
})

// Una vez hecho, puedes configurar rutas y adjuntar el handler como uno de tus middlewares
http.Handle("/", sentryHandler.Handle(&handler{}))

fmt.Println("Escuchando y atendiendo HTTP en :3000")

// Y ejecútalo
if err := http.ListenAndServe(":3000", nil); err != nil {
	panic(err)
}
```


<div id="usage">
  ## Uso
</div>

`sentryhttp` adjunta una instancia de `*sentry.Hub` (https://pkg.go.dev/github.com/getsentry/sentry-go#Hub) al contexto de la petición, lo que la hace disponible durante el resto de la vida de la petición.
Puedes acceder a ella usando el método `sentry.GetHubFromContext()` en la propia petición, en cualquiera de tus middleware y rutas posteriores.
Y debería usarse en lugar de las funciones globales `sentry.CaptureMessage`, `sentry.CaptureException` u otras llamadas, ya que mantiene la separación de datos entre las peticiones.

**Ten en cuenta que `*sentry.Hub` no estará disponible en middleware que se ejecute antes de `sentryhttp`!**

```go
type handler struct{}

func (h *handler) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	if hub := sentry.GetHubFromContext(r.Context()); hub != nil {
		hub.WithScope(func(scope *sentry.Scope) {
			scope.SetExtra("unwantedQuery", "someQueryDataMaybe")
			hub.CaptureMessage("El usuario proporcionó una cadena de consulta no deseada, pero nos recuperamos sin problema")
		})
	}
	rw.WriteHeader(http.StatusOK)
}

func enhanceSentryEvent(handler http.HandlerFunc) http.HandlerFunc {
	return func(rw http.ResponseWriter, r *http.Request) {
		if hub := sentry.GetHubFromContext(r.Context()); hub != nil {
			hub.Scope().SetTag("someRandomTag", "maybeYouNeedIt")
		}
		handler(rw, r)
	}
}

// Más adelante en el código

sentryHandler := sentryhttp.New(sentryhttp.Options{
	Repanic: true,
})

http.Handle("/", sentryHandler.Handle(&handler{}))
http.HandleFunc("/foo", sentryHandler.HandleFunc(
	enhanceSentryEvent(func(rw http.ResponseWriter, r *http.Request) {
		panic("¿y por qué, pues?")
	}),
))

fmt.Println("Escuchando y atendiendo HTTP en :3000")

if err := http.ListenAndServe(":3000", nil); err != nil {
	panic(err)
}
```


<div id="accessing-request-in-beforesend-callback">
  ### Acceso a la solicitud en el callback `BeforeSend`
</div>

```go
sentry.Init(sentry.ClientOptions{
	Dsn: "___PUBLIC_DSN___",
	BeforeSend: func(event *sentry.Event, hint *sentry.EventHint) *sentry.Event {
		if hint.Context != nil {
			if req, ok := hint.Context.Value(sentry.RequestContextKey).(*http.Request); ok {
				// Aquí tienes acceso a la solicitud original
			}
		}

		return event
	},
})
```

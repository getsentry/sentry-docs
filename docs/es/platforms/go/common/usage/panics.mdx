---
title: Manejo de pánicos
description: "Obtén más información sobre cómo nuestro SDK de Go captura pánicos no controlados."
sidebar_order: 3
---

La manera de capturar pánicos no controlados en nuestro SDK de Go es mediante el método `Recover`. Puede usarse directamente con la palabra clave `defer` o como parte de tu implementación.

<div id="usage">
  ## Uso
</div>

Cuando se usa directamente, como se muestra a continuación, Sentry se recuperará del pánico y decidirá internamente si usar el método `CaptureException` o `CaptureMessage`, según el tipo de entrada recibido.
Como no es raro provocar un pánico con una cadena (string), se recomienda usar la opción `AttachStacktrace` durante la inicialización del SDK, que intentará proporcionar también un stack trace útil para los mensajes.

```go
func() {
	defer sentry.Recover()
	// haz todas las cosas arriesgadas aquí
}()
```

De forma predeterminada, el SDK de Sentry para Go usa un transporte asíncrono, lo que en el ejemplo de código a continuación requiere esperar explícitamente a que finalice la entrega del evento usando el método `sentry.Flush`. Esto es necesario porque, de lo contrario, el programa no esperaría a que las llamadas HTTP asíncronas devolvieran una respuesta y terminaría el proceso inmediatamente al llegar al final de la función `main`. No sería necesario dentro de una goroutine en ejecución o si usaras `HTTPSyncTransport`, sobre el cual puedes leer en la sección `Transports`.

Si quieres controlar la entrega para una única llamada con `defer`, o realizar otras acciones antes de capturar, debes usar el método `Recovery` directamente en la instancia de `Hub`, ya que puede aceptar `err` por sí mismo.

```go
func() {
	defer func() {
		err := recover()

		if err != nil {
			sentry.CurrentHub().Recover(err)
			sentry.Flush(time.Second * 5)
		}
	}()

	// haz todas las cosas arriesgadas aquí
}()
```


<div id="using-context">
  ### Uso de Context
</div>

Además del método habitual `Recover`, hay otro que se puede usar para panics: `RecoverWithContext`.
Permite pasar una instancia de `context.Context` como primer argumento. Esto nos brinda dos funciones adicionales.

La primera es extraer la instancia de `Hub` del contexto y usarla en lugar de la global; esto se utiliza en cada integración del paquete http/server, ya que permite separar el contexto de ejecución. Puedes verlo en acción en el [código fuente](https://github.com/getsentry/sentry-go/blob/383614eaf2e038cf3a6d2022c56fb206589efe11/http/sentryhttp.go#L50-L91) de nuestra integración `http`.

Y la segunda función: tener acceso al propio `context.Context` dentro del método `beforeSend`, lo que se puede usar para extraer cualquier información adicional sobre lo que ocurrió durante el panic:

```go
type contextKey int
const SomeContextKey = contextKey(1)

func main() {
	sentrySyncTransport := sentry.NewHTTPSyncTransport()
	sentrySyncTransport.Timeout = time.Second * 3

	sentry.Init(sentry.ClientOptions{
		Dsn: "___PUBLIC_DSN___",
		Transport: sentrySyncTransport,
		BeforeSend: func(event *sentry.Event, hint *sentry.EventHint) *sentry.Event {
			if hint.Context != nil {
				// hint.Context.Value(SomeContextKey) te devolvería la cadena almacenada que ahora puede adjuntarse al evento
			}
			return event
		},
	})

	ctx := context.WithValue(context.Background(), SomeContextKey, "algunos detalles sobre tu panic")

	func() {
		defer sentry.RecoverWithContext(ctx)
		// haz todas las cosas arriesgadas aquí
	}()
}
```

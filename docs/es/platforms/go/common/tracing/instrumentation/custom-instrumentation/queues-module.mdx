---
title: Colas de instrumentación
sidebar_order: 3000
description: "Aprende a instrumentar manualmente tu código para usar el módulo Queues de Sentry."
---

Sentry incluye instrumentación automática para los sistemas de colas de mensajería más comunes. Si el tuyo no está soportado, aún puedes instrumentar spans y transacciones personalizados en torno a tus productores y consumidores de colas para asegurarte de contar con datos de rendimiento sobre tus colas de mensajería.

<div id="producer-instrumentation">
  ## Instrumentación del productor
</div>

Para comenzar a capturar métricas de rendimiento, usa la función `StartSpan()` para envolver los eventos del productor de tu cola. El `op` de tu span debe establecerse en `queue.publish`. Incluye los siguientes datos del span para enriquecer tus spans de productor con métricas de la cola:

| Atributo de datos | Tipo | Descripción |
|:--|:--|:--|
| `messaging.message.id ` | string | Identificador del mensaje |
| `messaging.destination.name` | string | Nombre de la cola o del tema |
| `messaging.message.body.size` | int | Tamaño del cuerpo del mensaje en bytes |

Tu span `queue.publish` debe existir dentro de una transacción para que se reconozca como un span de productor. Si usas un framework compatible, la transacción la crea la integración. Si usas Go puro, puedes iniciar una nueva con `sentry.StartTransaction()`.

También debes incluir encabezados de trazado en tu mensaje para que los consumidores puedan continuar tu traza una vez que se procese tu mensaje.

```go
connection := my_custom_queue.Connect()

// El mensaje que quieres enviar a la cola
queue := "messages"
message := "Hello World!"
messageId := "abc123"

// Crear la transacción
transaction := sentry.StartTransaction(
    ctx,
    "queue_producer_transaction",
    options...,
)
defer transaction.Finish()

// Crear el span
span := transaction.StartChild("queue.publish")
span.Description = "productor_de_cola";
defer span.Finish()

// Definir los datos del span
span.SetData("messaging.message.id", messageId)
span.SetData("messaging.destination.name", queue)
span.SetData("messaging.message.body.size", utf8.RuneCountInString(message))

// Publicar el mensaje en la cola (incluyendo la marca de tiempo actual)
now := time.Now().Unix()
connection.Publish(queue, message, now)
```


<div id="consumer-instrumentation">
  ## Instrumentación del consumidor
</div>

Para comenzar a capturar métricas de rendimiento, usa la función `startChild()` para envolver tus consumidores de colas. El `op` de tu span debe establecerse en `queue.process`. Incluye los siguientes datos de span para enriquecer tus spans de consumidor con métricas de colas:

| Data Attribute | Type | Description |
|:--|:--|:--|
| `messaging.message.id ` | string | El identificador del mensaje |
| `messaging.destination.name` | string | El nombre de la cola o del tópico |
| `messaging.message.body.size` | number | Tamaño del cuerpo del mensaje en bytes |
| `messaging.message.retry.count ` | number | La cantidad de veces que se intentó procesar un mensaje |
| `messaging.message.receive.latency ` | number | El tiempo en milisegundos que un mensaje esperó en la cola antes de procesarse |

Tu span `queue.process` debe existir dentro de una transacción para que sea reconocido como un span de consumidor. Si usas un framework compatible, la transacción la crea la integración. Si usas Go puro, puedes iniciar una nueva con `sentry.StartTransaction()`.

Usa `sentry.StartTransaction()` para conectar tus spans de consumidor con sus spans de productor asociados y establece el `Status` del span para marcar el rastro de tu mensaje como correcto o fallido.

```go
connection := my_custom_queue.Connect()

// Obtén el mensaje de las colas
queue := "messages"
message := connection.Consume(queue)

// Calcula la latencia (opcional, pero útil)
now := time.Now()
messageTime := time.Unix(message["timestamp"].(int64), 0)
latency := now.Sub(messageTime)

// Crea la transacción
transaction := sentry.StartTransaction(
    ctx, // Continúa el seguimiento a partir del mensaje
    "queue_consumer_transaction",
    options...,
)
defer transaction.Finish()

// Crea el span
span := transaction.StartSpan(ctx, "queue.process")
span.Description = "queue_consumer";
defer span.Finish()

// Establece los datos del span
span.SetData("messaging.message.id", message["message_id"])
span.SetData("messaging.destination.name", queue)
span.SetData("messaging.message.body.size", len(message["body"].(string)))
span.SetData("messaging.message.receive.latency", latency)
span.SetData("messaging.message.retry.count", 0)

// Procesa el mensaje
err = processMessage(message)
if err != nil {
    // En caso de error, establece el estado en "internal_error"
    span.Status = sentry.SpanStatusInternalError
}
```

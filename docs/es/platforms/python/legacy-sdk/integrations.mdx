---
draft: true
categories: []
toc: true
title: Integraciones
noindex: true
tags: []
---

<Alert level="warning" title="Aviso de obsolescencia">
  Un nuevo SDK de Python ha sustituido esta versión obsoleta. Sentry conserva esta documentación para clientes que usan el cliente antiguo. Recomendamos usar el [SDK de Python actualizado](/es/platforms/python/) para proyectos nuevos.
</Alert>

El módulo Raven para Python también incluye integraciones con algunas bibliotecas de uso común para capturar automáticamente errores en entornos habituales. Esto significa que, una vez que tengas configurada dicha integración, por lo general no necesitarás reportar errores manualmente.

Algunas integraciones permiten especificarse en una configuración estándar; de lo contrario, generalmente se pasan al instanciar el cliente de Sentry.

<div id="bottle">
  ## Bottle
</div>

[Bottle](https://bottlepy.org/) es un microframework para Python. Raven es compatible con este framework mediante la integración WSGI.

<div id="installation">
  ### Instalación
</div>

Si aún no lo has hecho, empieza por descargar Raven. La forma más sencilla es con *pip*:

```bash
pip install raven --upgrade
```

<div id="setup">
  ### Configuración
</div>

Lo primero que debes hacer es desactivar el catchall en tu app de Bottle:

```python
import bottle

app = bottle.app()
app.catchall = False
```

<Alert level="warning" title="Nota">
  De forma predeterminada, Bottle no propagará las excepciones al middleware WSGI subyacente. Establecer catchall en False deshabilita este comportamiento.
</Alert>

Luego, Sentry actuará como middleware:

```python
from raven import Client
from raven.contrib.bottle import Sentry
client = Client('___DSN___')
app = Sentry(app, client)
```

### Uso

Una vez que hayas configurado la aplicación de Sentry, solo tienes que llamar a run con ella:

```python
run(app=app)
```

Si quieres enviar eventos adicionales, el objeto de la solicitud de Bottle contiene un par de accesos directos en app.

Captura cualquier excepción llamando a `captureException`:

```python
try:
    1 / 0
except ZeroDivisionError:
    request.app.sentry.captureException()
```

Registra un mensaje genérico con `captureMessage`:

```python
request.app.sentry.captureMessage('¡Hola, mundo!')
```

<div id="celery">
  ## Celery
</div>

[Celery](https://docs.celeryq.dev/) es un sistema distribuido de colas de tareas para Python basado en los principios de AMQP. Raven ofrece compatibilidad integrada con Celery, pero requiere cierta configuración manual.

<div id="installation">
  ### Instalación
</div>

Si aún no lo has hecho, empieza por descargar Raven. La forma más sencilla es con *pip*:

```bash
pip install raven --upgrade
```

<div id="setup">
  ### Configuración
</div>

Para capturar errores, debes registrar un par de señales para tomar el control del manejo de errores de Celery:

```python
from raven import Client
from raven.contrib.celery import register_signal, register_logger_signal

client = Client('___DSN___')

# registra un filtro personalizado para filtrar logs duplicados
register_logger_signal(client)

# La función register_logger_signal también puede recibir un argumento opcional
# `loglevel` que es el nivel utilizado para el handler creado.
# Por defecto es `logging.ERROR`
register_logger_signal(client, loglevel=logging.INFO)

# se conecta al manejador de errores de Celery
register_signal(client)

# La función register_signal también puede recibir un argumento opcional
# `ignore_expected` que hace que se ignoren las clases de excepción especificadas en Task.throws
#
register_signal(client, ignore_expected=True)
```

Una versión más avanzada para encapsular el comportamiento:

```python
import celery
import raven
from raven.contrib.celery import register_signal, register_logger_signal

class Celery(celery.Celery):

    def on_configure(self):
        client = raven.Client('___DSN___')

        # registra un filtro personalizado para descartar registros duplicados
        register_logger_signal(client)

        # conéctate al controlador de errores de Celery
        register_signal(client)

app = Celery(__name__)
app.config_from_object('django.conf:settings')
```

<div id="django">
  ## Django
</div>

Se admiten las versiones 1.4 a 2.0 de [Django](https://djangoproject.com/). Dado que este SDK está en proceso de retirada, las versiones más recientes de Django solo son compatibles con [el nuevo SDK de Python](/es/platforms/python/).

<div id="installation">
  ### Instalación
</div>

Si aún no lo has hecho, empieza por descargar Raven. La forma más sencilla es con *pip*:

```bash
pip install raven --upgrade
```

<div id="setup">
  ### Configuración
</div>

Usar la integración de Django es tan sencillo como añadir `raven.contrib.django.raven_compat` a tus aplicaciones instaladas:

```python
INSTALLED_APPS = (
    'raven.contrib.django.raven_compat',
)
```

Esto hace que Raven instale un gancho en Django que reportará automáticamente las excepciones no controladas.

La configuración adicional del cliente se define usando el diccionario `RAVEN_CONFIG`:

```python
import os
import raven

RAVEN_CONFIG = {
    'dsn': '___DSN___',
    # Si usas git, también puedes configurar automáticamente la
    # versión basándote en la información de git.
    'release': raven.fetch_git_sha(os.path.abspath(os.pardir)),
}
```

Una vez que hayas configurado el cliente, puedes probarlo usando la interfaz de administración estándar de Django:

```bash
python manage.py raven test
```

En Django también harás referencia al cliente de una forma ligeramente distinta:

```python
from raven.contrib.django.raven_compat.models import client

client.captureException()
```

<div id="using-with-ravenjs">
  ### Uso con Raven.js
</div>

Se proporciona una etiqueta de plantilla de Django para insertar un DSN público correcto en tus plantillas; primero debes cargar `raven`:

```django
{% load raven %}
```

Dentro de tu plantilla, ahora puedes usar:

```html
<script>
  Raven.config("{% sentry_public_dsn %}").install();
</script>
```

De forma predeterminada, el DSN se genera con una ruta relativa al protocolo, por ejemplo, `//public@example.com/1`. Si necesitas un protocolo específico, puedes reemplazarlo:

```html
{% sentry_public_dsn 'https' %}
```

Consulta la [*documentación de Raven.js*](/es/platforms/javascript/legacy-sdk/) para más información.

<div id="integration-with-logging">
  ### Integración con `logging`
</div>

Para integrarse con el módulo `logging` de la biblioteca estándar y enviar a Sentry todos los mensajes de nivel ERROR y superiores, puede utilizarse la siguiente configuración:

```python
LOGGING = {
    'version': 1,
    'disable_existing_loggers': True,
    'root': {
        'level': 'WARNING',
        'handlers': ['sentry'],
    },
    'formatters': {
        'verbose': {
            'format': '%(levelname)s  %(asctime)s  %(module)s '
                      '%(process)d  %(thread)d  %(message)s'
        },
    },
    'handlers': {
        'sentry': {
            'level': 'ERROR', # Para capturar más que ERROR, cambia a WARNING, INFO, etc.
            'class': 'raven.contrib.django.raven_compat.handlers.SentryHandler',
            'tags': {'custom-tag': 'x'},
        },
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'verbose'
        }
    },
    'loggers': {
        'django.db.backends': {
            'level': 'ERROR',
            'handlers': ['console'],
            'propagate': False,
        },
        'raven': {
            'level': 'DEBUG',
            'handlers': ['console'],
            'propagate': False,
        },
        'sentry.errors': {
            'level': 'DEBUG',
            'handlers': ['console'],
            'propagate': False,
        },
    },
}
```

<div id="usage">
  #### Uso
</div>

El registro de uso funciona igual que fuera de Django, con la adición de una clave opcional `request` en los datos adicionales:

```python
logger.error('Hubo un error inesperado', exc_info=True, extra={
    # Opcionalmente pasa un request y capturaremos toda la información posible
    'request': request,
})
```

<div id="404-logging">
  ### Registro de 404
</div>

En ciertas situaciones, quizá quieras registrar eventos 404 en el servidor de Sentry. Para hacerlo, solo necesitas habilitar un middleware de Django:

```python
# Usa ``MIDDLEWARE_CLASSES`` antes de Django 1.10
MIDDLEWARE = (
    'raven.contrib.django.raven_compat.middleware.Sentry404CatchMiddleware',
    ...,
) + MIDDLEWARE
```

Se recomienda colocar el middleware en la parte superior, para que solo se registren los 404 que hayan llegado hasta arriba. Ciertos middlewares (p. ej., flatpages) interceptan los 404 y reemplazan la respuesta.

También es posible configurar este middleware para ignorar 404 en páginas específicas definiendo el ajuste `IGNORABLE_404_URLS` como un iterable de patrones de expresiones regulares. Si algún patrón coincide con la URL completa solicitada (según el método `search` de la expresión regular), entonces el 404 no se reportará a Sentry.

```python
import re

IGNORABLE_404_URLS = (
    re.compile('/foo'),
)
```

<div id="message-references">
  ### Referencias de mensajes
</div>

Sentry permite enviar un ID de mensaje a tus clientes para que tu equipo de desarrollo pueda rastrearlos fácilmente. Hay dos formas de acceder a esta información: la primera es mediante el encabezado de respuesta HTTP `X-Sentry-ID`. Agregarlo es tan sencillo como añadir un middleware a tu stack:

```python
# Usa ``MIDDLEWARE_CLASSES`` en versiones anteriores a Django 1.10
MIDDLEWARE = MIDDLEWARE + (
  # Recomendamos colocar esto lo más arriba posible en la cadena
  'raven.contrib.django.raven_compat.middleware.SentryResponseErrorIdMiddleware',
  ...,
)
```

Otro método alternativo es renderizarlo dentro de una plantilla. De forma predeterminada, Sentry adjunta `request.sentry` cuando captura una excepción de Django. En nuestro ejemplo, usaremos esta información para modificar el `500.html` predeterminado que se renderiza y mostrar al usuario un ID de referencia del caso. El primer paso para hacerlo es crear un `handler500()` personalizado en tu archivo `urls.py`:

```python
from django.conf.urls.defaults import *

from django.views.defaults import page_not_found, server_error
from django.template.response import TemplateResponse

def handler500(request):
    """Manejador de error 500 que incluye ``request`` en el contexto.

 Plantillas: `500.html`
 Contexto: Ninguno
 """

    context = {'request': request}
    template_name = '500.html'  # Debes crear una plantilla 500.html.
    return TemplateResponse(request, template_name, context, status=500)
```

Una vez que hayamos agregado correctamente la variable de contexto `request`, añadir el ID de referencia de Sentry a nuestro `500.html` es sencillo:

```html
<p>¡Vaya, te has encontrado con un error!</p>
{% if request.sentry.id %}
<p>
  Si necesitas ayuda, puedes usar este identificador de error:
  <strong>{{ request.sentry.id }}</strong>.
</p>
{% endif %}
```

<div id="wsgi-middleware">
  ### Middleware WSGI
</div>

Si usas una interfaz WSGI para servir tu aplicación, también puedes aplicar un middleware que garantizará que detectes errores incluso en los niveles más fundamentales de tu aplicación Django:

```python
from raven.contrib.django.raven_compat.middleware.wsgi import Sentry
from django.core.wsgi import get_wsgi_application

application = Sentry(get_wsgi_application())
```

<div id="user-feedback">
  ### Comentarios de usuarios
</div>

Para habilitar los comentarios de los usuarios en los informes de fallos, empieza por asegurarte de que el valor `request` esté disponible en tus procesadores de contexto:

```python
TEMPLATE_CONTEXT_PROCESSORS = (
    # ...
    'django.core.context_processors.request',
)
```

De forma predeterminada, Django representará `500.html`, así que basta con colocar el siguiente fragmento en tu plantilla:

```html
<!-- Se requiere Sentry JS SDK 2.1.+ -->
<script src="https://cdn.ravenjs.com/2.3.0/raven.min.js"></script>

{% if request.sentry.id %}
<script>
  Raven.showReportDialog({
    eventId: "{{ request.sentry.id }}",

    // usa el DSN público (¡no incluyas tu clave secreta!)
    dsn: "___PUBLIC_DSN___",
  });
</script>
{% endif %}
```

¡Listo!

Para obtener más información sobre esta función, consulta la [*guía de comentarios de usuarios*](/es/platforms/python/user-feedback/).

<div id="additional-settings">
  ### Configuración adicional
</div>

`SENTRY_CLIENT`

En algunas situaciones, quizá quieras un comportamiento ligeramente distinto en la forma en que Sentry se comunica con tu servidor. Para ello, Raven te permite especificar un cliente personalizado:

```python
SENTRY_CLIENT = 'raven.contrib.django.raven_compat.DjangoClient'
```

`SENTRY_CELERY_LOGLEVEL`

Si también usas Celery, se registra automáticamente un controlador que captura los errores de los workers. El nivel de registro predeterminado para ese controlador es `logging.ERROR` y puede personalizarse con esta configuración:

```python
SENTRY_CELERY_LOGLEVEL = logging.INFO
```

Como alternativa, puedes usar una clave de nombre similar en `RAVEN_CONFIG`:

```python
RAVEN_CONFIG = {
    'CELERY_LOGLEVEL': logging.INFO
}
```

`SENTRY_CELERY_IGNORE_EXPECTED`

Si también usas Celery, puedes ignorar las excepciones esperadas estableciendo esto en `True`. Esto hará que se omitan las clases de excepción en `Task.throws`.

<div id="caveats">
  ### Advertencias
</div>

Ten en cuenta lo siguiente al usar Raven con Django.

<div id="error-handling-middleware">
  #### Middleware de gestión de errores
</div>

Si ya cuentas con un middleware que maneja `process_exception()`, deberás tener especial cuidado al usar Sentry.

Por ejemplo, el siguiente middleware suprimiría el registro en Sentry porque devuelve una respuesta:

```python
class MyMiddleware(object):
    def process_exception(self, request, exception):
        return HttpResponse('foo')
```

Para evitar esto, puedes desactivar tu middleware de manejo de errores o añadir algo como lo siguiente:

```python
from django.core.signals import got_request_exception

class MyMiddleware(object):
    def process_exception(self, request, exception):
        # Asegúrate de que se dispare la señal de excepción para Sentry
        got_request_exception.send(sender=self, request=request)
        return HttpResponse('foo')
```

<Alert level="warning" title="Nota">
  Esta técnica puede hacer que fallen las pruebas unitarias que usan el cliente de pruebas de Django (`django.test.client.Client`) si una vista en prueba genera una excepción `Http404` o `PermissionDenied`, porque dichas excepciones no se convertirán en los códigos de respuesta esperados 404 o 403.
</Alert>

O, si lo prefieres, puedes habilitar las respuestas de Sentry:

```python
from raven.contrib.django.raven_compat.models import sentry_exception_handler

class MyMiddleware(object):
    def process_exception(self, request, exception):
        # Asegúrate de que se dispare la señal de excepción para Sentry
        sentry_exception_handler(request=request)
        return HttpResponse('foo')
```

<div id="circus">
  #### Circus
</div>

Si estás ejecutando Django con [circus](https://circus.rtfd.org/) y [chaussette](https://chaussette.readthedocs.io/), también necesitarás añadir un hook a circus para activar Raven:

```python
from django.conf import settings
from django.core.management import call_command

def run_raven(*args, **kwargs):
    """Configura Raven para Django ejecutando un comando de Django.
 Es necesario porque Chaussette no ejecuta ningún comando de Django.
 """
    if not settings.configured:
        settings.configure()

    call_command('validate')
    return True
```

Y en la configuración de Circus:

```ini
[socket:dwebapp]
host = 127.0.0.1
port = 8080

[watcher:dwebworker]
cmd = chaussette --fd $(circus.sockets.dwebapp) dproject.wsgi.application
use_sockets = True
numprocesses = 2
hooks.after_start = dproject.hooks.run_raven
```

<div id="flask">
  ## Flask
</div>

<div id="installation">
  ### Instalación
</div>

Si aún no lo has hecho, instala raven junto con sus dependencias explícitas de Flask:

```bash
pip install raven[flask]
```

<div id="setup">
  ### Configuración
</div>

Lo primero que debes hacer es inicializar Raven en tu aplicación:

```python
from raven.contrib.flask import Sentry
sentry = Sentry(app, dsn='___DSN___')
```

Si no especificas el valor de `dsn`, intentaremos obtenerlo del entorno en la clave `SENTRY_DSN`.

<div id="extended-setup">
  ### Configuración avanzada
</div>

Opcionalmente, también puedes configurar el registro:

```python
import logging
from raven.contrib.flask import Sentry
sentry = Sentry(app, logging=True, level=logging.ERROR, \
                logging_exclusions=("logger1", "logger2", ...))
```

¿Estás creando aplicaciones sobre la marcha? Puedes usar el hook `init_app` de Raven:

```python
sentry = Sentry(dsn='http://public_key:secret_key@example.com/1')

def create_app():
    app = Flask(__name__)
    sentry.init_app(app)
    return app
```

Puedes pasar parámetros en el hook `init_app`:

```python
sentry = Sentry()

def create_app():
    app = Flask(__name__)
    sentry.init_app(app, dsn='___DSN___', logging=True,
                    level=logging.ERROR,
                    logging_exclusions=("logger1", "logger2", ...))
    return app
```

<div id="setup">
  ### Configuración
</div>

Puedes configurar opciones adicionales para el cliente usando `SENTRY_CONFIG` en la configuración de tu aplicación:

```python
class MyConfig(object):
    SENTRY_CONFIG = {
        'dsn': '___DSN___',
        'include_paths': ['myproject'],
        'release': raven.fetch_git_sha(os.path.dirname(__file__)),
    }
```

Si tu aplicación utiliza [Flask-Login](https://pypi.python.org/pypi/Flask-Login/) (incluido [Flask-Security](https://pypi.python.org/pypi/Flask-Security/)), la información del usuario se registrará cuando se capture una excepción o un mensaje. De forma predeterminada, solo se capturan para el usuario el `id` (current&#95;user.get&#95;id()), `is_authenticated` e `is_anonymous`. Si quieres capturar atributos adicionales de `current_user`, puedes configurarlos con `SENTRY_USER_ATTRS`:

```python
class MyConfig(object):
    SENTRY_USER_ATTRS = ['username', 'first_name', 'last_name', 'email']
```

`email` se capturará como `sentry.interfaces.User.email`, y cualquier atributo adicional estará disponible en `sentry.interfaces.User.data`.

Puedes especificar los tipos de excepciones que no deben notificarse por el cliente de Sentry en tu aplicación estableciendo el valor de configuración `ignore_exceptions`:

```python
class MyExceptionType(Exception):
    def __init__(self, mensaje):
        super(MyExceptionType, self).__init__(mensaje)

app = Flask(__name__)
app.config['SENTRY_CONFIG'] = {
    'ignore_exceptions': [MyExceptionType],
}
```

### Uso

Una vez que hayas configurado la aplicación de Sentry, capturará automáticamente las excepciones no controladas en Flask. Si quieres enviar eventos adicionales, el objeto de middleware de Sentry para Flask ofrece un par de atajos.

Captura una excepción arbitraria llamando a `captureException`:

```python
try:
    1 / 0
except ZeroDivisionError:
    sentry.captureException()
```

Registra un mensaje genérico con `captureMessage`:

```python
sentry.captureMessage('hola, mundo')
```

<div id="getting-the-last-event-id">
  ### Obtener el último ID de evento
</div>

Cuando es posible, el último ID de evento de Sentry se almacena en la variable `g.sentry_event_id` del contexto de la solicitud. Esto permite mostrar al usuario un ID de error si has creado una página personalizada para el error 500.

```html
<h2>Error 500</h2>
{% if g.sentry_event_id %}
<p>El identificador del error es {{ g.sentry_event_id }}</p>
{% endif %}
```

<div id="user-feedback">
  ### Comentarios de usuarios
</div>

Para habilitar los comentarios de los usuarios en los informes de fallos, asegúrate de tener un controlador personalizado para el error *500* y de renderizar un fragmento HTML que abra el cuadro de diálogo de fallo:

```python
from flask import Flask, g, render_template
from raven.contrib.flask import Sentry

app = Flask(__name__)
sentry = Sentry(app, dsn='___DSN___')

@app.errorhandler(500)
def internal_server_error(error):
    return render_template('500.html',
        event_id=g.sentry_event_id,
        public_dsn=sentry.client.get_public_dsn('https')
    )
```

Y en la plantilla de error (`500.html`) puedes hacer lo siguiente:

```html
<!-- Se requiere Sentry JS SDK 2.1.+ -->
<script src="https://cdn.ravenjs.com/2.3.0/raven.min.js"></script>

{% if event_id %}
<script>
  Raven.showReportDialog({
    eventId: "{{ event_id }}",
    dsn: "{{ public_dsn }}",
  });
</script>
{% endif %}
```

¡Listo!

Para más información sobre esta función, consulta la [*guía de comentarios de usuario*](/es/platforms/python/user-feedback/).

<div id="dealing-with-proxies">
  ### Manejo de proxies
</div>

Cuando tu aplicación Flask está detrás de un proxy como nginx, Sentry usará la dirección remota del proxy en lugar de la de la máquina que realiza la solicitud. Al usar `ProxyFix` de `werkzeug.contrib.fixers`, puedes modificar la `.wsgi_app` de Flask para enviar la `REMOTE_ADDR` real a Sentry.

```python
from werkzeug.contrib.fixers import ProxyFix
app.wsgi_app = ProxyFix(app.wsgi_app)
```

Esto también puede requerir [cambios](https://flask.palletsprojects.com/en/1.1.x/deploying/wsgi-standalone/#proxy-setups) en la configuración del proxy para transmitir los encabezados adecuados si aún no lo hace.

<div id="signals">
  ### Señales
</div>

Raven usa [blinker](https://github.com/jek/blinker) para emitir una señal (llamada `logging_configured`) después de que se haya configurado el logging para el cliente. Puedes suscribirte a esa señal en tu aplicación para realizar cualquier configuración adicional del controlador de logging `SentryHandler`.

```python
from raven.contrib.flask import Sentry, logging_configured
from flask import Flask, g, render_template
from raven.contrib.flask import Sentry

app = Flask(__name__)
sentry = Sentry(app, dsn='___DSN___', logging=True)

@logging_configured.connect
def internal_server_error(sender, sentry_handler=None, **kwargs):
    # configura aquí sentry_handler
    sentry_handler.addFilter(some_filter)
```

<div id="amazon-web-services-lambda">
  ## Amazon Web Services Lambda
</div>

<div id="installation">
  ### Instalación
</div>

Para usar [Sentry](https://getsentry.com/) con [AWS Lambda](https://aws.amazon.com/lambda), debes instalar *raven* como una dependencia externa. Esto implica crear un [paquete de despliegue](https://docs.aws.amazon.com/lambda/latest/dg/lambda-python-how-to-create-deployment-package.html) y subirlo a AWS.

Para instalar raven en el directorio actual de tu proyecto:

```shell
pip install raven -t /ruta/al/directorio-del-proyecto
```

<div id="setup">
  ### Configuración
</div>

Crea una instancia de *LambdaClient* y envuelve tu controlador de Lambda con el decorador *capture&#95;exceptions*:

```python
from raven.contrib.awslambda import LambdaClient

client = LambdaClient()

@client.capture_exceptions
def handler(event, context):
    ...
    raise Exception('¡Se enviará a Sentry!')
```

De forma predeterminada, esto enviará a Sentry las excepciones y errores no gestionados.

El `LambdaClient` acepta los mismos argumentos que el `Client` estándar; consulta [*Configuring the Client*](/es/platforms/python/legacy-sdk/advanced/#python-client-config).

La integración se inspiró en [raven python lambda](https://github.com/Netflix-Skunkworks/raven-python-lambda), otra implementación que también se integra con Serverless Framework y admite transporte SQS.

<div id="logbook">
  ## Registro
</div>

<div id="installation">
  ### Instalación
</div>

Si aún no lo has hecho, empieza por descargar Raven. La forma más sencilla es con *pip*:

```bash
pip install raven --upgrade
```

<div id="setup">
  ### Configuración
</div>

Raven proporciona un controlador de [logbook](https://logbook.readthedocs.io) que enviará mensajes a Sentry.

Primero debes configurar un controlador:

```python
from raven.handlers.logbook import SentryHandler

# Especifica un cliente manualmente
client = Client(...)
handler = SentryHandler(client)
```

También puedes configurar el cliente predeterminado automáticamente con un DSN:

```python
# Configura el cliente predeterminado
handler = SentryHandler('___DSN___')
```

Finalmente, vincula tu controlador a tu contexto:

```python
from raven.handlers.logbook import SentryHandler

client = Client(...)
sentry_handler = SentryHandler(client)
with sentry_handler.applicationbound():
    # todo lo que se registre aquí se enviará a Sentry.
    ...
```

<div id="logging">
  ## Registro de actividad
</div>

<div id="installation">
  ### Instalación
</div>

Si aún no lo has hecho, empieza por descargar Raven. La forma más fácil es con *pip*:

```bash
pip install raven --upgrade
```

<div id="setup">
  ### Configuración
</div>

Sentry permite integrarse directamente con el módulo `logging`. Para usarlo, simplemente agrega `SentryHandler` a tu logger.

Primero, necesitas configurar un handler:

```python
from raven.handlers.logging import SentryHandler

# Especificar manualmente un cliente
client = Client(...)
handler = SentryHandler(client)
```

También puedes configurar automáticamente el cliente por defecto con un DSN:

```python
# Configura el cliente predeterminado
handler = SentryHandler('___DSN___')
```

Quizá quieras especificar el nivel de logging en este punto para no enviar mensajes INFO o DEBUG a Sentry:

```python
handler.setLevel(logging.ERROR)
```

Por último, llama a la función auxiliar `setup_logging()`:

```python
from raven.conf import setup_logging

setup_logging(handler)
```

Otra opción es utilizar `logging.config.dictConfig`:

```python
LOGGING = {
    'version': 1,
    'disable_existing_loggers': True,

    'formatters': {
        'console': {
            'format': '[%(asctime)s][%(levelname)s] %(name)s '
                      '%(filename)s:%(funcName)s:%(lineno)d | %(message)s',
            'datefmt': '%H:%M:%S',
            },
        },

    'handlers': {
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'console'
            },
        'sentry': {
            'level': 'ERROR',
            'class': 'raven.handlers.logging.SentryHandler',
            'dsn': '___DSN___',
            },
        },

    'loggers': {
        '': {
            'handlers': ['console', 'sentry'],
            'level': 'DEBUG',
            'propagate': False,
            },
        'your_app': {
            'level': 'DEBUG',
            'propagate': True,
        },
    }
}
```

<div id="usage">
  #### Uso
</div>

Un patrón recomendado para el registro (logging) es usar simplemente el nombre del módulo para cada logger. Por ejemplo, podrías definir lo siguiente al inicio de tu módulo:

```python
import logging
logger = logging.getLogger(__name__)
```

También puedes usar los argumentos `exc_info` y `extra={'stack': True}` en tus métodos `log`. Esto almacenará la información adecuada y permitirá que Sentry la muestre en función de esa información:

```python
# Si realmente estás capturando una excepción, usa `exc_info=True`
logger.error('Ocurrió un error, con traza de pila.', exc_info=True)

# Si no hay una excepción pero igual quieres capturar la traza,
# usa el argumento `stack`
logger.error('Ocurrió un error, con traza de pila.', extra={
    'stack': True,
})
```

<Alert title="Nota sobre la versión de Python">
  Según la versión de Python que estés usando, `extra` podría no ser un argumento con nombre válido para el método `.exception()` de un logger (`.debug()`, `.info()`, `.warning()`, `.error()` y `.critical()` deberían funcionar bien independientemente de la versión de Python). Esto se corrigió a partir de Python 2.7.4 y 3.2. Incidencia oficial: [bugs.python.org/issue15541](https://bugs.python.org/issue15541).
</Alert>

Aunque no lo recomendamos, también puedes habilitar la captura implícita de la pila para todos los mensajes:

```python
client = Client(..., auto_log_stacks=True)
handler = SentryHandler(client)

logger.error('¡Hubo un error, con un seguimiento de pila!')
```

También puedes pasar etiquetas y el contexto del usuario mediante extra:

```python
logger.error('Se produjo un error, con contexto de usuario y etiquetas'), extra={
    'user': {'email': 'test@test.com'},
    'tags': {'database': '1.0'},
})
```

También puedes enviar información adicional para almacenarla como metadatos del evento. Siempre que el nombre de la clave no esté reservado ni sea privado (&#95;foo), se mostrará en el panel de Sentry. Para hacerlo, inclúyela como `data` dentro de tu sección `extra`:

```python
logger.error('Se produjo un error inesperado', exc_info=True, extra={
    # Opcionalmente, puedes pasar argumentos adicionales para especificar información de la solicitud
    'culprit': 'my.view.name',
    'fingerprint': [...],

    'data': {
        # Puedes especificar cualquier valor aquí y Sentry los registrará y mostrará
        'username': request.user.username,
    }
})
```

Las claves `url` y `view` se usan internamente por Sentry dentro de los datos extra.

Cualquier clave (en `data`) con el prefijo `_` no se mostrará automáticamente en la vista de detalles de Sentry.

Sentry agrupa de forma inteligente los mensajes si usas un formato de cadena adecuado. Por ejemplo, los siguientes mensajes se considerarían el mismo mensaje dentro de Sentry:

```python
logger.error('Hubo un error %s', 'crazy')
logger.error('Hubo un error %s', 'fun')
logger.error('Hubo un error %s', 1)
```

<div id="exclusions">
  #### Exclusiones
</div>

También puedes configurar algunas exclusiones de registro durante la instalación. Estos registradores no enviarán sus logs al controlador de Sentry:

```python
from raven.conf import setup_logging

setup_logging(handler, exclude=("logger1", "logger2", ...))
```

<div id="pylons">
  ## Pylons
</div>

Pylons es un framework de Python.

<div id="installation">
  ### Instalación
</div>

Si aún no lo has hecho, empieza descargando Raven. La forma más sencilla es con *pip*:

```bash
pip install raven --upgrade
```

{/*<!-- WIZARD pylons -->*/}

<div id="wsgi-middleware">
  ### Middleware WSGI
</div>

Existe un middleware específico de Pylons que permite configurar fácilmente desde la configuración:

```python
from raven.contrib.pylons import Sentry

application = Sentry(application, config)
```

La configuración se gestiona mediante el espacio de nombres sentry:

```ini
[sentry]
dsn=___DSN___
include_paths=my.package,my.other.package,
exclude_paths=my.package.crud
```

### Configuración del registro

Añade las siguientes líneas al archivo *.ini* de tu proyecto para configurar *SentryHandler*:

```ini
[loggers]
keys = root, sentry

[handlers]
keys = console, sentry

[formatters]
keys = generic

[logger_root]
level = INFO
handlers = console, sentry

[logger_sentry]
level = WARN
handlers = console
qualname = sentry.errors
propagate = 0

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[handler_sentry]
class = raven.handlers.logging.SentryHandler
args = ('SENTRY_DSN',)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(asctime)s,%(msecs)03d %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
```

Quizá también quieras configurar otros registradores.

{/*<!-- TODO-AÑADIR EJEMPLO DE VERIFICACIÓN -->*/}

<div id="pyramid">
  ## Pirámide
</div>

<div id="installation">
  ### Instalación
</div>

Si aún no lo has hecho, empieza por descargar Raven. La forma más sencilla es con *pip*:

```bash
pip install raven --upgrade
```

{/*<!-- ASISTENTE pirámide -->*/}

<div id="pastedeploy-filter">
  ### Filtro de PasteDeploy
</div>

Existe una factoría de filtros para [PasteDeploy](https://pastedeploy.readthedocs.io/en/latest/) que permite insertar Raven fácilmente en una canalización WSGI:

```ini
[pipeline:main]
pipeline =
 raven
 tm
 MyApp

[filter:raven]
use = egg:raven#raven
dsn = ___DSN___
include_paths = my.package, my.other.package
exclude_paths = my.package.crud
```

En la sección `[filter:raven]`, debes especificar el punto de entrada de raven con la clave `use =`. Todos los demás parámetros del cliente de raven también se pueden incluir en esta sección.

Consulta la [documentación de configuración de Pyramid PasteDeploy](https://docs.pylonsproject.org/projects/pyramid/en/latest/narr/paste.html) para obtener más información.

<div id="logger-setup">
  ### Configuración del registrador
</div>

Agrega las siguientes líneas al archivo *.ini* de tu proyecto para configurar *SentryHandler*:

```ini
[loggers]
keys = root, sentry

[handlers]
keys = console, sentry

[formatters]
keys = generic

[logger_root]
level = INFO
handlers = console, sentry

[logger_sentry]
level = WARN
handlers = console
qualname = sentry.errors
propagate = 0

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[handler_sentry]
class = raven.handlers.logging.SentryHandler
args = ('___DSN___',)
level = WARNING
formatter = generic

[formatter_generic]
format = %(asctime)s,%(msecs)03d %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
```

Puede que también quieras configurar otros registradores. Consulta la [documentación sobre registro de Pyramid](https://docs.pylonsproject.org/projects/pyramid/en/latest/narr/logging.html) para obtener más información.

En lugar de definir el DSN en el archivo *.ini*, también puedes usar la variable de entorno `SENTRY_DSN`, que reemplaza la configuración de este archivo. Debido a una comprobación de sintaxis, no puedes eliminar por completo la opción `args`; como alternativa, puedes definir una lista vacía de argumentos: `args = ()`.

<div id="rq">
  ## RQ
</div>

Desde la versión 0.3.1 de RQ, Sentry cuenta con compatibilidad integrada.

{/*<!-- ASISTENTE rq -->*/}

### Uso

RQ admite de forma nativa la integración con Sentry pasando tu `SENTRY_DSN` a `rqworker`:

```bash
rqworker --sentry-dsn="___DSN___"
```

<div id="extended-setup">
  ### Configuración avanzada
</div>

Si quieres pasar información adicional, como `release`, tendrás que vincular tu propia instancia del `Client` de Sentry:

```python
from raven import Client
from raven.transport.http import HTTPTransport
from rq.contrib.sentry import register_sentry

client = Client('___DSN___', transport=HTTPTransport)
register_sentry(client, worker)
```

Consulta la documentación de `rq` para obtener más información: [python-rq.org/patterns/sentry/](https://python-rq.org/patterns/sentry/)

<div id="tornado">
  ## Tornado
</div>

Tornado es un framework web asíncrono para Python.

<div id="installation">
  ### Instalación
</div>

Si aún no lo has hecho, comienza por descargar Raven. La forma más sencilla es con *pip*:

```bash
pip install raven --upgrade
```

<div id="setup">
  ### Configuración
</div>

Lo primero que debes hacer es inicializar el cliente de Sentry en tu aplicación

```python
import tornado.web
from raven.contrib.tornado import AsyncSentryClient

class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.write("Hola, mundo")

application = tornado.web.Application([
    (r"/", MainHandler),
])
application.sentry_client = AsyncSentryClient(
    '___DSN___'
)
```

### Uso

Una vez que el cliente de Sentry esté integrado en la aplicación, los controladores de solicitudes pueden capturar automáticamente las excepciones no controladas heredando de la clase *SentryMixin*.

```python
import tornado.web
from raven.contrib.tornado import SentryMixin

class UncaughtExceptionExampleHandler(
        SentryMixin, tornado.web.RequestHandler):
    def get(self):
        1/0
```

También puedes enviar eventos manualmente usando los accesos directos definidos en *SentryMixin*. Estos accesos directos se pueden usar tanto de forma asíncrona como síncrona.

<div id="asynchronous">
  #### Asincrónico
</div>

```python
import tornado.web
import tornado.gen
from raven.contrib.tornado import SentryMixin

class AsyncMessageHandler(SentryMixin, tornado.web.RequestHandler):
    @tornado.web.asynchronous
    @tornado.gen.engine
    def get(self):
        self.write("Has solicitado la página principal")
        yield tornado.gen.Task(
            self.captureMessage, "Solicitud de la página principal atendida"
        )
        self.finish()

class AsyncExceptionHandler(SentryMixin, tornado.web.RequestHandler):
    @tornado.web.asynchronous
    @tornado.gen.engine
    def get(self):
        try:
            raise ValueError()
        except Exception as e:
            response = yield tornado.gen.Task(
                self.captureException, exc_info=True
            )
        self.finish()
```

<Alert title="Consejo">
  El valor que devuelve yield es un objeto `HTTPResponse`.

  Para usar Python de forma dinámica cuando haya disponible un DSN de configuración, cambia tu controlador base sobre la marcha y asegúrate de importar todos los controladores concretos después de esto.

  > ```python
  > from raven.contrib.tornado import SentryMixin
  > app.sentry_client = AsyncSentryClient(dsn)
  > BaseHandler.__bases__ = (SentryMixin, ) + BaseHandler.__bases__
  > ```
</Alert>

<div id="synchronous">
  #### Sincrónico
</div>

```python
import tornado.web
from raven.contrib.tornado import SentryMixin

class AsyncExampleHandler(SentryMixin, tornado.web.RequestHandler):
    def get(self):
        self.write("Has solicitado la página principal")
        self.captureMessage("Se atendió la solicitud de la página principal")
```

## Middleware WSGI

Raven incluye un middleware WSGI fácil de usar.

```python
from raven import Client
from raven.middleware import Sentry

application = Sentry(
    application,
    Client('___DSN___')
)
```

Muchos frameworks no propagan las excepciones al middleware WSGI subyacente de forma predeterminada.

<div id="zconfig-logging-configuration">
  ## Configuración de logging de ZConfig
</div>

[ZConfig](https://zconfig.readthedocs.io/en/latest/using-logging.html) proporciona un mecanismo de configuración para el módulo de logging de Python.

Para obtener más información, consulta:

> [zconfig.readthedocs.io/en/latest/using-logging.html](https://zconfig.readthedocs.io/en/latest/using-logging.html)

Para usarlo con Sentry, utiliza la etiqueta del handler de Sentry:

```xml
<logger>
  nivel INFO
  <logfile>
   path ${buildout:directory}/var/{:_buildout_section_name_}.log
   nivel INFO
  </logfile>

  %import raven.contrib.zconfig
  <sentry>
    dsn ___DSN___
    nivel ERROR
  </sentry>
</logger>
```

Esta configuración mantiene el registro normal en un archivo de registro, pero añade el registro en Sentry para los errores.

Se admiten todas las opciones de `raven.base.Client`.

<div id="zerorpc">
  ## ZeroRPC
</div>

ZeroRPC es una biblioteca ligera, confiable y agnóstica al lenguaje para la comunicación distribuida entre procesos del lado del servidor.

<div id="installation">
  ### Instalación
</div>

Si aún no lo has hecho, comienza por descargar Raven. La forma más fácil es con *pip*:

```bash
pip install raven --upgrade
```

<div id="setup">
  ### Configuración
</div>

La integración de ZeroRPC se ofrece como middleware para ZeroRPC. El middleware se puede configurar igual que el cliente original de Raven (usando argumentos con nombre) y registrarse en el administrador de contexto de ZeroRPC:

```python
import zerorpc

from raven.contrib.zerorpc import SentryMiddleware

sentry = SentryMiddleware(dsn='___DSN___')
zerorpc.Context.get_instance().register_middleware(sentry)
```

De forma predeterminada, el middleware ocultará las tramas internas de ZeroRPC cuando envíe excepciones a Sentry. Este comportamiento puede desactivarse pasando el parámetro `hide_zerorpc_frames` al middleware:

```python
sentry = SentryMiddleware(hide_zerorpc_frames=False, dsn='___DSN___')
```

<div id="compatibility">
  ### Compatibilidad
</div>

* ZeroRPC-Python &lt; 0.4.0 es compatible con Raven &lt;= 3.1.0;
* ZeroRPC-Python &gt;= 0.4.0 requiere Raven &gt; 3.1.0.

<div id="zopeplone">
  ## Zope/Plone
</div>

<div id="installation">
  ### Instalación
</div>

Si aún no lo has hecho, empieza por descargar Raven. La forma más sencilla es con *pip*:

```bash
pip install raven --upgrade
```

<div id="zopeconf">
  ### zope.conf
</div>

Zope ofrece opciones de configuración de registros extensibles. La configuración de registros para una instancia básica (que no sea cliente ZEO) se vería así:

```xml
<eventlog>
  nivel INFO
  <logfile>
   path ${buildout:directory}/var/{:_buildout_section_name_}.log
   level INFO
  </logfile>

  %import raven.contrib.zope
  <sentry>
    dsn ___DSN___
    nivel ERROR
  </sentry>
</eventlog>
```

Esta configuración mantiene el registro normal en un archivo de log, pero añade el registro en Sentry para los errores.

Se admiten todas las opciones de `raven.base.Client`.

Usa una receta de buildout en lugar de editar zope.conf directamente. Para añadir la configuración de instancia equivalente, harías lo siguiente:

```
[instance]
recipe = plone.recipe.zope2instance
...
event-log-custom =
 %import raven.contrib.zope
 <logfile>
 path ${buildout:directory}/var/instance.log
 level INFO
 </logfile>
 <sentry>
 dsn ___DSN___
 level ERROR
 </sentry>
```

Para añadir la configuración equivalente del cliente ZEO, harías lo siguiente:

```
[instance]
recipe = plone.recipe.zope2instance
...
event-log-custom =
 %import raven.contrib.zope
 <logfile>
 path ${buildout:var-dir}/${:_buildout_section_name_}/event.log
 level INFO
 </logfile>
 <sentry>
 dsn ___DSN___
 level ERROR
 </sentry>
```

---
title: Instrumentación de colas
sidebar_order: 3000
description: "Aprende a instrumentar manualmente tu código para usar el módulo de colas de Sentry. "
---

Sentry incluye un [panel de monitoreo de colas](https://sentry.io/orgredirect/organizations/:orgslug/insights/backend/queues/) que puede instrumentarse automáticamente para configuraciones populares de colas en Python (como <PlatformLink to="/integrations/celery/">Celery</PlatformLink>).

Si la tuya no es compatible, aún puedes instrumentar spans y transacciones personalizados alrededor de tus productores y consumidores de colas para asegurarte de contar con datos de rendimiento sobre tus colas de mensajería.

<div id="producer-instrumentation">
  ## Instrumentación del productor
</div>

Para empezar a capturar métricas de rendimiento, usa la función `sentry_sdk.start_span()` para envolver los eventos de tu productor de colas. El `op` de tu span debe establecerse en `queue.publish`. Incluye los siguientes datos del span para enriquecer los spans del productor con métricas de la cola:

| Data Attribute | Type | Description |
|:--|:--|:--|
| `messaging.message.id ` | string | El identificador del mensaje |
| `messaging.destination.name` | string | El nombre de la cola o del tema |
| `messaging.message.body.size` | int | Tamaño del cuerpo del mensaje en bytes |

Tu span `queue.publish` debe existir dentro de una transacción para que se reconozca como un span de productor. Si estás usando un <PlatformLink to="/integrations/#web-frameworks">framework web compatible</PlatformLink>, la transacción la crea la integración. Si usas Python a secas, puedes iniciar una nueva con `sentry_sdk.start_transaction()`.

También debes incluir encabezados de trace (`sentry-trace` y `baggage`) en tu mensaje para que tus consumidores puedan continuar el trace una vez que se procese tu mensaje.

```python
from datetime import datetime, timezone

import sentry_sdk
import my_custom_queue

# Inicializar Sentry
sentry_sdk.init(...)

connection = my_custom_queue.connect()

# El mensaje que quieres enviar a la cola
queue = "messages"
message = "Hello World!"
message_id = "abc123"

# Crear transacción
# Si usas un framework web, la integración del framework
# creará esto automáticamente y puedes omitir este paso.
with sentry_sdk.start_transaction(
    op="function",
    name="queue_producer_transaction",
):
    # Crear el span
    with sentry_sdk.start_span(
        op="queue.publish",
        name="queue_producer",
    ) as span:
        # Establecer datos del span
        span.set_data("messaging.message.id", message_id)
        span.set_data("messaging.destination.name", queue)
        span.set_data("messaging.message.body.size", len(message.encode("utf-8")))

        # Publicar el mensaje en la cola (incluyendo información de rastreo y marca de tiempo actual)
        now = int(datetime.now(timezone.utc).timestamp())
        connection.publish(
            queue=queue,
            body=message,
            timestamp=now,
            headers={
                "sentry-trace": sentry_sdk.get_traceparent(),
                "baggage": sentry_sdk.get_baggage(),
            },
        )
```


<div id="consumer-instrumentation">
  ## Instrumentación de consumidores
</div>

Para empezar a capturar métricas de rendimiento, usa la función `sentry_sdk.start_span()` para envolver tus consumidores de colas. El `op` del span debe establecerse en `queue.process`. Incluye los siguientes datos de span para enriquecer tus spans de consumidor con métricas de la cola:

| Data Attribute | Type | Description |
|:--|:--|:--|
| `messaging.message.id ` | string | El identificador del mensaje |
| `messaging.destination.name` | string | El nombre de la cola o del tema |
| `messaging.message.body.size` | number | Tamaño del cuerpo del mensaje en bytes |
| `messaging.message.retry.count ` | number | La cantidad de veces que se intentó procesar un mensaje |
| `messaging.message.receive.latency ` | number | El tiempo en milisegundos que un mensaje esperó en la cola antes de ser procesado |

Tu span `queue.process` debe existir dentro de una transacción para que se reconozca como un span de consumidor. Si estás usando un <PlatformLink to="/integrations/#web-frameworks">framework web compatible</PlatformLink>, la transacción la crea la integración. Si usas Python puro, puedes iniciar una nueva con `sentry_sdk.start_transaction()`.

Usa `sentry_sdk.continue_trace()` para conectar tus spans de consumidor con sus spans de productor asociados, y `transaction.set_status()` para marcar el rastro de tu mensaje como correcto o fallido.

```python
from datetime import datetime, timezone

import sentry_sdk
import my_custom_queue

# Inicializar Sentry
sentry_sdk.init(...)

connection = my_custom_queue.connect()

# Obtener mensaje de las colas
queue = "messages"
message = connection.consume(queue=queue)

# Calcular latencia (opcional, pero valioso)
now = datetime.now(timezone.utc)
message_time = datetime.fromtimestamp(message["timestamp"], timezone.utc)
latency = now - message_time

# Continuar el rastreo iniciado en el productor
# Si usas un framework web, la integración del framework
# creará esto automáticamente y puedes omitir esto.
transaction = sentry_sdk.continue_trace(
    message["headers"],
    op="function",
    name="queue_consumer_transaction",
)
with sentry_sdk.start_transaction(transaction):
    # Crear el span
    with sentry_sdk.start_span(
        op="queue.process",
        name="queue_consumer",
    ) as span:
        # Establecer datos del span
        span.set_data("messaging.message.id", message["message_id"])
        span.set_data("messaging.destination.name", queue)
        span.set_data("messaging.message.body.size", message["body"])
        span.set_data("messaging.message.receive.latency", latency)
        span.set_data("messaging.message.retry.count", 0)

        try:
            # Procesar el mensaje
            process_message(message)
        except Exception:
            # En caso de error, establecer el estado como "internal_error"
            transaction.set_status("internal_error")
```

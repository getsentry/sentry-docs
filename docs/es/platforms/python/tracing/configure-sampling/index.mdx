---
title: Configurar el muestreo
description: "Aprende a configurar el muestreo en tu aplicación."
sidebar_order: 40
---

Si notas que la funcionalidad de tracing de Sentry está generando demasiados datos —por ejemplo, si ves que tu cuota de spans se agota rápidamente— puedes optar por muestrear tus trazas.

Un muestreo eficaz es clave para obtener el máximo valor del monitoreo de rendimiento de Sentry mientras minimizas la sobrecarga. El SDK de Python ofrece dos formas de controlar la tasa de muestreo. Puedes revisar las opciones y los [ejemplos](#traces-sampler-examples) a continuación.

<div id="sampling-configuration-options">
  ## Opciones de configuración del muestreo
</div>

<div id="1-uniform-sample-rate-traces_sample_rate">
  ### 1. Tasa de muestreo uniforme (`traces_sample_rate`)
</div>

`traces_sample_rate` es un valor de coma flotante entre `0.0` y `1.0` (incluidos) que controla la probabilidad con la que se muestrea cada transacción:

<PlatformContent includePath="/performance/traces-sample-rate" />

Con `traces_sample_rate` establecido en `0.25`, cada transacción de tu aplicación se muestrea aleatoriamente con una probabilidad de `0.25`, por lo que puedes esperar que una de cada cuatro transacciones se envíe a Sentry.

<div id="2-sampling-function-traces_sampler">
  ### 2. Función de muestreo (`traces_sampler`)
</div>

Para un control más granular, puedes proporcionar una función `traces_sampler`. Este enfoque te permite:

* Aplicar distintas tasas de muestreo a diferentes tipos de transacciones
* Excluir por completo transacciones específicas
* Tomar decisiones de muestreo basadas en los datos de la transacción
* Controlar la herencia de decisiones de muestreo en trazas distribuidas
* Usar atributos personalizados para modificar el muestreo

<Alert>
  Se recomienda encarecidamente que, al usar un `traces_sampler` personalizado, respetes la decisión de muestreo del elemento padre. Esto garantiza que tus trazas estén completas.
</Alert>

En sistemas distribuidos, implementar lógica de herencia cuando la información de la traza se propaga entre servicios garantizará decisiones de muestreo coherentes en toda tu traza distribuida.

<PlatformContent includePath="/performance/traces-sampler-as-sampler" />

<details>
  <summary className="text-xl font-semibold">Ejemplos de Muestreo de Trazas</summary>

  #### Ejemplos de Muestreador de Trazas

  1. Priorización de flujos críticos de usuario

  ```python
  import sentry_sdk
  from sentry_sdk.types import SamplingContext

  def traces_sampler(sampling_context: SamplingContext) -> float:
      # Usa la decisión de muestreo del padre si tenemos un trace entrante.
      # Nota: recomendamos encarecidamente respetar la decisión de muestreo del padre,
      # ¡ya que esto asegura que tus traces estarán completos!
      parent_sampling_decision = sampling_context["parent_sampled"]
      if parent_sampling_decision is not None:
          return float(parent_sampling_decision)

      transaction_ctx = sampling_context["transaction_context"]
      name = transaction_ctx["name"]
      op = transaction_ctx["op"]

      # Muestrea todas las transacciones de checkout
      if name and ('/checkout' in name or op == 'checkout'):
          return 1.0

      # Muestrea el 50% de las transacciones de login
      if name and ('/login' in name or op == 'login'):
          return 0.5

      # Muestrea el 10% de todo lo demás
      return 0.1

  sentry_sdk.init(
      dsn="your-dsn",
      traces_sampler=traces_sampler,
  )
  ```

  2. Gestión de distintos entornos y tasas de error

  ```python
  import sentry_sdk
  from sentry_sdk.types import SamplingContext

  def traces_sampler(sampling_context: SamplingContext) -> float:
      # Usa la decisión de muestreo principal si tenemos un trace entrante.
      # Nota: recomendamos encarecidamente respetar la decisión de muestreo principal,
      # ¡ya que esto asegura que tus traces estarán completos!
      parent_sampling_decision = sampling_context["parent_sampled"]
      if parent_sampling_decision is not None:
          return float(parent_sampling_decision)

      custom_sampling_ctx = sampling_context["custom_sampling_context"]
      environment = os.environ.get("ENVIRONMENT", "development")

      # Muestrea todas las transacciones en desarrollo
      if environment == "development":
          return 1.0

      # Muestrea más transacciones si hay errores recientes
      # Nota: hasRecentErrors es un atributo personalizado que debe configurarse
      if custom_sampling_ctx.get("hasRecentErrors") is True:
          return 0.8

      # Muestrea según el entorno
      if environment == "production":
          return 0.05  # 5% en producción
      elif environment == "staging":
          return 0.2   # 20% en staging

      # Tasa de muestreo predeterminada
      return 0.1

  # Inicializa el SDK con la función de muestreo
  sentry_sdk.init(
      dsn="your-dsn",
      traces_sampler=traces_sampler,
  )

  # Los atributos personalizados deben configurarse al iniciar la transacción mediante
  # el argumento `custom_sampling_context` para que estén disponibles
  # en el traces_sampler
  with sentry_sdk.start_transaction(
      name="GET /api/users",
      op="http.request",
      custom_sampling_context={"hasRecentErrors": True},
  ) as transaction:
      # tu código aquí
  ```

  3. Control del muestreo según las propiedades del usuario y de la transacción

  ```python
  import sentry_sdk
  from sentry_sdk.types import SamplingContext

  def traces_sampler(sampling_context: SamplingContext) -> float:
      # Usa la decisión de muestreo del padre si tenemos un trace entrante.
      # Nota: recomendamos encarecidamente respetar la decisión de muestreo del padre,
      # ¡ya que esto asegura que tus traces estarán completos!
      parent_sampling_decision = sampling_context["parent_sampled"]
      if parent_sampling_decision is not None:
          return float(parent_sampling_decision)

      custom_sampling_ctx = sampling_context["custom_sampling_context"]

      # Siempre muestrea para usuarios premium
      # Nota: user.tier es un atributo personalizado que necesita ser configurado
      if custom_sampling_ctx.get("user", {}).get("tier") == "premium":
          return 1.0

      # Muestrea más transacciones para usuarios que experimentan errores
      # Nota: hasRecentErrors es un atributo personalizado
      if custom_sampling_ctx.get("hasRecentErrors") is True:
          return 0.8

      # Muestrea menos para rutas de alto volumen y bajo valor
      name = sampling_context["transaction_context"]["name"]
      if name and name.startswith("/api/metrics"):
          return 0.01

      # Tasa de muestreo por defecto
      return 0.2

  # Inicializa el SDK con la función de muestreo
  sentry_sdk.init(
      dsn="your-dsn",
      traces_sampler=traces_sampler,
  )

  # Para configurar atributos personalizados para este ejemplo:
  with sentry_sdk.start_transaction(
      name="GET /api/users",
      op="http.request",
      custom_sampling_context={"user": {"tier": "premium"}, "hasRecentErrors": True},
  ) as transaction:
      # Tu código aquí
  ```

  4. Muestreo de lógica empresarial compleja

  ```python
  import sentry_sdk
  from sentry_sdk.types import SamplingContext

  def traces_sampler(sampling_context: SamplingContext) -> float:
      # Usa la decisión de muestreo principal si tenemos un trace entrante.
      # Nota: recomendamos encarecidamente respetar la decisión de muestreo principal,
      # ¡ya que esto asegura que tus traces estarán completos!
      parent_sampling_decision = sampling_context["parent_sampled"]
      if parent_sampling_decision is not None:
          return float(parent_sampling_decision)

      # Siempre muestrea operaciones de negocio críticas
      # Nota: op es un atributo proporcionado por el SDK
      transaction_ctx = sampling_context["transaction_context"]
      if transaction_ctx["op"] in ["payment.process", "order.create", "user.verify"]:
          return 1.0

      custom_sampling_context = sampling_context["custom_sampling_context"]

      # Muestrea según el segmento de usuario
      # Nota: user.segment es un atributo personalizado
      user_segment = custom_sampling_context.get("user", {}).get("segment")
      if user_segment == "enterprise":
          return 0.8
      elif user_segment == "premium":
          return 0.5

      # Muestrea según el valor de la transacción
      # Nota: transaction.value es un atributo personalizado
      transaction_value = custom_sampling_context.get("transaction", {}).get("value")
      if transaction_value is not None and transaction_value > 1000:  # Transacciones de alto valor
          return 0.7

      # Muestrea según la tasa de error del servicio
      # Nota: service.error_rate es un atributo personalizado
      error_rate = custom_sampling_context.get("service", {}).get("error_rate")
      if error_rate is not None and error_rate > 0.05:  # Tasa de error superior al 5%
          return 0.9

      # Tasa de muestreo por defecto
      return 0.1

  # Inicializa el SDK con la función de muestreo
  sentry_sdk.init(
      dsn="your-dsn",
      traces_sampler=traces_sampler,
  )

  # Para establecer atributos personalizados para este ejemplo:
  with sentry_sdk.start_transaction(
      name="Process Payment",
      op="payment.process",
      custom_sampling_context={"user": {"segment": "enterprise"}, "transaction": {"value": 1500}, "service": {"error_rate": 0.03}},
  ) as transaction:
      # Tu código aquí
  ```

  5. Muestreo basado en el rendimiento

  ```python
  import sentry_sdk
  from sentry_sdk.types import SamplingContext

  def traces_sampler(sampling_context: SamplingContext) -> float:
      # Usa la decisión de muestreo del padre si tenemos un trace entrante.
      # Nota: recomendamos encarecidamente respetar la decisión de muestreo del padre,
      # ¡ya que esto asegura que tus traces estarán completos!
      parent_sampling_decision = sampling_context["parent_sampled"]
      if parent_sampling_decision is not None:
          return float(parent_sampling_decision)

      custom_sampling_ctx = sampling_context["custom_sampling_context"]

      # Muestrea más transacciones con alto uso de memoria
      # Nota: memory_usage_mb es un atributo personalizado
      memory_usage = custom_sampling_ctx.get("memory_usage_mb")
      if memory_usage is not None and memory_usage > 500:
          return 0.8

      # Muestrea más transacciones con alto uso de CPU
      # Nota: cpu_percent es un atributo personalizado
      cpu_percent = custom_sampling_ctx.get("cpu_percent")
      if cpu_percent is not None and cpu_percent > 80:
          return 0.8

      # Muestrea más transacciones con alta carga de base de datos
      # Nota: db_connections es un atributo personalizado
      db_connections = custom_sampling_ctx.get("db_connections")
      if db_connections is not None and db_connections > 100:
          return 0.7

      # Tasa de muestreo por defecto
      return 0.1

  # Inicializa el SDK con la función de muestreo
  sentry_sdk.init(
      dsn="your-dsn",
      traces_sampler=traces_sampler,
  )

  # Para establecer atributos personalizados en este ejemplo:
  with sentry_sdk.start_transaction(
      name="Process Data",
      op="data.process",
      custom_sampling_context={"memory_usage_mb": 600, "cpu_percent": 85, "db_connections": 120},
  ) as transaction:
      # Tu código aquí
  ```
</details>

<div id="the-sampling-context-object">
  ## El objeto de contexto de muestreo
</div>

Cuando se invoca la función `traces_sampler`, el SDK de Sentry pasa un objeto `sampling_context` con información del span pertinente para ayudar a tomar decisiones de muestreo:

```python
{
    "transaction_context": {
        "name": str,  # título de la transacción al momento de la creación (proporcionado por el SDK)
        "op": str,  # descripción breve del tipo de transacción (proporcionado por el SDK)
        "data": Optional[dict[str, Any]]
    },
    "parent_sampled": Optional[bool],  # si la transacción padre fue muestreada (proporcionado por el SDK)
    "parent_sample_rate": Optional[float],  # tasa de muestreo utilizada por el padre (proporcionado por el SDK)
    "custom_sampling_context": Optional[dict[str, Any]]  # datos personalizados adicionales para muestreo
}
```

<div id="sdk-provided-vs-custom-attributes">
  ### Atributos del SDK vs. personalizados
</div>

El contexto de muestreo incluye tanto atributos del SDK como atributos personalizados:

**Atributos del SDK:**

* `transaction_context.name`: Nombre de la transacción
* `transaction_context.op`: Tipo de operación
* `parent_sampled`: Si la transacción primaria fue muestreada
* `parent_sample_rate`: La tasa de muestreo utilizada por la transacción primaria

**Atributos personalizados:**

* Cualquier dato que agregues al parámetro `custom_sampling_context` en `start_transaction`. Úsalo para datos que quieras emplear en decisiones de muestreo, pero que no quieras incluir en los datos de la transacción que se envían a Sentry. Lee más sobre el contexto de muestreo [aquí](/es/platforms/python/configuration/sampling/#sampling-context).

<div id="sampling-decision-precedence">
  ## Prioridad de las decisiones de muestreo
</div>

Cuando podrían aplicarse varios mecanismos de muestreo, Sentry sigue este orden de prioridad:

1. Si se pasa una decisión de muestreo a `start_transaction`, se usa esa decisión
2. Si `traces_sampler` está definido, se usa su decisión. Aunque `traces_sampler` puede anular la decisión de muestreo del elemento padre, la mayoría de los usuarios querrán asegurarse de que su `traces_sampler` respete la decisión de muestreo del elemento padre
3. Si no se define `traces_sampler`, pero hay una decisión de muestreo del elemento padre proveniente de un rastro distribuido entrante, usamos la decisión de muestreo del elemento padre
4. Si no se cumple ninguno de los puntos anteriores, se usa `traces_sample_rate`
5. Si ninguno de los puntos anteriores está configurado, no se muestrean transacciones. Esto equivale a configurar `traces_sample_rate=0.0`

<div id="how-sampling-propagates-in-distributed-traces">
  ## Cómo se propaga el muestreo en trazas distribuidas
</div>

Sentry utiliza un enfoque de muestreo &quot;basado en el origen&quot;:

* La decisión de muestreo se toma en el servicio de origen (la &quot;cabeza&quot;)
* Esta decisión se propaga a todos los servicios downstream

Los dos encabezados clave son:

* `sentry-trace`: Contiene el ID de traza, el ID de span y la decisión de muestreo
* `baggage`: Contiene metadatos adicionales de la traza, incluido el ratio de muestreo

El SDK de Sentry para Python adjunta automáticamente estos encabezados a las solicitudes HTTP salientes cuando se utiliza la autoinstrumentación con bibliotecas como `requests`, `urllib3` o `httpx`. Para otros canales de comunicación, puedes propagar manualmente la información de la traza. Obtén más información sobre cómo personalizar el tracing en [propagación de trazas personalizada](/es/platforms/python/tracing/distributed-tracing/custom-trace-propagation/)
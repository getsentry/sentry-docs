---
title: Celery
description: "Descubre cómo usar Sentry con Celery."
---

La integración de Celery añade soporte para el [sistema de colas de tareas Celery](https://docs.celeryq.dev/).

<div id="install">
  ## Instalar
</div>

Instala `sentry-sdk` desde PyPI con el extra `celery`:

```bash {tabTitle:pip}
pip install "sentry-sdk[celery]"
```

```bash {tabTitle:uv}
uv add "sentry-sdk[celery]"
```

<div id="configure">
  ## Configurar
</div>

Si tienes el paquete `celery` en tus dependencias, la integración de Celery se habilitará automáticamente cuando inicialices el SDK de Sentry.

<Alert>
  Asegúrate de que la llamada a `sentry_sdk.init()` se ejecute al iniciar el worker y
  no solo en el módulo donde se definen tus tareas. De lo contrario, la
  inicialización podría ocurrir demasiado tarde y es posible que los eventos no se informen.
</Alert>

<div id="set-up-celery-without-django">
  ### Configurar Celery sin Django
</div>

Cuando uses Celery sin Django, necesitarás inicializar el SDK de Sentry tanto en tu aplicación como en los procesos worker que crea el demonio de Celery.

Además de capturar errores, puedes usar Sentry para [trazabilidad distribuida](/es/concepts/key-terms/tracing/) y [perfilado](/es/product/explore/profiling/). Selecciona qué deseas instalar para obtener a continuación las instrucciones correspondientes de instalación y configuración.

<div id="set-up-sentry-in-celery-daemon-or-worker-processes">
  #### Configura Sentry en procesos daemon o en workers de Celery
</div>

<OnboardingOptionButtons options={["error-monitoring", "performance", "profiling"]} />

```python {filename:tasks.py}
from celery import Celery, signals
import sentry_sdk

# Inicializando Celery
app = Celery("tasks", broker="...")

# Inicializar el SDK de Sentry al iniciar Celery
@signals.celeryd_init.connect
def init_sentry(**_kwargs):
    sentry_sdk.init(
        dsn="___PUBLIC_DSN___",
        # Agregar encabezados de solicitud e IP para usuarios,
        # consulta https://docs.sentry.io/platforms/python/data-management/data-collected/ para más información
        send_default_pii=True,
        # ___PRODUCT_OPTION_START___ performance
        # Establece traces_sample_rate en 1.0 para capturar el 100%
        # de las transacciones para el rastreo.
        traces_sample_rate=1.0,
        # ___PRODUCT_OPTION_END___ performance
        # ___PRODUCT_OPTION_START___ profiling
        # Para recopilar perfiles de todas las sesiones de perfilado,
        # establece `profile_session_sample_rate` en 1.0.
        profile_session_sample_rate=1.0,
        # Los perfiles se recopilarán automáticamente mientras
        # haya un span activo.
        profile_lifecycle="trace",
        # ___PRODUCT_OPTION_END___ profiling
    )

# Las definiciones de tareas van aquí
@app.task
def add(x, y):
    return x + y
```

La señal [`celeryd_init`](https://docs.celeryq.dev/en/stable/userguide/signals.html?#celeryd-init) se activa cuando se inicia el daemon de Celery, antes de que se generen los procesos de worker. Si necesitas inicializar Sentry para cada proceso de worker individual, utiliza la señal [`worker_init`](https://docs.celeryq.dev/en/stable/userguide/signals.html?#worker-init) en su lugar.

<div id="set-up-sentry-in-your-application">
  #### Configura Sentry en tu aplicación
</div>

<OnboardingOptionButtons options={["error-monitoring", "performance", "profiling"]} />

```python {filename:main.py}
from tasks import add
import sentry_sdk

def main():
    # Inicializando el SDK de Sentry en nuestro proceso
    sentry_sdk.init(
        dsn="___PUBLIC_DSN___",
        # Agrega datos como encabezados de la solicitud y la IP de los usuarios, si corresponde;
        # consulta https://docs.sentry.io/platforms/python/data-management/data-collected/ para más información
        send_default_pii=True,
        # ___PRODUCT_OPTION_START___ performance
        # Establece traces_sample_rate en 1.0 para capturar el 100 %
        # de las transacciones para el trazado.
        traces_sample_rate=1.0,
        # ___PRODUCT_OPTION_END___ performance
        # ___PRODUCT_OPTION_START___ profiling
        # Para recopilar perfiles de todas las sesiones de perfil,
        # establece `profile_session_sample_rate` en 1.0.
        profile_session_sample_rate=1.0,
        # Los perfiles se recopilarán automáticamente mientras
        # haya un span activo.
        profile_lifecycle="trace",
        # ___PRODUCT_OPTION_END___ profiling
    )

    # Encolar una tarea para que la procese Celery
    with sentry_sdk.start_transaction(name="calling-a-celery-task"):
        result = add.delay(4, 4)

if __name__ == "__main__":
    main()
```

<div id="set-up-celery-with-django">
  ### Configurar Celery con Django
</div>

Si usas Celery con Django en una configuración típica, has inicializado el SDK en tu archivo `settings.py` (como se describe en la [documentación de la integración de Django](/es/platforms/python/integrations/django/#configure)) y tienes Celery configurado para usar los mismos parámetros que [`config_from_object`](https://docs.celeryq.dev/en/stable/django/first-steps-with-django.html), no es necesario inicializar el SDK de Celery por separado.

<div id="verify">
  ## Verificar
</div>

Para confirmar que tu SDK se inicializa al arrancar el worker, pasa `debug=True` a `sentry_sdk.init()`. Esto añadirá salida adicional a los registros de Celery cuando se inicialice el SDK. Si ves la salida durante el arranque del worker, y no solo después de que una tarea haya comenzado, entonces está funcionando correctamente.

El siguiente fragmento incluye un `ZeroDivisionError` intencional en la tarea de Celery que será capturado por Sentry. Para provocar el error, llama a `debug_sentry.delay()`:

```python {filename:tasks.py}
from celery import Celery, signals
import sentry_sdk

app = Celery("tasks", broker="...")

@signals.celeryd_init.connect
def init_sentry(**_kwargs):
    sentry_sdk.init(...)  # igual que arriba

@app.task
def debug_sentry():
    1/0
```

<Alert title="Nota sobre el tracing distribuido">
  Sentry utiliza encabezados de mensaje personalizados para el tracing distribuido. En las versiones 4.x de Celery, con el [protocolo de mensajes versión 1](https://docs.celeryq.dev/en/stable/internals/protocol.html#version-1), esta funcionalidad no funciona y Celery no logra propagar los encabezados personalizados al worker. La versión 2 del protocolo, predeterminada desde Celery 4.0, no se ve afectada.

  La solución al problema de propagación de encabezados personalizados se incorporó al proyecto Celery ([PR](https://github.com/celery/celery/pull/6374)) a partir de la versión 5.0.1. Sin embargo, no se aplicó retroactivamente a las versiones 4.x.
</Alert>

<div id="options">
  ## Opciones
</div>

Para configurar opciones en `CeleryIntegration` y cambiar su comportamiento, añádela explícitamente en tu `sentry_sdk.init()`:

```python
import sentry_sdk
from sentry_sdk.integrations.celery import CeleryIntegration

sentry_sdk.init(
    # igual que antes
    integrations=[
        CeleryIntegration(
            monitor_beat_tasks=True,
            exclude_beat_tasks=[
                "unimportant-task",
                "payment-check-.*"
            ],
        ),
    ],
)
```

Puedes pasar los siguientes argumentos con nombre a `CeleryIntegration()`:

* `propagate_traces`

  Propaga la información de trazado de Sentry a la tarea de Celery. Esto permite vincular los errores de las tareas de Celery con la función que desencadenó la tarea.

  Si se establece en `False`:

  * los errores en las tareas de Celery no se asociarán con la función que las desencadenó.
  * tus tareas de Celery iniciarán una nueva traza y no estarán conectadas a la traza de la función que las invoca.

  El valor predeterminado es `True`.

  Consulta [Trazas distribuidas](#distributed-traces) a continuación para saber cómo obtener un control más granular del trazado distribuido en tareas de Celery.

* `monitor_beat_tasks`:

  Activa o desactiva la autoinstrumentación de tareas de Celery Beat usando Sentry Crons.

  Consulta <PlatformLink to="/crons/#celery-beat-auto-discovery">Detección automática de Celery Beat</PlatformLink> para obtener más información.

  El valor predeterminado es `False`.

* `exclude_beat_tasks`:

  Lista de tareas de Celery Beat que deben excluirse de la autoinstrumentación con Sentry Crons. Solo se aplica si `monitor_beat_tasks` está configurado en `True`.

  La lista puede contener cadenas con los nombres de las tareas en la programación de Celery Beat que se deben excluir. También puede incluir expresiones regulares para hacer coincidir varias tareas. Por ejemplo, si incluyes `"payment-check-.*"`, se excluirá de la autoinstrumentación toda tarea que comience con `payment-check-`.

  Consulta <PlatformLink to="/crons/#celery-beat-auto-discovery">Detección automática de Celery Beat</PlatformLink> para obtener más información.

  El valor predeterminado es `None`.

<div id="distributed-traces">
  ## Trazas distribuidas
</div>

El rastreo distribuido extiende la traza desde el código que ejecuta tu tarea de Celery para incluir también el código que inició la tarea.

Puedes desactivarlo de forma global con el parámetro `propagate_traces`, documentado arriba. Si estableces `propagate_traces` en `False`, todas las tareas de Celery iniciarán su propia traza.

Si quieres un control más detallado sobre la propagación de trazas, puedes sobrescribir la opción `propagate_traces` pasando el encabezado `sentry-propagate-traces` al iniciar la tarea de Celery:

**Nota:** `CeleryIntegration` no utiliza la opción de configuración `traces_sample_rate` para decidir si una traza debe propagarse a una tarea de Celery.

```python
import sentry_sdk

# Habilitar trazas distribuidas globales (este es el valor predeterminado, solo para ser explícitos)
sentry_sdk.init(
    # igual que arriba
    integrations=[
        CeleryIntegration(
            propagate_traces=True
        ),
    ],
)

# Esto propagará la traza:
my_task_a.delay("some parameter")

# Esto propagará la traza:
my_task_b.apply_async(
    args=("some_parameter", )
)

# Esto NO propagará la traza. La tarea iniciará su propia traza:
my_task_b.apply_async(
    args=("some_parameter", ),
    headers={"sentry-propagate-traces": False},
)

# Nota: no es posible sobrescribir el comportamiento de rastreo usando `task_x.delay()`.
```

<div id="supported-versions">
  ## Versiones compatibles
</div>

* Celery: 4.0+
* Python: 3.6+

<Include name="python-use-older-sdk-for-legacy-support.mdx" />
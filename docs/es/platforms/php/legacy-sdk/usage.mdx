---
draft: true
categories: []
toc: true
title: Uso
sidebar_order: 1
noindex: true
tags: []
---

<Alert level="warning" title="Aviso de obsolescencia">
  Un nuevo SDK de PHP ha sustituido esta versión obsoleta. Sentry conserva esta documentación para quienes siguen usando el cliente anterior. Si utilizas PHP 7.1 o posterior, te recomendamos usar el [SDK de PHP actualizado](/es/platforms/php/) en tus proyectos.
</Alert>

Usar Sentry con PHP es sencillo. Tras instalar la biblioteca, puedes interactuar directamente con el cliente y empezar a enviar datos.

<div id="basics">
  ## Conceptos básicos
</div>

Lo más importante es crear el cliente de Raven. Créalo una vez y haz referencia a él desde cualquier lugar donde quieras interactuar con Sentry:

```php
$sentryClient = new Raven_Client('___PUBLIC_DSN___');
```

<div id="capturing-errors">
  ## Captura de errores
</div>

Sentry incluye funciones básicas para informar de cualquier excepción no controlada o error de PHP. Esto se hace mediante el controlador de errores y los hooks adecuados para cada uno de los mecanismos de reporte integrados de PHP:

```php
$error_handler = new Raven_ErrorHandler($sentryClient);
$error_handler->registerExceptionHandler();
$error_handler->registerErrorHandler();
$error_handler->registerShutdownFunction();
```

<Alert title="Nota">
  Al llamar a `install()` en una instancia de Raven&#95;Client, estos controladores se registran automáticamente.
</Alert>

<div id="reporting-exceptions">
  ## Informar excepciones
</div>

Si quieres reportar excepciones manualmente, puedes usar la función *captureException*.

```php
// Reporte Básico
$sentryClient->captureException($ex);

// Proporcionar datos adicionales con una excepción
$sentryClient->captureException($ex, array(
    'extra' => array(
        'php_version' => phpversion()
    ),
));
```

<div id="reporting-other-errors">
  ## Informar otros errores
</div>

A veces no tienes un objeto de excepción como tal, pero algo salió mal y quieres reportarlo de todos modos. Aquí es donde entra *captureMessage*. Recibe un mensaje y lo envía a Sentry.

```php
// Capturar un mensaje
$sentryClient->captureMessage('mi mensaje de registro');
```

Nota: `captureMessage` tiene una API ligeramente distinta a `captureException` para admitir el formateo parametrizado:

```php
$sentryClient->captureMessage('mi mensaje %s', array('log'), array(
    'extra' => array(
        'foo' => 'bar',
    ),
));
```

<div id="optional-attributes">
  ## Atributos opcionales
</div>

Con las llamadas a `captureException` o `captureMessage`, se pueden proporcionar datos adicionales:

```php
$sentryClient->captureException($ex, array(
    'attr' => 'valor',
));
```

`extra`

Contexto adicional para este evento. Debe ser un mapa. Los elementos hijos pueden ser de cualquier tipo nativo de JSON.

```php
array(
    'extra' => array('key' => 'value')
)
```

`fingerprint`

La firma (fingerprint) para agrupar este evento.

```php
array(
    'fingerprint' => ['{{ default }}', 'otro valor']
)
```

`level`

El nivel del evento. De forma predeterminada, es `error`.

```php
array(
    'level' => 'warning'
)
```

Sentry reconoce los siguientes niveles:

* debug (el menos grave)
* info
* warning
* error
* fatal (el más grave)

`logger`

El nombre del registrador para el evento.

```php
array(
    'logger' => 'default'
)
```

`tags`

Etiquetas para indexar este evento. Debe ser un mapa de cadenas.

```php
array(
    'tags' => array('key' => 'value')
)
```

`user`

El usuario que realiza la acción.

```php
array(
    'user' => array(
        'id' => 42,
        'email' => 'clever-girl'
    )
)
```

<div id="getting-back-an-event-id">
  ## Obtener un ID de evento
</div>

Un ID de evento es un identificador único global del evento que se acaba de enviar. Este ID de evento se puede usar para encontrar el evento exacto dentro de Sentry.

A menudo se utiliza para mostrárselo al usuario y para informar un error al servicio de atención al cliente.

```php
$sentryClient->getLastEventID();
```

<div id="user-feedback">
  ## Comentarios de los usuarios
</div>

Para habilitar los comentarios de los usuarios en los informes de fallos, tendrás que crear un manejador de errores que conozca el último ID de evento.

```php
<?php

$sentry = new \Raven_Client(___PUBLIC_DSN___);

public class App {
    function error500($exc) {
        $event_id = $sentry->captureException($exc);

        return $this->render('500.html', array(
            'sentry_event_id' => $event_id,
        ), 500);
    }
}
```

Luego, en tu plantilla puedes cargar el widget de feedback:

```html
<!-- Se requiere Sentry JS SDK 2.1.+ -->
<script src="https://cdn.ravenjs.com/2.3.0/raven.min.js"></script>

{% if sentry_event_id %}
<script>
  Raven.showReportDialog({
    eventId: "{{ sentry_event_id }}",

    // usa el DSN público (¡no incluyas tu clave secreta!)
    dsn: "___PUBLIC_DSN___",
  });
</script>
{% endif %}
```

¡Listo!

Para obtener más información sobre esta función, consulta la [*guía de comentarios de usuarios*](/es/platforms/php/user-feedback/).

<div id="handling-failures">
  ## Manejo de errores
</div>

El SDK intenta minimizar los errores y, cuando ocurren, procurará no propagarlos a tu aplicación. Si quieres saber cuándo un evento no se pudo registrar, puedes usar el asistente `getLastError`:

```php
if ($sentryClient->getLastError() !== null) {
    echo "Algo salió muy, muy mal";
    // $sentryClient->getLastError() contiene el error que ocurrió
} else {
    // Proporciona retroalimentación al usuario
    echo "Lo sentimos, ¡hubo un error!";
    echo "Tu ID de referencia es " . $event_id;
}
```

<div id="breadcrumbs">
  ## Breadcrumbs
</div>

Sentry admite la captura de breadcrumbs, es decir, eventos que ocurrieron antes de un incidente.

```php
$sentryClient->breadcrumbs->record(array(
    'message' => 'Autenticando usuario como ' . $username,
    'category' => 'auth',
    'level' => 'info',
));
```

<div id="filtering-out-errors">
  ## Filtrado de errores
</div>

Es común querer evitar la captura automática de ciertas áreas. Idealmente, simplemente no llamarías a Sentry en ese caso, pero eso suele ser más fácil decirlo que hacerlo. En su lugar, puedes proporcionar una función que el SDK llamará antes de enviar cualquier dato, lo que te permite tanto modificar esos datos como evitar que se envíen al servidor.

```php
$sentryClient->setSendCallback(function($data) {
    $ignore_types = array('Symfony\Component\HttpKernel\Exception\NotFoundHttpException');

    if (isset($data['exception']) && in_array($data['exception']['values'][0]['type'], $ignore_types))
    {
        return false;
    }
});
```

<div id="error-control-operators">
  ## Operadores de control de errores
</div>

En PHP es bastante común usar el [operador de supresión](https://php.net/manual/en/language.operators.errorcontrol.php) para evitar que los errores gestionados se propaguen:

```php
$my_file = @file('non_existent_file');
```

En estas situaciones, Sentry no capturará el error. Si quieres capturarlo en esa fase, tendrás que invocar manualmente al cliente de PHP:

```php
$my_file = @file('non_existent_file');
if (!$my_file) {
    // ...
    $sentryClient->captureLastError();
}
```

<div id="testing-your-connection">
  ## Prueba de tu conexión
</div>

El cliente de PHP incluye un script auxiliar sencillo para comprobar tu conexión y credenciales con el servidor principal de Sentry:

```bash
bin/sentry test ___PUBLIC_DSN___
Configuración del cliente:
-> servidor: [___API_URL___]
-> proyecto: ___PROJECT_ID___
-> clave pública: ___PUBLIC_KEY___

Enviando un evento de prueba:
-> ID del evento: f1765c9aed4f4ceebe5a93df9eb2d34f

¡Listo!
```

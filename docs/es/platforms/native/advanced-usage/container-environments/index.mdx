---
title: Entornos de contenedores
description: "Cómo usar el SDK Sentry Native en entornos de contenedores."
sidebar_order: 2000
---

<div id="database-path-on-a-mounted-volume">
  ## Ruta de la base de datos en un volumen montado
</div>

El SDK de Sentry Native utiliza una [ruta de base de datos](/es/platforms/native/configuration/options/#database-path) para almacenar eventos e informes de fallos. Si usas un entorno con contenedores, quizá quieras montar un volumen para conservar la base de datos entre reinicios del contenedor y evitar perder estos datos.

<div id="waiting-for-crashpad-to-finish">
  ## Esperar a que `Crashpad` termine
</div>

A partir de la versión del SDK [0.8.3](https://github.com/getsentry/sentry-native/releases/tag/0.8.3) para Linux y [0.9.0](https://github.com/getsentry/sentry-native/releases/tag/0.9.0) para Windows, la [opción `crashpad_wait_for_upload`](/es/platforms/native/configuration/options/#crashpad-wait-for-upload) permite que la aplicación espere a que el `crashpad_handler` finalice antes de apagarse tras un fallo.

En las versiones del SDK anteriores a `0.8.3`/`0.9.0`, podías usar un script similar al ejemplo siguiente para vincular el apagado del contenedor al proceso `crashpad_handler`:

```bash
#!/bin/bash

# ./execute-main-app

crashpad_timeout_s=10
crashpad_process_name=crashpad_handler
crashpad_pid=$(pgrep -n -f $crashpad_process_name)
if [ -n "$crashpad_pid" ]; then
    echo "Esperando a que crashpad finalice..."
    timeout $crashpad_timeout_s tail --pid=$crashpad_pid -f /dev/null
    if [ $? -eq 124 ]; then
        echo "El proceso crashpad no finalizó en $crashpad_timeout_s segundos"
    else
        echo "El proceso crashpad finalizó correctamente"
    fi
fi
```

en Linux o en Windows PowerShell

```powershell
# Start-Process -FilePath ".\main-app.exe" -Wait

$crashpadTimeoutSec = 10
$crashpadProcessName = "crashpad_handler"
$crashpadProcess = Get-Process -Name $crashpadProcessName -ErrorAction SilentlyContinue | Sort-Object StartTime -Descending | Select-Object -First 1
if ($null -ne $crashpadProcess) {
    Write-Output "Esperando a que crashpad finalice..."
    $finished = $crashpadProcess.WaitForExit($crashpadTimeoutSec * 1000)
    if (-not $finished) {
        Write-Output "El proceso crashpad no finalizó en $crashpadTimeoutSec segundos"
    } else {
        Write-Output "El proceso crashpad finalizó correctamente"
    }
}
```

---
title: Manejo de desbordamientos de pila
description: "Aprende las diferencias al informar fallos por desbordamientos de pila entre plataformas y cómo Sentry puede ayudar."
sidebar_order: 1100
---

Los bloqueos de la aplicación por desbordamiento de pila difieren de otros bloqueos desde la perspectiva del manejador porque este
depende del recurso que se agotó: el espacio de pila. Dado que el manejador normalmente se ejecuta en el hilo cuya pila se desbordó,
ya no puede usar variables de pila ni llamar a funciones. Esto da como resultado una aplicación bloqueada sin enviar un informe de que
ocurrió.

Cómo abordar este problema varía según la plataforma, pero las opciones se reducen a:

* asignar una pila que solo el manejador de fallos pueda usar (Linux/POSIX y Windows)
* ejecutar el manejador en un hilo (o proceso) independiente, que recibirá un mensaje del fallo de forma asíncrona (macOS)

Independientemente de si una aplicación se bloqueó por un desbordamiento de pila o no, los manejadores deberían hacer un uso mínimo de la
pila porque, incluso si no hubo desbordamiento de pila, la cantidad de pila disponible para el manejador podría ser limitada. Esto es
especialmente cierto para quienes usan los hooks `on_crash` o `before_send`, sobre los cuales Sentry no tiene control.

En Linux (y otros sistemas `POSIX`), se debe preasignar todo antes de que se ejecuten los hooks y solo mover datos al
almacenamiento preasignado, porque las asignaciones en el heap también pueden fallar dentro del manejador de señales (construir `sentry_value_t` está
bien porque usamos un asignador seguro dentro del manejador de señales). Consulta también:
[Qué considerar al escribir hooks on&#95;crash](/es/platforms/native/advanced-usage/signal-handling/#what-to-consider-when-writing-on_crash-hooks).

<div id="how-do-oses-differ-and-how-can-sentry-help">
  ## ¿En qué se diferencian los sistemas operativos y cómo puede ayudar Sentry?
</div>

<div id="windows">
  ### Windows
</div>

La API de Windows proporciona una [interfaz de garantía de pila de hilo](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadstackguarantee)
donde los usuarios pueden indicar un tamaño en bytes reservado para que el manejador se ejecute en caso de fallo. Sin embargo, este tamaño se resta
de la reserva de pila del hilo, ya que es una continuación directa dentro de la pila del hilo, no una asignación ni una
región de memoria separada.

El desarrollador debe sopesar la reserva de pila del hilo frente a la garantía del manejador durante el funcionamiento normal.
De lo contrario, la garantía usada para el manejador podría consumir suficiente espacio de pila como para provocar un desbordamiento.

Esto no debería ser un problema para la mayoría de los hilos en Windows, que tienen una reserva de pila predeterminada de 1MiB (mientras que la
garantía requerida para el manejador será de solo decenas de KiB). Sin embargo, algunos hilos creados por runtimes específicos o por el kernel
(para controladores) podrían tener reservas de pila mucho más pequeñas, donde una garantía de 32KiB ya podría representar la mitad o toda
la pila disponible para el hilo.

En resumen, aunque Windows proporciona una interfaz de muy alto nivel para solicitarla (&quot;garantízame x bytes para mi manejador&quot;), no es
flexible con respecto a la ubicación de la pila garantizada del manejador. Por lo tanto, debes considerar el tamaño de la garantía en
el contexto de la reserva de pila y el uso real de la pila en un hilo en particular. Esto último es difícil de hacer para hilos
que no controlas.

Además, tendrás que solicitar la garantía de pila desde dentro del hilo que quieras configurar. No puedes establecer una
garantía desde fuera, lo que normalmente te limita a los hilos que posees.

En Windows, el SDK nativo establece automáticamente una garantía de pila de 64KiB para todos los hilos que comiencen después de cargarlo como
biblioteca compartida. Para compilaciones de biblioteca estática, solo establecemos automáticamente la garantía de pila para el hilo que llama a
`sentry_init()`.

Si necesitas establecer garantías de pila manualmente, puedes usar directamente la API de Win32. Una garantía establecida una vez no puede
disminuirse a través de la API de Win32; solo puede aumentarse. También proporcionamos `sentry_set_thread_stack_guarantee()` sobre la función de Win32, que incluye registros útiles y evita sobrescribir una garantía de pila previamente establecida.

La auto-inicialización también es preventiva al consultar la reserva de pila para cada hilo en el que se ejecuta, y solo intenta
establecer una garantía si la reserva es al menos, de forma predeterminada, 10 veces mayor que la garantía predeterminada solicitada.

Puedes parametrizar este comportamiento para adaptarlo a tu caso de uso:

* cambiar la pila predeterminada del manejador usando el parámetro en tiempo de compilación `SENTRY_HANDLER_STACK_SIZE`
* deshabilitar por completo la auto-inicialización usando la opción en tiempo de compilación `SENTRY_THREAD_STACK_GUARANTEE_AUTO_INIT`
* ajustar la relación entre la reserva de pila y la garantía del manejador usando el parámetro en tiempo de compilación `SENTRY_THREAD_STACK_GUARANTEE_FACTOR`
* habilitar registros más detallados durante el ajuste de parámetros con `SENTRY_THREAD_STACK_GUARANTEE_VERBOSE_LOG`

Estos parámetros se documentan con más detalle en la sección sobre opciones en tiempo de compilación del
[README del SDK nativo](https://github.com/getsentry/sentry-native?tab=readme-ov-file#compile-time-options).

<div id="linux-or-oses-that-primarily-use-posix-signal-handlers">
  ### Linux o sistemas operativos que usan principalmente manejadores de señales POSIX
</div>

Cuando usas manejadores de señales POSIX, puedes especificar un `sigaltstack`. Esta pila de señales alternativa permite que el kernel
continúe la pila del manejador incluso si la pila del hilo que se bloqueó y fue interrumpido se queda sin espacio.

Esta interfaz relativamente de bajo nivel permite especificar un rango de memoria arbitrario (en el heap, la pila o cualquier mapeo de
memoria accesible para el usuario). La ventaja de permitir que el usuario determine el tamaño *y* la ubicación ofrece flexibilidad
en comparación con el enfoque de Windows, porque es independiente del uso y el tamaño de la pila del hilo que se bloqueó y te permite
agregar límites adicionales, como regiones protegidas alrededor de la pila del manejador.

Sin embargo, también añade complejidad al entorno, porque una región de memoria mal ubicada o configurada incorrectamente podría provocar
errores difíciles de identificar (piensa en una pila del manejador dentro del heap, donde un desbordamiento del manejador causado por una implementación
de `on_crash` muy demandante de pila podría causar corrupción arbitraria del heap).

Al igual que en Windows, solo puedes asignar un `sigaltstack` desde dentro del hilo, lo que significa que solo puedes configurar la región del manejador
para los hilos que controlas.

En Linux, `crashpad` y `breakpad` proporcionan su propia inicialización de `sigaltstack`, actualmente no influida por Sentry:

* `breakpad` normalmente asigna 16 KiB o `SIGSTKSZ` si es mayor.
* `crashpad` asigna `SIGSTKSZ` + el tamaño de página de tu sistema y lo alinea al tamaño de página (lo que dará como resultado 16 KiB o
  32 KiB en la mayoría de los sistemas)

Tanto `breakpad` como `crashpad` solo especificarán un `sigaltstack` si no existe ninguno o si el definido es más pequeño que
el tamaño objetivo. `breakpad` asigna la pila alternativa en el heap. `crashpad` crea un mapeo de memoria independiente que
incluye una página de protección.

El backend `inproc` usa el tamaño de la pila del manejador especificado en [`SENTRY_HANDLER_STACK_SIZE`](https://github.com/getsentry/sentry-native?tab=readme-ov-file#compile-time-options)
y solo configura un `sigaltstack` si no se ha definido ninguno. Al igual que `breakpad`, asigna la pila del manejador en el heap.

<Alert>
  Actualmente, todos los backends solo configuran el `sigaltstack` para el hilo que inicializa el SDK nativo. Todos los demás hilos
  deben configurar su propio `sigaltstack`, ya que en Linux no existe una auto-inicialización como en Windows.
</Alert>

<div id="android">
  ### Android
</div>

Android configura automáticamente cada hilo para usar un tamaño de `sigaltstack` de 16 KiB (en sistemas de 32 bits) y 32 KiB (en sistemas de 64 bits). El equipo de Android recomienda no modificar estos valores porque las inconsistencias de configuración con las pilas de señales proporcionadas por Android pueden provocar fallos durante la ejecución normal. El backend `inproc` del SDK nativo utilizado en la integración de Android no definirá un `sigaltstack` en Linux/Android si ya existe uno. Por lo tanto, en Android solo se usará el `sigaltstack` predeterminado, y puedes estar seguro de que cada hilo tendrá uno.

<div id="macos-when-using-mach-exception-port-listeners">
  ### macOS, al usar receptores de puertos de excepciones Mach
</div>

El receptor de puertos de excepciones Mach suele quedarse bloqueado en un hilo independiente hasta que el kernel entrega una excepción Mach. Dado que
el hilo del receptor es completamente independiente del hilo que se estrelló, una excepción causada por un desbordamiento de pila nunca
afectará a la pila disponible para el controlador. Esto es aún más cierto en `crashpad` en macOS, donde el controlador
no solo se ejecuta en un hilo independiente, sino en un proceso aparte.

<Alert>
  Esto significa que, al usar `breakpad` o `crashpad` en macOS, manejar un desbordamiento de pila no requiere una configuración
  ni cuidados diferentes a los de otros fallos.
</Alert>

<Alert>
  Ten en cuenta que, a diferencia del uso de puertos de excepciones Mach, los manejadores de señales en macOS se ejecutan en el mismo hilo que causó la
  señal y, por lo tanto, también necesitan un `sigaltstack` para manejar cualquier fallo por desbordamiento de pila. Solo el backend `inproc` en macOS
  actualmente depende por completo de manejadores de señales, y su pila de señales se configura de forma equivalente a la de Linux u otras plataformas POSIX.
</Alert>
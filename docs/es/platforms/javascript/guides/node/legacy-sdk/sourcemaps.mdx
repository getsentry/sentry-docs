---
draft: true
categories: []
toc: true
title: Mapas de código fuente
sidebar_order: 2
noindex: true
tags: []
---

<Alert level="warning" title="Aviso de desaprobación">
  Un nuevo SDK de Node ha sustituido esta versión obsoleta. Sentry conserva esta documentación para clientes que usan el cliente antiguo. Recomendamos usar el [SDK de Node actualizado](/es/platforms/javascript/guides/node/) en tus proyectos.
</Alert>

Sentry admite desofuscar JavaScript mediante [mapas de código fuente](https://blog.sentry.io/2015/10/29/debuggable-javascript-with-source-maps/). Esto te permite ver el contexto del código fuente obtenido de los rastreos de pila en su forma original sin transformar, lo cual es especialmente útil para depurar código minificado (por ejemplo, UglifyJS) o código transpilado desde un lenguaje de más alto nivel (por ejemplo, TypeScript, ES6).

<div id="generating-a-source-map">
  ## Generación de un mapa de origen
</div>

La mayoría de los transpiladores modernos de JavaScript admiten mapas de origen. A continuación encontrarás instrucciones para algunas herramientas comunes.

<div id="webpack">
  ### Webpack
</div>

Webpack es una potente herramienta de compilación que resuelve y agrupa tus módulos de JavaScript en archivos listos para ejecutarse en el navegador. También admite muchos “loaders” que pueden convertir lenguajes de nivel superior como TypeScript y ES6/ES2015 en JavaScript compatible con los navegadores.

Se puede configurar Webpack para generar mapas de código fuente editando `webpack.config.js`.

```javascript
const path = require("path");

module.exports = {
  // ... otras configuraciones arriba ...
  target: "node",
  devtool: "source-map",
  entry: {
    app: "./src/app.js",
  },
  output: {
    path: path.join(__dirname, "dist"),
    filename: "[name].js",
  },
};
```

<div id="making-source-maps-available-to-sentry">
  ## Poner los mapas de origen a disposición de Sentry
</div>

Los mapas de origen de proyectos Node.js deben cargarse directamente en Sentry.

<div id="uploading-source-maps-to-sentry">
  ### Carga de source maps en Sentry
</div>

Sentry ofrece una abstracción llamada **Releases** a la que puedes adjuntar artefactos de código fuente. La API de releases está pensada para permitirte almacenar archivos fuente (y source maps) en Sentry.

Puede hacerse fácilmente con la ayuda de `sentry-webpack-plugin`, que internamente usa nuestro Sentry CLI.

* Empieza creando un nuevo token de autenticación en **[Account] &gt; API**.
* Asegúrate de tener `project:write` seleccionado en los scopes.
* Instala `@sentry/webpack-plugin` usando `npm`.
* Crea el archivo `.sentryclirc` con la configuración necesaria (consulta la documentación del plugin de Sentry para webpack más abajo).
* Actualiza tu `webpack.config.js`.

```javascript
const SentryPlugin = require("@sentry/webpack-plugin");

module.exports = {
  // ... otras configuraciones arriba ...
  plugins: [
    new SentryPlugin({
      release: process.env.RELEASE,
      include: "./dist",
    }),
  ],
};
```

Puedes consultar la [documentación del plugin de Sentry para webpack](https://github.com/getsentry/sentry-webpack-plugin) para obtener más información sobre cómo configurar el plugin.

Además, deberás configurar el cliente para enviar el `release`:

```javascript
Raven.config("tu-dsn", {
  release: process.env.RELEASE,
});
```

Nota: No estás obligado a usar variables de entorno *RELEASE*. Puedes proporcionarlas como prefieras.

Encontrarás más información en la [documentación de la API de Releases](/es/api/releases/).

<div id="updating-raven-configuration-to-support-source-maps">
  ## Actualizar la configuración de Raven para admitir Source Maps
</div>

Para que Sentry pueda interpretar el origen de los errores, necesitamos modificar los datos que enviamos. Como el soporte para Source Maps aún está en fase experimental, esta tarea no está integrada en la biblioteca principal. Para lograrlo, podemos normalizar todas las URL con el método `dataCallback`:

```javascript
var path = require('path');

Raven.config('your-dsn', {
    // el resto de la configuración

  dataCallback: function (data) {
    var stacktrace = data.exception && data.exception[0].stacktrace;

    if (stacktrace && stacktrace.frames) {
      stacktrace.frames.forEach(function(frame) {
        if (frame.filename.startsWith('/')) {
          frame.filename = 'app:///' + path.basename(frame.filename);
        }
      });
    }

    return data;
  }
).install();
```

Hay algo muy importante que señalar aquí. Esta configuración asume que empaquetarás tu aplicación en un solo archivo. Por eso usamos *path.basename* para obtener el nombre del archivo.

Si no haces esto —por ejemplo, si usas TypeScript y subes todos tus archivos compilados por separado al servidor— entonces debemos ser un poco más astutos con este caso. Consulta la [documentación de uso de TypeScript](/es/platforms/javascript/guides/node/legacy-sdk/typescript/) para ver un ejemplo más complejo y detallado.

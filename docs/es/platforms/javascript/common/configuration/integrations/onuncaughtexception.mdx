---
title: OnUncaughtException
description: "Registra controladores para capturar excepciones globales no controladas. (predeterminado)"
supported:
  - javascript.node
  - javascript.aws-lambda
  - javascript.azure-functions
  - javascript.connect
  - javascript.express
  - javascript.fastify
  - javascript.gcp-functions
  - javascript.hapi
  - javascript.hono
  - javascript.koa
  - javascript.nestjs
  - javascript.electron
  - javascript.nextjs
  - javascript.nuxt
  - javascript.solidstart
  - javascript.sveltekit
  - javascript.remix
  - javascript.react-router
  - javascript.astro
  - javascript.bun
  - javascript.deno
  - javascript.cloudflare
  - javascript.tanstackstart-react
---

<Alert>
  Esta integración solo funciona en entornos de servidor (Node.js, Bun, Deno).
</Alert>

*Nombre de importación: `Sentry.onUncaughtExceptionIntegration`*

Esta integración está habilitada de forma predeterminada. Si quieres modificar tus integraciones predeterminadas, lee [esto](./../#modifying-default-integrations).

La `onUncaughtExceptionIntegration` registra controladores para capturar excepciones globales no controladas que harían que el proceso finalice.

¡Esta integración no evita que el proceso finalice! Si quieres evitar que el proceso finalice, debes registrar tu propio controlador de excepciones no controladas y configurar `exitEvenIfOtherHandlersAreRegistered: false` en las opciones de la integración.

```JavaScript
Sentry.init({
  integrations: [Sentry.onUncaughtExceptionIntegration()],
});
```


<div id="options">
  ## Opciones
</div>

<div id="exitevenifotherhandlersareregistered">
  ### `exitEvenIfOtherHandlersAreRegistered`
</div>

_Tipo: `boolean`_

Si se establece en false, el SDK _no_ finalizará si detectamos que hay otro controlador de excepciones no capturadas registrado.

<div id="onfatalerror">
  ### `onFatalError`
</div>

_Tipo: `(firstError: Error, secondError: Error | undefined) => void`_

Este método se invoca cuando un error no capturado provocaría que el proceso finalice. `secondError` se establecerá si el controlador fue invocado varias veces. Esto puede ocurrir porque el propio `onFatalError` lanzó una excepción o porque se produjo un error independiente en otro lugar mientras `onFatalError` se estaba ejecutando.
---
title: Solución de problemas
description: >-
  Si necesitas ayuda para resolver problemas con la integración de tu Sentry JavaScript SDK,
  puedes leer los casos límite documentados a continuación.
keywords:
  - adblocker
  - blocked
  - tunnel
  - non-Error exception
  - '404'
notSupported:
  - javascript.capacitor
sidebar_order: 9000
og_image: /og-images/platforms-javascript-common-troubleshooting.png
---

<Expandable permalink title="El SDK no está enviando datos">
  Si configuraste el Sentry SDK y no está enviando datos a Sentry:

  * Verifica que hayas configurado un DSN y que lo estés pasando a la opción `dsn` en `Sentry.init()`.

    Si estás usando variables de entorno para pasar el DSN, asegúrate de que las variables de entorno estén definidas en todos los entornos relevantes. Además, si usas variables de entorno dentro de un framework, verifica que el framework las incluya en tu bundle. A menudo esto significa que tendrás que anteponer a tus variables de entorno prefijos especiales definidos por tu framework (`NEXT_PUBLIC_` en Next.js, `NUXT_` en Nuxt, `VITE_` para proyectos Vite, `REACT_APP_` para Create React App, ...).

  * Verifica que no tengas bloqueadores de anuncios activados.

  * Establece `debug: true` en las opciones de `Sentry.init()` y observa la salida de la consola al iniciar tu aplicación. El SDK puede indicar por qué no está enviando datos.

  * Revisa las páginas de [Stats](https://sentry.io/orgredirect/organizations/:orgslug/stats/) y [Subscription](https://sentry.io/orgredirect/organizations/:orgslug/settings/billing/overview/) en Sentry. Puede que te hayas quedado sin cuota.

  <PlatformSection supported={["javascript.nextjs"]}>
    - Verifica que no hayas configurado `sideEffects: false` en tu `package.json`.
      Establecer `sideEffects` en false en tu `package.json` hará que Next.js
      haga tree shaking del código del SDK de forma demasiado agresiva, eliminando efectivamente cualquier
      llamada a `Sentry.init()`. Establecer `sideEffects: false` es incorrecto cuando
      usas el Sentry SDK.
  </PlatformSection>
</Expandable>

<Expandable permalink title="Actualizar a una nueva versión del Sentry SDK">
  Si actualizas tu Sentry SDK a una nueva versión principal, podrías encontrarte con cambios incompatibles que requieran cierta adaptación de tu parte.
  Consulta nuestra [guía de migración](https://github.com/getsentry/sentry-javascript/blob/master/MIGRATION.md) para aprender todo lo que necesitas
  saber para volver a ponerte en marcha con las últimas funciones de Sentry.
</Expandable>

<Expandable permalink title="Depurar datos adicionales">
  Puedes ver la carga útil JSON de un evento para comprobar cómo Sentry almacena datos adicionales en el evento. La estructura de los datos puede no coincidir exactamente con la descripción.

  ![Recuadro rojo que muestra dónde encontrar el JSON asociado a un evento](./img/event_JSON.png)

  Para más detalles, consulta la [documentación completa sobre la carga útil de eventos](https://develop.sentry.dev/sdk/data-model/event-payloads/).
</Expandable>

<Expandable permalink title="Tamaño máximo de la carga útil JSON">
  De forma predeterminada, `maxValueLength` es undefined y no se trunca nada, pero puedes cambiar este valor según tus necesidades si tus mensajes son más largos (por ejemplo, a `250`). Ten en cuenta que no todos los valores se ven afectados por esta opción.
</Expandable>

<PlatformCategorySection supported={['browser']}>
  <Expandable permalink title="Atributos y encabezados CORS">
    Para obtener visibilidad de una excepción de JavaScript lanzada desde scripts que se originan en distintos orígenes, haz dos cosas:

    1. Agrega el atributo de script crossorigin=&quot;anonymous&quot;

    ```bash
     <script src="http://another-domain.com/app.js" crossorigin="anonymous"></script>
    ```

    El atributo del script le indica al navegador que obtenga el archivo de destino “de forma anónima”. Información potencialmente identificable del usuario, como cookies o credenciales HTTP, no será transmitida por el navegador al servidor al solicitar este archivo.

    2. Agrega un encabezado HTTP de Cross-Origin

    ```bash
    Access-Control-Allow-Origin: *
    ```

    El uso compartido de recursos entre orígenes (CORS) es un conjunto de APIs (principalmente encabezados HTTP) que dictan cómo se deben descargar y servir archivos entre orígenes.

    Al configurar `Access-Control-Allow-Origin: *`, el servidor indica a los navegadores que cualquier origen puede obtener este archivo. Alternativamente, puedes restringirlo a un origen conocido bajo tu control:

    ```bash
     Access-Control-Allow-Origin: https://www.example.com
    ```

    La mayoría de los CDNs de la comunidad configuran correctamente un encabezado `Access-Control-Allow-Origin`.

    ```bash
     $ curl --head https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.js | \
     grep -i "access-control-allow-origin"

     Access-Control-Allow-Origin: *
    ```
  </Expandable>
</PlatformCategorySection>

<PlatformSection supported={["javascript.sveltekit"]}>
  <Expandable permalink title="Configura la CSP para la instrumentación de `fetch` en el cliente">
    Si estás usando una versión de SvelteKit anterior a `sveltejs/kit@2.16.0`, el SDK de Sentry inyecta una etiqueta `<script>` en línea en la respuesta HTML del servidor.
    Este script actúa como proxy de todas las llamadas `fetch` del lado del cliente para que las llamadas `fetch` dentro de tus funciones `load` sean capturadas por el SDK.
    Sin embargo, si configuraste reglas de CSP para bloquear scripts en línea de forma predeterminada, este script será [bloqueado por el navegador](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src#unsafe_inline_script).

    Tienes varias opciones para resolver este problema de CSP:

    #### Opción 1: Actualiza SvelteKit

    La opción más sencilla es actualizar `@sveltejs/kit` al menos a la versión `2.16.0` (o más reciente). El SDK ya no inyectará el script proxy de fetch porque dejó de ser necesario.

    #### Opción 2: Agrega el hash del script a la política de CSP

    Para habilitar el script, agrega una excepción para el script `sentryHandle` añadiendo el hash del script a tus reglas de origen de scripts de la CSP.

    Si tu CSP está definida en `svelte.config.js`, puedes agregar el hash al arreglo `csp.directives.script-src`:

    ```javascript {filename:svelte.config.js} {5-7}
    const config = {
      kit: {
        csp: {
          directives: {
            "script-src": ["sha256-y2WkUILyE4eycy7x+pC0z99aZjTZlWfVwgUAfNc1sY8="], // + rest of your values
          },
        },
      },
    };
    ```

    Para configuraciones externas de CSP, agrega el siguiente hash a tu directiva `script-src`:

    ```txt
    'sha256-y2WkUILyE4eycy7x+pC0z99aZjTZlWfVwgUAfNc1sY8='
    ```

    <Alert>
      No cambiaremos este script en el corto plazo, por lo que el hash se mantendrá
      constante.
    </Alert>

    #### Opción 3: Desactiva el script proxy de `fetch`

    Si no quieres inyectar el script responsable de instrumentar las llamadas `fetch` del lado del cliente, puedes desactivar la inyección pasando `injectFetchProxyScript: false` a `sentryHandle`:

    ```javascript {filename:hooks.server.(js|ts)}
    export const handle = sentryHandle({ injectFetchProxyScript: false });
    ```

    Ten en cuenta que si desactivas el script proxy de `fetch`, el SDK no podrá capturar spans de las llamadas `fetch` realizadas por SvelteKit cuando tu ruta tenga una función de carga en el servidor. Esto también significa que los posibles spans creados en el servidor para estas llamadas `fetch` no se conectarán con el rastro del lado del cliente.
  </Expandable>
</PlatformSection>

<PlatformCategorySection supported={['browser']}>
  <Expandable permalink title="Solicitud OPTIONS inesperada">
    Si tu aplicación empezó a comportarse de forma incorrecta por realizar solicitudes OPTIONS adicionales, lo más probable es que sea un problema con encabezados de solicitud `sentry-trace` no deseados, lo cual puede ocurrir cuando usas una configuración demasiado genérica para nuestra integración de Tracing en el SDK para navegador.

    Para solucionarlo, cambia la opción `tracePropagationTargets` durante la inicialización del SDK. Para más detalles, consulta <PlatformLink to="/tracing/instrumentation/automatic-instrumentation/#tracePropagationTarget">Instrumentación automática</PlatformLink> en nuestra documentación de Tracing.
  </Expandable>
</PlatformCategorySection>

<PlatformCategorySection notSupported={['browser']}>
  <PlatformSection notSupported={['javascript.aws-lambda', 'javascript.azure-functions', 'javascript.bun', 'javascript.cloudflare', 'javascript.deno', 'javascript.electron', 'javascript.gcp-functions', 'javascript.tanstackstart-react']}>
    <Expandable permalink title="Error: 'import-in-the-middle' no pudo envolver">
      Al usar ESM, de forma predeterminada todos los paquetes se envuelven bajo el capó con
      [import-in-the-middle](https://www.npmjs.com/package/import-in-the-middle).
      `import-in-the-middle` tiene problemas de compatibilidad con algunos paquetes y
      puede arrojar errores en estas situaciones.

      Consulta la sección <PlatformLink to="/install/esm/#troubleshooting-instrumentation">Solución de problemas de instrumentación en ESM</PlatformLink> para más información.
    </Expandable>
  </PlatformSection>
</PlatformCategorySection>

<PlatformCategorySection supported={['browser']}>
  <Expandable permalink title="Números de línea de `instrument.js` en declaraciones de consola">
    Si `instrument.js` aparece en tu consola mientras depuras, agrega Sentry a tu [Framework Ignore List](https://developer.chrome.com/docs/devtools/settings/ignore-list/#skip-extensions) añadiendo este patrón: `/@sentry/`

    Luego, Chrome ignorará los frames de la pila del SDK al depurar.
  </Expandable>
</PlatformCategorySection>

<PlatformCategorySection supported={['browser']}>
  <Expandable permalink title="Cómo manejar los bloqueadores de anuncios">
    Cuando usas nuestra CDN, las extensiones que bloquean anuncios o scripts pueden impedir que nuestro SDK se descargue e inicialice correctamente. Por ello, cualquier llamada a la API del SDK fallará y puede hacer que tu aplicación se comporte de forma inesperada.

    Además, incluso cuando el SDK se descarga e inicializa correctamente, los endpoints de Sentry que deben recibir los datos capturados también pueden bloquearse. Esto impide que se envíen los informes de errores, el estado de las sesiones o los datos de rendimiento, dejándolos, en la práctica, no disponibles en [sentry.io](https://sentry.io).

    Asimismo, algunos navegadores, como [Brave](https://brave.com/), incluyen bloqueadores de anuncios integrados que pueden bloquear las solicitudes enviadas a nuestro endpoint. Incluso si los usuarios excluyen tu dominio del bloqueo, Brave podría seguir bloqueando [las solicitudes realizadas desde service workers](https://github.com/getsentry/sentry/issues/47912#issuecomment-1573714875).

    Puedes evitar que se bloqueen nuestros bundles de la CDN [usando nuestros paquetes de NPM](#using-the-npm-package) e incorporando nuestro SDK a tu app. Sin embargo, el bloqueo del endpoint solo puede resolverse usando un túnel, como se explica a continuación.
  </Expandable>

  <Expandable permalink title="Uso de la opción «tunnel»">
    <PlatformSection supported={["javascript.nextjs"]}>
      El SDK de Sentry para Next.js ofrece una opción específica que facilita mucho la configuración de túneles y te permite omitir los pasos que se detallan a continuación. Consulta <PlatformLink to="/configuration/build/#tunnelRoute">
      `tunnelRoute`</PlatformLink> para aprender a configurar el túnel en Next.js.

      Si no quieres configurar `tunnelRoute`, puedes seguir la guía a continuación.
    </PlatformSection>

    Un túnel es un endpoint HTTP que actúa como proxy entre Sentry y tu aplicación. Como tú controlas este servidor, no hay riesgo de que se bloquee ninguna solicitud enviada a él. Cuando el endpoint se encuentra bajo el mismo origen (aunque no es necesario para que el túnel funcione), el navegador no tratará las solicitudes al endpoint como solicitudes de terceros. Como resultado, estas solicitudes tendrán aplicadas diferentes medidas de seguridad que, por defecto, no activan los bloqueadores de anuncios. A continuación se puede encontrar un resumen rápido del flujo.

    ![Flujo del túnel](./img/tunnel.png)

    A partir de la versión `6.7.0` del SDK de JavaScript, puedes usar la opción `tunnel` para indicarle al SDK que envíe eventos a la URL configurada, en lugar de usar el DSN. Esto permite que el SDK elimine `sentry_key` de los parámetros de consulta, que es una de las principales razones por las que los bloqueadores de anuncios impiden el envío de eventos. Esta opción también evita que el SDK envíe solicitudes preflight, que era uno de los requisitos que hacían necesario enviar `sentry_key` en los parámetros de consulta.

    Para habilitar la opción `tunnel`, proporciona una URL relativa o absoluta en tu llamada a `Sentry.init`. Cuando uses una URL relativa, esta será relativa al origen actual, y esta es la forma que recomendamos. El uso de una URL relativa no activará una solicitud CORS de preflight, por lo que ningún evento será bloqueado, ya que el bloqueador de anuncios no tratará estos eventos como solicitudes de terceros. Al usar tunneling con SDKs del lado del servidor como `@sentry/node` o `@sentry/bun`, debes proporcionar una URL absoluta.

    ```javascript
    Sentry.init({
      dsn: "___PUBLIC_DSN___",
      tunnel: "/tunnel",
    });
    ```

    Una vez configurado, todos los eventos se enviarán al endpoint `/tunnel`. Sin embargo, esta solución requiere configuración adicional en el servidor, ya que ahora los eventos deben procesarse y redirigirse a Sentry. Aquí tienes un ejemplo para tu componente de servidor:

    ```csharp
    // Esta funcionalidad ahora está integrada en el paquete Sentry.AspNetCore.
    // Consulta https://docs.sentry.io/platforms/dotnet/guides/aspnetcore/#tunnel
    // para más información.

    // Este ejemplo muestra cómo podrías implementarlo tú mismo:

    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Net.Http;
    using System.Text.Json;
    using Microsoft.AspNetCore;
    using Microsoft.AspNetCore.Builder;
    using Microsoft.AspNetCore.Hosting;
    using Microsoft.AspNetCore.Http;

    // Cambia el host apropiadamente si ejecutas tu propia instancia de Sentry.
    const string host = "sentry.io";
    // Establece knownProjectIds como una lista con los IDs de tus proyectos de Sentry que
    // deseas aceptar a través de este proxy.
    var knownProjectIds = new HashSet<string>() {  };

    var client = new HttpClient();
    WebHost.CreateDefaultBuilder(args).Configure(a =>
        a.Run(async context =>
        {
            context.Request.EnableBuffering();
            using var reader = new StreamReader(context.Request.Body);
            var header = await reader.ReadLineAsync();
            var headerJson = JsonSerializer.Deserialize<Dictionary<string, object>>(header);
            if (headerJson.TryGetValue("dsn", out var dsnString)
                && Uri.TryCreate(dsnString.ToString(), UriKind.Absolute, out var dsn))
            {
                var projectId = dsn.AbsolutePath.Trim('/');
                if (knownProjectIds.Contains(projectId) && string.Equals(dsn.Host, host, StringComparison.OrdinalIgnoreCase)) {
                  context.Request.Body.Position = 0;
                  await client.PostAsync($"https://{dsn.Host}/api/{projectId}/envelope/",
                      new StreamContent(context.Request.Body));
                }
            }
        })).Build().Run();
    ```

    ```ruby
    require 'net/http'

    class HomeController < ApplicationController

      SENTRY_HOST = "oXXXXXX.ingest.sentry.io"
      SENTRY_PROJECT_IDS = ["123456"]

      def tunnel
        envelope = request.body.read
        piece = envelope.split("\n").first
        header = JSON.parse(piece)
        dsn = URI.parse(header['dsn'])
        project_id = dsn.path.tr('/', '')

        raise "Nombre de host de Sentry inválido: #{dsn.hostname}" if dsn.hostname != SENTRY_HOST
        raise "ID de proyecto de Sentry inválido: #{project_id}" unless SENTRY_PROJECT_IDS.include?(project_id)

        upstream_sentry_url = "https://#{SENTRY_HOST}/api/#{project_id}/envelope/"
        Net::HTTP.post(URI(upstream_sentry_url), envelope)

        head(:ok)
      rescue => e
        # maneja la excepción según tu preferencia,
        # por ejemplo, registrándola o reenviándola al proyecto Sentry del servidor
        Rails.logger.error('error al tunelizar a Sentry')
      end

    end
    ```

    ```javascript
    const SENTRY_HOST = "oXXXXXX.ingest.sentry.io";
    const SENTRY_PROJECT_IDS = ["123456"];

    export const postAction = async ({ request }) => {
      try {
        const envelopeBytes = await req.arrayBuffer();
        const envelope = new TextDecoder().decode(envelopeBytes);
        const piece = envelope.split("\n")[0];
        const header = JSON.parse(piece);
        const dsn = new URL(header["dsn"]);
        const project_id = dsn.pathname?.replace("/", "");

        if (dsn.hostname !== SENTRY_HOST) {
          throw new Error(`Nombre de host de Sentry inválido: ${dsn.hostname}`);
        }

        if (!project_id || !SENTRY_PROJECT_IDS.includes(project_id)) {
          throw new Error(`ID de proyecto de Sentry inválido: ${project_id}`);
        }

        const upstream_sentry_url = `https://${SENTRY_HOST}/api/${project_id}/envelope/`;
        await fetch(upstream_sentry_url, { method: "POST", body: envelopeBytes });

        return json({}, { status: 200 });
      } catch (e) {
        console.error("error al tunelizar a Sentry", e);
        return json({ error: "error al tunelizar a Sentry" }, { status: 500 });
      }
    };
    ```

    Si tu caso de uso está relacionado con el bloqueo del paquete SDK en sí, cualquiera de las siguientes soluciones te ayudará a resolver este problema.

    ### Uso del paquete NPM

    La mejor forma de lidiar con extensiones que bloquean scripts es usar el paquete SDK directamente a través de `npm` y empaquetarlo con tu aplicación. De esta manera, puedes estar seguro de que el código siempre estará disponible como lo esperas.

    ### Auto-alojamiento de bundles de CDN

    La segunda forma es descargar el SDK desde nuestro CDN y alojarlo tú mismo. De esta manera, el SDK seguirá estando separado del resto de tu código, pero tendrás la certeza de que no será bloqueado, ya que su origen será el mismo que el de tu sitio web.

    Puedes obtenerlo fácilmente usando `curl` o cualquier otra herramienta similar:

    ```bash
    curl https://browser.sentry-cdn.com/5.20.1/bundle.min.js -o sentry.browser.5.20.1.min.js -s
    ```

    ### Uso de la API Proxy de JavaScript

    La última opción es usar el guard `Proxy`, que garantizará que tu código no falle, incluso cuando llames a nuestro SDK bloqueado. `Proxy` es compatible con todos los navegadores excepto Internet Explorer, aunque este navegador no tiene extensiones. Además, si `Proxy` no está disponible en el navegador de ninguno de tus usuarios, se omitirá silenciosamente, así que no tienes que preocuparte de que cause problemas.

    Coloca este fragmento inmediatamente **antes** de la etiqueta `<Expandable>` que contiene nuestro bundle de CDN. El fragmento en formato legible se ve así:

    ```javascript
    if ("Proxy" in window) {
      var handler = {
        get: function (_, key) {
          return new Proxy(function (cb) {
            if (key === "flush" || key === "close") return Promise.resolve();
            if (typeof cb === "function") return cb(window.Sentry);
            return window.Sentry;
          }, handler);
        },
      };
      window.Sentry = new Proxy({}, handler);
    }
    ```

    Si quieres copiar y pegar el fragmento directamente, aquí lo tienes minificado:

    ```html
    <script>
      if ("Proxy" in window) {
        var n = {
          get: function (o, e) {
            return new Proxy(function (n) {
              return "flush" === e || "close" === e
                ? Promise.resolve()
                : "function" == typeof n
                  ? n(window.Sentry)
                  : window.Sentry;
            }, n);
          },
        };
        window.Sentry = new Proxy({}, n);
      }
    </script>
    ```
  </Expandable>
</PlatformCategorySection>

<Expandable permalink title="Librerías de promesas de terceros">
  Cuando incluyes y configuras Sentry, nuestro SDK de JavaScript adjunta automáticamente controladores globales para capturar excepciones no detectadas y rechazos de promesas no gestionados. Puedes desactivar este comportamiento predeterminado cambiando la opción `onunhandledrejection` a `false` en tu integración GlobalHandlers y enganchándote manualmente a cada controlador de eventos, para luego llamar directamente a `Sentry.captureException` o `Sentry.captureMessage`.

  También puede que necesites ajustar tu configuración si usas una librería de terceros para implementar promesas. Además, recuerda que los navegadores suelen aplicar medidas de seguridad que pueden bloquear el envío de errores cuando se sirven archivos de script desde orígenes distintos.
</Expandable>

<Expandable permalink title="Eventos con 'Non-Error Exception'">
  Si ves errores con el mensaje “Non-Error exception (or promise rejection) captured with keys: x, y, z.”, esto ocurre cuando a) llamas a `Sentry.captureException()` con un objeto plano, b) lanzas un objeto plano o c) rechazas una promesa con un objeto plano.

  Puedes ver el contenido del objeto que no es de tipo Error en la entrada `__serialized__` de la sección “Additional Data”.

  Para comprender mejor estos eventos de error, te recomendamos localizar dónde se está pasando o lanzando el objeto plano a Sentry en función del contenido de los datos `__serialized__`, y luego convertir dicho objeto plano en un objeto Error.
</Expandable>

<PlatformCategorySection supported={['browser']}>
  <Expandable permalink title="Capturar 404 de recursos">
    De forma predeterminada, Sentry no captura errores cuando un recurso (como una imagen o un archivo CSS) falla al cargar. Si quieres que lo haga, puedes usar el siguiente código. (Nota: Recomendamos cargar Sentry lo antes posible en cualquier caso, pero este método en particular solo funcionará si Sentry se carga antes que otros recursos).

    ```javascript
    document.body.addEventListener(
      "error",
      (event) => {
        if (!event.target) return;

        if (event.target.tagName === "IMG") {
          Sentry.captureException(
            new Error(`Failed to load image: ${event.target.src}`)
          );
        } else if (event.target.tagName === "LINK") {
          Sentry.captureException(
            new Error(`Failed to load css: ${event.target.href}`)
          );
        }
      },
      true // useCapture - necesario para errores de carga de recursos
    );
    ```

    Recuerda pasar `true` como segundo parámetro a `addEventListener()`. Sin eso, no se llamará al controlador de eventos, ya que se agrega en el ancestro del objetivo del evento en lugar del propio objetivo; y, a diferencia de los errores de tiempo de ejecución de JavaScript, los eventos `error` derivados de fallos de carga no hacen burbujeo y, por lo tanto, deben capturarse durante la fase de `capture`. Para más información, consulta [la especificación del W3C](https://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107/events.html#Events-phases).
  </Expandable>
</PlatformCategorySection>

<PlatformCategorySection supported={['browser']}>
  <Expandable permalink title="El SDK provoca invocaciones dobles de `addEventListener` (p. ej., eventos de clic duplicados)">
    En casos muy raros, el SDK puede provocar que las devoluciones de llamada agregadas mediante `addEventListener` a un objetivo de evento (como un botón) se invoquen dos veces.
    Esto suele ser una señal de que el SDK se inicializó demasiado tarde en el ciclo de vida de la página. Si puedes, intenta inicializar el SDK antes en tu aplicación.

    Si esto no es posible o no aplica a tu caso de uso, establece la opción `unregisterOriginalCallbacks` en la integración [`browserApiErrors`](../configuration/integrations/browserapierrors) en `true`.
  </Expandable>
</PlatformCategorySection>

<Expandable permalink title="Errores de compilación con Vite">
  Si estás usando el [Vite Bundler](https://vitejs.dev/) y un paquete NPM de Sentry, y ves el siguiente error:

  ```
  Error: Could not resolve './{}.js' from node_modules/@sentry/utils/esm/index.js
  ```

  Esto podría deberse a que la opción [`define`](https://vitejs.dev/config/shared-options.html#define) en tu configuración de Vite está reemplazando por cadena alguna variable usada por el SDK de Sentry, como `global`, lo que provoca errores de compilación. Vite recomienda usar `define` solo para constantes y no incluir `process` o `global` en las opciones. Para corregir este error de compilación, elimina o actualiza tu opción `define`, como se muestra a continuación:

  ```javascript {filename:vite.config.ts} {diff}
  export default defineConfig({
     build: {
       sourcemap: true
     },
  -  define: {
  -    global: {}
  -  },
     plugins: [react()]
  })
  ```
</Expandable>

<Expandable permalink title="Falta el módulo `diagnostics_channel`">
  <Include name="diagnostics-channel-build-error-troubleshooting.mdx" />
</Expandable>

<Expandable permalink title="Errores de compilación del plugin Terser">
  <Include name="terser-plugin-build-error-troubleshooting.mdx" />
</Expandable>

<PlatformSection supported={['javascript.angular']}>
  <Expandable permalink title="Hashes no válidos en ngsw.json del Service Worker de Angular">
    Si subes los source maps de tu aplicación Angular con <PlatformLink to="/sourcemaps/uploading/cli">Sentry CLI</PlatformLink>, podrías tener problemas de caché si usas el [service worker de Angular](https://angular.dev/ecosystem/service-workers).
    Obtén más información sobre cómo solucionar estos problemas de caché en la guía <PlatformLink to="/sourcemaps/uploading/cli/#fixing-angular-service-worker-caching-issues">Subida de source maps con Sentry CLI</PlatformLink>.
  </Expandable>
</PlatformSection>

<PlatformSection notSupported={['javascript.nuxt']}>
  <Expandable permalink title="pnpm: Resolver errores del paquete externo 'import-in-the-middle'">
    Al usar pnpm, podrías encontrarte con errores relacionados con paquetes que no pueden tratarse como externos, en particular con paquetes como `import-in-the-middle` y `require-in-the-middle`. Estos errores suelen darse por la estricta gestión de dependencias y el comportamiento de hoisting de pnpm.

    Aunque añadir estos paquetes como dependencias directas podría eliminar los mensajes de advertencia, a menudo no resuelve los problemas de funcionamiento subyacentes:

    ```bash
    pnpm add import-in-the-middle require-in-the-middle
    ```

    Como solución alternativa, crea o modifica el archivo `.npmrc` en la raíz de tu proyecto. Primero, intenta aplicar hoisting específicamente a las dependencias en cuestión:

    ```ini {filename:.npmrc}
    public-hoist-pattern[]=*import-in-the-middle*
    public-hoist-pattern[]=*require-in-the-middle*
    ```

    Si eso no funciona, también puedes indicarle a pnpm que haga hoist de todas las dependencias:

    ```ini {filename:.npmrc}
    shamefully-hoist=true
    ```

    <Alert level="warning">
      <strong>Nota</strong>: Aunque `shamefully-hoist=true` por lo general no es la solución ideal desde
      la perspectiva de la gestión de dependencias, a veces es necesaria para la
      compatibilidad con ciertos paquetes que esperan un comportamiento de
      resolución de módulos de Node.js similar al de npm o yarn.
    </Alert>
  </Expandable>
</PlatformSection>

<PlatformSection supported={['javascript.nuxt']}>
  <Expandable permalink title="Error al registrar 'import-in-the-middle' durante la compilación">
    Después de agregar `sentry.server.config.ts` y compilar el proyecto, podrías ver un error como este:
    `Failed to register ESM hook import-in-the-middle/hook.mjs`. Puedes agregar un override (npm/pnpm) o una resolution (yarn)
    para `@vercel/nft` para solucionarlo. Esto añadirá el archivo `hook.mjs` al resultado de tu compilación. Consulta el [problema subyacente en el proyecto UnJS Nitro](https://github.com/unjs/nitro/issues/2703).

    Nitro actualizó `@vercel/nft` en la versión `2.10.0` de Nitro, así que puede que ya no veas este error y no necesites
    agregar este override/resolution.

    ```json {tabTitle:npm} {filename:package.json}
    "overrides": {
      "@vercel/nft": "^0.27.4"
    }
    ```

    ```json {tabTitle:yarn} {filename:package.json}
    "resolutions": {
      "@vercel/nft": "^0.27.4"
    }
    ```

    ```json {tabTitle:pnpm} {filename:package.json}
    "pnpm": {
      "overrides": {
        "@vercel/nft": "^0.27.4"
      }
    }
    ```
  </Expandable>

  <Expandable permalink title="pnpm dev: No se encuentra el paquete 'import-in-the-middle'">
    Sentry inyecta `import "import-in-the-middle/hook.mjs"` en el entry del servidor. Esta importación sirve como indicación para que los empaquetadores de Node incluyan realmente este archivo.
    Como pnpm implementa un aislamiento estricto de dependencias, esta importación podría causar problemas.
    De forma predeterminada, `shamefully-hoist` es `false` ([documentación de pnpm aquí](https://pnpm.io/next/npmrc#shamefully-hoist)) y esto impide acceder a dependencias no declaradas.
    Probablemente no quieras cambiar esta configuración, así que debes agregar explícitamente la dependencia `import-in-the-middle`:

    ```bash
    pnpm add import-in-the-middle
    ```
  </Expandable>

  <Expandable permalink title="Nuxt: Nitro del lado del servidor no está enviando eventos">
    Nuxt compila la aplicación Nitro del lado del servidor como ES Modules, lo que introduce limitaciones para el tracing del lado del servidor durante el desarrollo.
    Actualmente, la recopilación de trazas solo es compatible al compilar y ejecutar la aplicación. El modo de desarrollo (`nuxt dev`) no es compatible por ahora.

    Al ejecutar el resultado de la compilación, Sentry debe inicializarse antes de ejecutar el resto de la aplicación. Esto se hace automáticamente, pero podría no funcionar en tu caso.
    Lee más sobre esto en <PlatformLink to="/install">métodos de instalación</PlatformLink>.

    ***

    Actualmente estamos investigando un problema por el que el lado del servidor no se inicializa correctamente con una actualización reciente de Nitro (el toolkit del lado del servidor en Nuxt).

    Estamos trabajando para resolverlo ([consulta el issue aquí](https://github.com/getsentry/sentry-javascript/issues/14514)). Por el momento, puedes agregar los siguientes overrides a tu aplicación:

    ```json {tabTitle:npm} {filename:package.json}
    "overrides": {
      "nitropack": "~2.9.7",
      "@vercel/nft": "^0.27.4"
    }
    ```

    ```json {tabTitle:yarn} {filename:package.json}
    "resolutions": {
      "nitropack": "~2.9.7",
      "@vercel/nft": "^0.27.4"
    }
    ```

    ```json {tabTitle:pnpm} {filename:package.json}
    "pnpm": {
      "overrides": {
        "nitropack": "~2.9.7",
        "@vercel/nft": "^0.27.4"
      }
    }
    ```
  </Expandable>
</PlatformSection>

<PlatformSection supported={['javascript.nextjs']}>
  <Expandable permalink title="Errores de falta de memoria (OOM) durante la compilación">
    El problema aquí está relacionado con el consumo de memoria durante el proceso de compilación, especialmente al generar mapas de origen (source maps). Aquí tienes algunas posibles soluciones y alternativas:

    * Actualiza tu paquete `@sentry/nextjs` a la versión más reciente.
    * Aumenta el límite de memoria de Node.js: Puedes intentar aumentar el límite de memoria para Node.js durante el proceso de compilación. Añade esto a tu comando de compilación: `NODE_OPTIONS="--max-old-space-size=8192" next build`. Este flag aumentará la memoria disponible para el proceso de Node a 8 GB. Hemos visto que Next.js consume alrededor de 4 GB en la mayoría de los casos. Ajusta el tamaño según la memoria que tengas disponible.
    * Desactiva los mapas de origen por completo: Como último recurso, puedes desactivar completamente la generación de mapas de origen:

    ```js {filename:next.config.js}
      module.exports = withSentryConfig(module.exports, {
        sourcemaps: {
          disable: true,
        },
      }
    ```
  </Expandable>
</PlatformSection>

<PlatformSection supported={['javascript.nextjs']}>
  <Expandable permalink title="Uso del SDK de Sentry para Next en un monorepo de Nx (usando `@nx/next`)">
    Para configurar el SDK de Next.js de Sentry en un monorepo de Nx, considera la siguiente configuración:

    ```js {filename:next.config.js}
      const nextConfig = {
      // ...
      };

      const plugins = [
      // Tus plugins, excluyendo withNx
      ];

      module.exports = async (phase, context) => {
        let updatedConfig = plugins.reduce((acc, fn) => fn(acc), nextConfig);

        // Aplica la función asíncrona que devuelve `withNx`.
        updatedConfig = await withNx(updatedConfig)(phase, context);

        return updatedConfig;
      };

      // El plugin de Sentry siempre debe aplicarse al final
      const { withSentryConfig } = require('@sentry/nextjs');
      module.exports = withSentryConfig(module.exports)
    ```
  </Expandable>

  <Expandable permalink title="Hook de instrumentación del cliente - Ejecución lenta detectada">
    Ver esta advertencia en tu build de desarrollo puede ser engañoso debido a los detalles internos del servidor de desarrollo de Next.js.

    Si usas Session Replay y experimentas problemas de rendimiento con el hook de instrumentación del cliente, puedes intentar cargar Session Replay de forma diferida como se describe [aquí](/es/platforms/javascript/guides/nextjs/session-replay/#lazy-loading-replay).

    Si quieres inicializar el SDK más tarde, la precisión de los datos de tracing disminuirá y podrían ocurrir errores antes de que el SDK esté inicializado. Esta es una compensación que deberías valorar según tu caso de uso, aunque recomendamos inicializar el SDK lo antes posible.
  </Expandable>
</PlatformSection>

Si necesitas ayuda adicional, puedes [preguntar en GitHub](https://github.com/getsentry/sentry-javascript/issues/new/choose). Los clientes con un plan de pago también pueden contactar con soporte.
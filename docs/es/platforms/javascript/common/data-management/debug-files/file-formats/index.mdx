---
title: "Depurar formatos de archivo"
description: "Conoce los formatos de archivo específicos de cada plataforma y la información de depuración que contienen."
sidebar_order: 1
supported:
  - javascript.capacitor
  - javascript.electron
---

Sentry distingue cuatro tipos de información de depuración:

* **Información de depuración:** Proporciona nombres de funciones, rutas a archivos fuente, números de línea y frames inline. El proceso de resolver esta información a partir de direcciones de instrucción se llama “symbolication”. Esta información es relativamente grande en comparación con el ejecutable y normalmente se coloca en un archivo aparte. En Sentry, estos archivos se denominan *debug companions* y muestran la etiqueta `debug`.

* **Tablas de símbolos:** Si no hay información de depuración disponible para una biblioteca determinada, Sentry puede usar tablas de símbolos como alternativa para recuperar nombres de funciones. Las tablas de símbolos suelen estar incluidas tanto en el ejecutable como en los archivos de acompañamiento de depuración. Sin embargo, no contienen suficiente información para resolver funciones inline ni nombres de archivo y números de línea. La etiqueta `symtab` indica tablas de símbolos.

* **Código fuente:** Por convención, el código fuente no forma parte de los archivos habituales de información de depuración. Sentry CLI puede empaquetar el código fuente de tu aplicación y subirlo para mostrar contexto de código en los stack traces en Sentry. Estos paquetes aparecen con la etiqueta `sources`.

* **Información de unwinding:** Permite a Sentry extraer stack traces de Minidumps y otros formatos binarios de fallos en builds optimizadas. Este proceso se conoce como “stack unwinding” o “stack walking”. Dado que también se requiere al lanzar excepciones en C++, esta información suele incluirse en el ejecutable o la biblioteca. Si un archivo subido contiene esta información, muestra la etiqueta `unwind`. Ten en cuenta que en algunas plataformas no se realiza un unwinding real. Por ejemplo, WebAssembly actualmente no tiene el equivalente de minidumps, lo que significa que no requerimos ese tipo de información en esos casos.

Los compiladores colocan la información de depuración anterior en archivos distintos según la plataforma de destino, la arquitectura, las flags de compilación o el nivel de optimización. En consecuencia, Sentry podría no necesitar toda la información anterior para procesar informes de fallos. Aun así, siempre es buena idea proporcionar toda la información de depuración disponible.

`sentry-cli` puede usarse para listar propiedades de los archivos de depuración compatibles y validar su contenido. Consulta [*Archivos de información de depuración en sentry-cli*](/es/cli/dif/) para obtener más información.

<div id="mach-o-and-dsym">
  ## Mach-O y dSYM
</div>

Los ejecutables, las bibliotecas dinámicas y los artefactos de depuración en todas las plataformas de Apple usan
el formato contenedor *Mach Object*, o *Mach-O* para abreviar. Esto aplica a iOS,
iPadOS, tvOS, watchOS, macOS y visionOS.

* **Ejecutables** no llevan extensión de archivo. En aplicaciones de escritorio, a menudo
  se ubican en estructuras de paquetes de app con el sufijo `.app`. A menos que se
  elimine manualmente, un ejecutable contiene información de unwinding y una tabla de símbolos.
  La información de depuración nunca se almacena en los ejecutables.

* **Bibliotecas dinámicas** usan la extensión `.dylib` y, por lo demás, se comportan exactamente
  igual que los ejecutables.

* **Artefactos de depuración** se colocan en una estructura de carpetas con la extensión `.dSYM`,
  y se encuentran en `<name>.dSYM/Contents/Resources/DWARF/<name>`.
  Suelen contener una tabla de símbolos e información de depuración, pero rara vez información de unwinding.

Al compilar una aplicación con Xcode o con el compilador `clang`, la información de depuración
se coloca automáticamente en un archivo dSYM. Sin embargo, al enlazar manualmente,
el archivo dSYM debe crearse usando el siguiente comando:

```bash
dsymutil /ruta/a/salida[.dylib]
```

<div id="executable-and-linkable-format-elf">
  ## Formato Ejecutable y Enlazable (ELF)
</div>

En las distribuciones de Linux, los ejecutables y la información de depuración se almacenan en contenedores *ELF*. A diferencia de otras plataformas, no existe un contenedor ni un especificador dedicado para archivos de depuración acompañantes.

La información de depuración forma parte del binario (ejecutable o biblioteca) y se elimina al generar compilaciones de lanzamiento debido a su tamaño. Sin embargo, existe una forma de conservarla en un archivo aparte (ya sea en una ubicación distinta o con la extensión `.debug`):

```bash
# Hay un ejecutable llamado «binary» en el CWD
objcopy --only-keep-debug binary binary.debug
objcopy --strip-debug --strip-unneeded binary
objcopy --add-gnu-debuglink=binary.debug binary
```

Esto da como resultado la siguiente estructura:

* **Ejecutables** no llevan extensión de archivo. Si se les aplica stripping como arriba,
  los ejecutables contienen una tabla de símbolos, pero no información de depuración. Si en la
  compilación se omiten los frame pointers, también se conservará la información de unwind. Ambos se pueden
  depurar aún más usando flags como `--strip-all`.

* **Bibliotecas compartidas** usan la extensión `.so` y, por lo demás, se comportan exactamente
  igual que los ejecutables.

* **Archivos de depuración** no llevan una extensión estándar, pero a menudo
  se llaman `.debug`. Si se les aplica stripping como arriba, estos archivos contienen información de unwind,
  información de depuración y una tabla de símbolos.

Las bibliotecas compartidas instaladas mediante gestores de paquetes suelen proporcionar su información de depuración
en paquetes `*-dev` separados y la colocan en ubicaciones como
`/usr/local/debug/...`. Para recibir trazas de pila simbolizadas de esas
bibliotecas, asegúrate de subir también sus símbolos además de los símbolos de tu app.

ELF admite la compresión de la información de depuración, lo que puede reducir significativamente
el tiempo necesario para subir archivos de información de depuración a Sentry y así mejorar
los tiempos de compilación. `gcc` (versión 5 o posterior) y `clang` (versión 5 o posterior) lo admiten
pasando el flag `-gz` tanto al compilador como al enlazador. La forma habitual
de comprimir la información de depuración, sin embargo, es al hacer stripping del ejecutable:

```bash
# Ten en cuenta la opción --compress-debug-sections
objcopy --only-keep-debug --compress-debug-sections=zlib binary binary.debug
```

Esto puede verificarse comprobando el indicador `C` en `readelf`, que corresponde a
`SHF_COMPRESSED`:

```bash
readelf -S ruta/al/archivo
  ...
  [21] .debug_info       PROGBITS         0000000000000000  00000370
       000000000000e133  0000000000000000   C       0     0     1
```

<div id="pe-and-pdb">
  ## PE y PDB
</div>

Los ejecutables y las bibliotecas dinámicas en Microsoft Windows, y los creados por la
plataforma .NET en todos los sistemas operativos, usan el formato de contenedor *Portable Executable* (*PE*).
La información de depuración asociada se almacena en archivos *Program Database*
(*PDB*).

* Los **ejecutables** usan la extensión de archivo `.exe`. Solo cuando se compilan para arquitecturas
  de 64 bits contienen información de “unwind”. De lo contrario, no contienen
  información utilizable y se omitirán al cargarlos en Sentry.

* Las **bibliotecas dinámicas** usan la extensión `.dll` y, por lo demás, se comportan
  exactamente igual que los ejecutables.

* Los **archivos de depuración** se almacenan en `.pdb`. Por lo general, contienen información
  de depuración y, en la mayoría de los casos, tablas de símbolos. En programas de 32 bits, también
  incluyen información de “unwind”. En casos poco frecuentes, pueden tener nombres de archivo distintos a los de su ejecutable correspondiente.

* La plataforma .NET usa una variación de este formato, llamada [Portable PDBs](https://github.com/dotnet/core/blob/main/Documentation/diagnostics/portable_pdb.md).
  Los Portable PDBs son compatibles a partir de Sentry 22.11.0 (o Sentry CLI 2.8.0, o Symbolic 10.0.0).

<div id="breakpad-symbols">
  ## Símbolos de Breakpad
</div>

La biblioteca Google Breakpad ha establecido un formato ASCII independiente de la plataforma
para almacenar información de depuración. Estos archivos suelen generarse para aplicaciones
que usan Breakpad, Crashpad o el framework Electron.

El repositorio de Breakpad incluye herramientas `dump_syms` para cada plataforma que
pueden convertir archivos de depuración nativos en símbolos de Breakpad. Estos convertidores
agrupan toda la información disponible en un solo archivo, de modo que solo sea necesario subir un archivo.

A diferencia de los archivos de depuración nativos, los símbolos de Breakpad descartan mucha información
que no es necesaria para procesar minidumps. En particular, las funciones en línea no se declaran,
por lo que Sentry no puede mostrar fotogramas en línea en los rastreos de pila.

<div id="wasm">
  ## WASM
</div>

Para WebAssembly, admitimos [DWARF en contenedores WASM](https://yurydelendik.github.io/webassembly-dwarf/).
Ten en cuenta que no admitimos los source maps, que también son un formato usado para la depuración de WASM, pero que tienen limitaciones que los vuelven poco prácticos para una herramienta de reporte de fallos como Sentry.

[WebAssembly admite build IDs](https://github.com/WebAssembly/tool-conventions/blob/main/BuildId.md) como una
[sección personalizada](https://webassembly.github.io/spec/core/binary/modules.html#custom-section). Esta sección
es compatible con `LLVM` [desde la versión 17](https://github.com/llvm/llvm-project/commit/c7af9ae577bb04c5fe120fc07844a500818c8f47) (y, con ello, la correspondiente toolchain de `emscripten`).

Además, proporcionamos una herramienta para agregar build IDs y dividir archivos llamada [wasm-split](https://github.com/getsentry/symbolicator/blob/master/crates/wasm-split)
para ayudarte a crear un archivo de depuración complementario listo para subir a Sentry,
mientras eliminas toda la información de depuración del binario de la versión.

<div id="proguard-mappings">
  ## Mapeos de ProGuard
</div>

Los archivos de mapeo de ProGuard permiten que Sentry convierta rutas de clases y nombres de métodos ofuscados de Java a su forma original. En ese sentido, actúan como archivos de información de depuración para aplicaciones Java y Android.
---
title: Alcances
description: "Los SDK suelen gestionar automáticamente los alcances por ti en las integraciones con frameworks. Descubre qué es un alcance y cómo puedes aprovecharlo."
---

Cuando se captura un evento y se envía a Sentry, los SDK combinan esos datos del evento con información adicional del alcance actual. Por lo general, los SDK gestionan automáticamente los alcances por ti en las integraciones con frameworks y no tienes que preocuparte por ellos. Aun así, conviene que sepas qué es un alcance y cómo puedes sacarle partido.

<div id="whats-a-scope">
  ## ¿Qué es un scope?
</div>

Los scopes contienen información útil que se envía junto con el
evento. Por ejemplo, los [contexts](../context/) y las
[breadcrumbs](../breadcrumbs/) se almacenan en
el scope. Cuando se bifurca un scope, hereda todos los datos de su scope padre.

Las integraciones predeterminadas del SDK bifurcan los scopes de forma inteligente. Por ejemplo, las integraciones de frameworks web bifurcan scopes alrededor de tus
rutas o controladores de solicitudes.

<div id="how-scopes-work">
  ## Cómo funcionan los scopes
</div>

Los scopes son básicamente una pila de datos que se asocia a los eventos. Cuando se captura un evento, el SDK combinará los datos de los scopes activos en el evento. Esto te permite adjuntar datos a los eventos que sean relevantes para el contexto en el que se capturó el evento.

Un scope generalmente es válido dentro de un callback o un contexto de ejecución. Esto significa que varias partes de tu aplicación pueden tener diferentes scopes activos al mismo tiempo. Por ejemplo, un servidor web podría manejar varias solicitudes simultáneamente, y cada solicitud podría tener distintos datos de scope para aplicar a sus eventos.

<div id="different-kinds-of-scopes">
  ## Tipos de scopes
</div>

El SDK de Sentry tiene tres tipos de scopes:

- [Scope global](#global-scope)
- [Scope de aislamiento](#isolation-scope)
- [Scope actual](#current-scope)

<div id="global-scope">
  ### Alcance global
</div>

El alcance global se aplica a _todos_ los eventos, sin importar de dónde provengan. Puedes usarlo para almacenar datos que deban aplicarse a todos los eventos, como información de entorno.

Puedes acceder al alcance global mediante `Sentry.getGlobalScope()`.

Ten en cuenta que el alcance global solo puede usarse para escribir datos, no para capturar eventos. Los eventos solo pueden capturarse en el alcance actual (por ejemplo, `getCurrentScope().captureException()` y API similares).

<div id="isolation-scope">
  ### Ámbito de aislamiento
</div>

El ámbito de aislamiento se usa para aislar eventos entre sí. Por ejemplo, cada solicitud en un servidor web puede tener su propio ámbito de aislamiento, de modo que los eventos de una solicitud no interfieran con los de otra. En la mayoría de los casos, querrás colocar en el ámbito de aislamiento los datos que deban aplicarse a tus eventos; por eso todos los métodos `Sentry.setXXX`, como `Sentry.setTag()`, escriben datos en el ámbito de aislamiento activo. Un ejemplo clásico de datos que pertenecen al ámbito de aislamiento es el usuario: cada solicitud puede tener un usuario diferente, así que debes asegurarte de establecer el usuario en el ámbito de aislamiento.

Puedes acceder al ámbito de aislamiento mediante `Sentry.getIsolationScope()`, pero normalmente solo usarás los métodos `Sentry.setXXX` para establecer datos en el ámbito de aislamiento activo:

```javascript
Sentry.setTag("my-tag", "my value");
// Es idéntico a:
Sentry.getIsolationScope().setTag("my-tag", "my value");
```

<PlatformCategorySection supported={["browser"]}>
  En el navegador, el ámbito de aislamiento nunca se bifurca, porque es imposible
  hacer un seguimiento de a qué ámbito de aislamiento pertenecería. Por ello, en
  el navegador el ámbito de aislamiento es, en la práctica, global.
</PlatformCategorySection>

Ten en cuenta que el ámbito de aislamiento solo puede usarse para escribir datos, no para capturar eventos. Los eventos solo pueden capturarse en el ámbito actual (p. ej., `getCurrentScope().captureException()` y APIs similares).


<div id="current-scope">
  ### Alcance actual
</div>

El alcance actual es el alcance local que está activo en este momento. A diferencia del alcance de aislamiento, que rara vez se ramifica, el alcance actual puede ramificarse con más frecuencia y de forma interna. Se puede usar para almacenar datos que solo deban aplicarse a eventos específicos. En la mayoría de los casos, no deberías acceder a este alcance directamente, sino usar `Sentry.withScope` para crear un nuevo alcance que solo esté activo para una parte específica de tu código:

```javascript
Sentry.withScope((scope) => {
  // scope es el ámbito actual dentro de este callback
  scope.setTag("my-tag", "my value");
  // esta etiqueta solo se aplicará a los eventos capturados dentro de este callback
  // el siguiente evento tendrá la etiqueta:
  Sentry.captureException(new Error("my error"));
});
// este evento no tendrá la etiqueta:
Sentry.captureException(new Error("my other error"));
```

Puedes acceder al scope actual mediante `Sentry.getCurrentScope()`, pero en la mayoría de los casos no deberías usar esta API, sino `withScope` para generar y acceder a un scope local. No se garantiza la consistencia de `getCurrentScope` en distintas partes de tu aplicación, ya que el scope puede bifurcarse internamente en varios puntos.


<div id="how-scope-data-is-applied-to-events">
  ## Cómo se aplican los datos del alcance a los eventos
</div>

Antes de enviar un evento (como un error o una transacción) a Sentry, se le aplican los alcances activos.

Primero se aplica el alcance global, luego el alcance de aislamiento y, por último, el alcance actual. Esto significa que cualquier dato definido en el alcance actual tendrá prioridad sobre el definido en los alcances de aislamiento y global:

```javascript
Sentry.getGlobalScope().setExtras({
  shared: "global",
  global: "data",
});
Sentry.getIsolationScope().setExtras({
  shared: "isolation",
  isolation: "data",
});
Sentry.getCurrentScope().setExtras({
  shared: "current",
  current: "data",
});

Sentry.captureException(new Error("mi error"));
// --> Tendrá los siguientes extras:
// { shared: 'current', global: 'data', isolation: 'data', current: 'data' }
```


<div id="configuring-the-scope">
  ## Configurar el alcance
</div>

En la mayoría de los casos, deberías usar directamente métodos de nivel superior como `Sentry.setTag()`, que establecerán los datos en el alcance de aislamiento y garantizarán que se apliquen a todos los eventos relacionados con la solicitud o proceso actual.

Si quieres aplicar datos a un alcance más acotado, puedes usar `withScope` para crear un nuevo alcance que solo esté activo en una parte específica de tu código. `withScope` recibe el alcance como argumento de la función de retorno (callback), que puedes usar para establecer datos en el alcance.

<PlatformContent includePath="enriching-events/import" />

Puedes, por ejemplo, añadir etiquetas personalizadas o informar a Sentry sobre el usuario autenticado actualmente.

```javascript
Sentry.setTag("my-tag", "my value");
Sentry.setUser({
  id: 42,
  email: "john.doe@example.com",
});

// Alternativamente, puedes usar `withScope` como se documenta más abajo.
```

Para saber qué información útil se puede asociar a los scopes, consulta
[context](../context/), [tags](../tags), [users](../identify-user) y [breadcrumbs](../breadcrumbs/).

Recomendamos evitar usar `getCurrentScope()` y establecer datos en él, ya que el scope actual puede tener una vida útil poco fiable. En su lugar:

* Si quieres aplicar datos a la solicitud/proceso actual (en Node) o a la vista de página actual (en el navegador), usa los métodos de nivel superior, p. ej., `Sentry.setTag()`.
* Si quieres aplicar datos a todos los eventos, sin importar dónde se capturen, usa métodos en el scope global, p. ej., `getGlobalScope().setTag()`.
* Si quieres aplicar datos a un scope más acotado, usa `withScope` para crear un nuevo scope que solo esté activo para una parte específica de tu código.


<div id="using-withscope">
  ## Uso de `withScope`
</div>

En el siguiente ejemplo usamos <PlatformIdentifier name="with-scope" /> para adjuntar un `level` y una `tag` a un único error específico:

<PlatformContent includePath="enriching-events/scopes/with-scope" />

El scope dentro del callback de `withScope()` solo es válido dentro del propio callback. Una vez que el callback termina, el scope se elimina y deja de aplicarse. El scope interno solo se aplica a los eventos capturados dentro del callback. `withScope()` clonará (o bifurcará) el scope actual, de modo que este no se modifique. Esto te permite
aislar más fácilmente fragmentos de información de contexto en ubicaciones específicas de tu código o
incluso llamar a <PlatformIdentifier name="clear" /> para eliminar temporalmente toda la información de contexto.

<PlatformCategorySection supported={['server']}>
<div id="using-withisolationscope">
  ## Uso de `withIsolationScope`
</div>

`withIsolationScope` funciona básicamente igual que `withScope`, pero bifurca el scope de aislamiento en lugar del scope actual. En general, el scope de aislamiento debería bifurcarse con menos frecuencia que el scope actual y, en la mayoría de los casos, el SDK lo manejará automáticamente por ti.

Pero en casos en los que, por ejemplo, quieras aislar un proceso que no está vinculado a una solicitud (p. ej., un trabajo en segundo plano), puedes usar `withIsolationScope` para crear un nuevo scope de aislamiento que solo esté activo durante la ejecución del callback:

<PlatformContent includePath="enriching-events/scopes/with-isolation-scope" />
</PlatformCategorySection>
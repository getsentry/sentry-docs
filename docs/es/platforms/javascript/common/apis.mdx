---
title: APIs
description: "Más información sobre las APIs del SDK."
customCanonicalTag: "/platforms/javascript/apis/"
sidebar_order: 3
---

Esta página muestra todas las APIs de nivel superior disponibles del SDK. Puedes usar estas APIs como la forma principal de:

* Configurar el SDK después de la inicialización
* Capturar manualmente distintos tipos de eventos
* Enriquecer eventos con datos adicionales
* ... y mucho más

Estas APIs son funciones que puedes usar de la siguiente manera: todas están disponibles en el objeto `Sentry` de nivel superior:

```javascript
import * as Sentry from "@sentry/browser";

Sentry.setTag("tag", "value");
```

<div id="available-apis">
  ## API disponibles
</div>

<TableOfContents ignoreIds={["available-apis"]} />

<div id="core-apis">
  ## APIs principales
</div>

<SdkApi name="init" signature="function init(options: InitOptions): Client | undefined">
  Inicializa el SDK con las opciones indicadas. Consulta{" "}
  <PlatformLink to="/configuration/options/">Opciones</PlatformLink> para ver
  las opciones que puedes pasar a `init`.
</SdkApi>

<SdkApi name="getClient" signature="function getClient(): Client | undefined">
  Devuelve el cliente activo actualmente.
</SdkApi>

<SdkApi name="setCurrentClient" signature="function setCurrentClient(client: Client): void">
  Establece el cliente indicado como el cliente actual. No necesitas esto si usas
  `init()`, solo es necesario si configuras un cliente manualmente.
</SdkApi>

<SdkApi name="lastEventId" signature="function lastEventId(): string | undefined">
  Devuelve el ID del último evento de error enviado. Ten en cuenta que esto no
  garantiza que este ID de evento exista, ya que puede haberse descartado en el
  proceso.
</SdkApi>

<SdkApi
  name="flush"
  signature="function flush(timeout?: number): Promise<boolean>"
  parameters={[
  {
    name: "timeout",
    type: "number",
    description:
      "Tiempo máximo en ms que el cliente debe esperar para vaciar su cola de eventos. Si se omite este parámetro, el cliente esperará hasta que se envíen todos los eventos antes de resolver la promesa.",
  },
]}
>
  Vacía todos los eventos pendientes.
</SdkApi>

<SdkApi name="isEnabled" signature="function isEnabled(): boolean">
  Devuelve true si el SDK está inicializado y habilitado.
</SdkApi>

<SdkApi
  name="close"
  signature="function close(timeout?: number): Promise<boolean>"
  parameters={[
  {
    name: "timeout",
    type: "number",
    description:
      "Tiempo máximo en ms que el cliente debe esperar para vaciar su cola de eventos. Si se omite este parámetro, el cliente esperará hasta que se envíen todos los eventos antes de resolver la promesa.",
  },
]}
>
  Vacía todos los eventos pendientes y deshabilita el SDK. Ten en cuenta que esto no
  elimina ningún listener que el SDK pueda haber configurado. Después de llamar a `close`, el cliente actual ya no se puede usar. Es
  importante llamar a `close` solo inmediatamente antes de cerrar la aplicación.

  Como alternativa, el método [`flush`](#flush) vacía la cola de eventos mientras mantiene el
  cliente habilitado para seguir usándolo.
</SdkApi>

<SdkApi
  name="addEventProcessor"
  signature="function addEventProcessor(processor: EventProcessor): void"
  parameters={[
  {
    name: "processor",
    type: "(event: Event, hint: EventHint) => Event | null | Promise<Event | null>",
  },
]}
>
  Agrega un procesador de eventos al SDK. Un procesador de eventos recibe cada evento
  antes de enviarlo a Sentry. Puede mutar el evento (y devolverlo) o
  devolver `null` para descartarlo. Los procesadores de eventos también pueden devolver una
  promesa, pero se recomienda usar esto solo cuando sea necesario, ya que ralentiza
  el procesamiento de eventos.

  <PlatformCategorySection notSupported={["server", "serverless"]}>
    Los procesadores de eventos agregados mediante `Sentry.addEventProcessor()` se aplicarán a todos
    los eventos de tu aplicación. Si quieres agregar un procesador de eventos que solo
    se aplique a ciertos eventos, también puedes agregar uno a un scope de la siguiente manera:
  </PlatformCategorySection>

  <PlatformCategorySection supported={['server', 'serverless']}>
    Los procesadores de eventos agregados mediante `Sentry.addEventProcessor()` se aplicarán a todos los eventos de tu solicitud actual.

    Si quieres agregar un procesador de eventos que solo se aplique a ciertos eventos, también puedes agregar uno a un scope de la siguiente manera:
  </PlatformCategorySection>

  ```javascript
  Sentry.withScope((scope) => {
    scope.addEventProcessor((event) => {
      // esto solo se aplicará a los eventos capturados dentro de este scope
      return event;
    });

    Sentry.captureException(new Error("test"));
  });
  ```

  <Expandable title="¿Cuál es la diferencia con `beforeSend` / `beforeSendTransaction`?">
    `beforeSend` y `beforeSendTransaction` se ejecutan garantizadamente al final, después de todos los demás procesadores de eventos (lo que significa que obtienen la versión final del evento justo antes de que se envíe, de ahí el nombre). Los procesadores de eventos agregados con `addEventProcessor` se ejecutan en un orden indeterminado, por lo que aún pueden hacerse cambios al evento después de que se ejecute el procesador.

    Solo puede existir un único procesador `beforeSend` / `beforeSendTransaction`, pero puedes agregar varios procesadores de eventos mediante `addEventProcessor()`.
  </Expandable>
</SdkApi>

<SdkApi name="addIntegration" signature="function addIntegration(integration: Integration): void">
  Agrega una integración al SDK. Puedes usar esto para añadir integraciones de forma condicional después de llamar a `Sentry.init()`. Ten en cuenta que, cuando sea posible, se recomienda pasar las integraciones a `init` en lugar de llamar a este método.

  Consulta <PlatformLink to="/configuration/integrations">Integrations</PlatformLink> para obtener más información sobre cómo usar integraciones.
</SdkApi>

<SdkApi name="lazyLoadIntegration" signature="function lazyLoadIntegration(name: string, scriptNonce?: string): Promise<Integration>" categorySupported={['browser']}>
  Carga una integración de forma diferida. Se espera que el nombre sea, p. ej., `replayIntegration`. Cargará el script desde el CDN y devolverá una promesa que se resuelve con la integración, la cual luego se puede añadir al SDK usando `addIntegration`:

  ```javascript
  Sentry.lazyLoadIntegration("replayIntegration")
    .then((integration) => {
      Sentry.addIntegration(integration);
    })
    .catch((error) => {
      // Asegúrate de manejar los errores aquí.
      // Esto se rechaza, p. ej., si no se puede cargar el bundle del CDN
    });
  ```

  Si usas un bundler, se recomienda usar, p. ej., `const { replayIntegration } = await import('@sentry/browser')` en su lugar.

  Consulta <PlatformLink to="/configuration/integrations">Integrations</PlatformLink> para obtener más información sobre cómo usar integraciones.
</SdkApi>

<div id="capturing-events">
  ## Captura de eventos
</div>

<SdkApi
  name="captureException"
  signature={`function captureException(
exception: unknown,
captureContext?: CaptureContext
): EventId`}
  parameters={[
  {
    name: "exception",
    required: true,
    type: "unknown",
    description:
      "La excepción que se va a capturar. Para obtener mejores resultados, pasa un objeto `Error`, pero acepta cualquier tipo de valor.",
  },
  {
    name: "captureContext",
    type: {
      name: "CaptureContext",
      properties: [
        {
          name: "user",
          type: {
            name: "User",
            properties: [
              { name: "id", type: "string | number" },
              { name: "email", type: "string" },
              { name: "ip_address", type: "string" },
              { name: "username", type: "string" },
            ],
          },
        },
        {
          name: "level",
          type: '"fatal" | "error" | "warning" | "log" | "info" | "debug"',
        },
        {
          name: "extra",
          type: "Record<string, unknown>",
          description:
            "Datos adicionales que se enviarán con la excepción.",
        },
        {
          name: "tags",
          type: "Record<string, string>",
          description:
            "Etiquetas adicionales que se enviarán con la excepción.",
        },
        { name: "contexts", type: "Record<string, Record<string, unknown>>" },
        { name: "fingerprint", type: "string[]" },
      ],
    },
    description: "Datos adicionales opcionales para adjuntar al evento de Sentry.",
  },
]}
>
  Captura un evento de excepción y lo envía a Sentry. Ten en cuenta que puedes pasar no solo objetos `Error`, sino también otros objetos como `exception`; en ese caso, el SDK intentará serializar el objeto por ti y la traza de pila será generada por el SDK y puede ser menos precisa.
</SdkApi>

<SdkApi
  name="captureMessage"
  signature={`function captureMessage(
message: string,
captureContext?: CaptureContext | SeverityLevel
): EventId`}
  parameters={[
{
  name: "message",
  required: true,
  type: "string",
  description: "El mensaje que se va a capturar.",
},
{
  name: "captureContext",
  type: {
    name: "CaptureContext",
    properties: [
      {
        name: "user",
        type: {
          name: "User",
          properties: [
            { name: "id", type: "string | number" },
            { name: "email", type: "string" },
            { name: "ip_address", type: "string" },
            { name: "username", type: "string" },
          ],
        },
      },
      {
        name: "level",
        type: '"fatal" | "error" | "warning" | "log" | "info" | "debug"',
      },
      {
        name: "extra",
        type: "Record<string, unknown>",
        description:
          "Datos adicionales que se enviarán con la excepción.",
      },
      {
        name: "tags",
        type: "Record<string, string>",
        description:
          "Etiquetas adicionales que se enviarán con la excepción.",
      },
      { name: "contexts", type: "Record<string, Record<string, unknown>>" },
      { name: "fingerprint", type: "string[]" },
    ],
  },
  description: "Datos adicionales opcionales para adjuntar al evento de Sentry.",
},
]}
>
  Captura un evento de mensaje y lo envía a Sentry. Opcionalmente, en lugar de un `CaptureContext`, también puedes pasar un `SeverityLevel` como segundo argumento, por ejemplo `"error"` o `"warning"`.

  Los mensajes aparecen como incidencias en tu flujo de incidencias, con el propio mensaje como nombre de la incidencia.
</SdkApi>

<div id="enriching-events">
  ## Enriquecimiento de eventos
</div>

<SdkApi name="setTag" signature="function setTag(key: string, value: string): void" parameters={[]}>
  Establece una etiqueta que se enviará con los eventos de Sentry.

  * Las claves de las etiquetas tienen una longitud máxima de 32 caracteres y solo pueden contener letras (`a-zA-Z`), números (`0-9`), guiones bajos (`_`), puntos (`.`), dos puntos (`:`) y guiones (`-`).
  * Los valores de las etiquetas tienen una longitud máxima de 200 caracteres y no pueden contener el carácter de salto de línea (`\n`).
</SdkApi>

<SdkApi name="setTags" signature="function setTags(tags: Record<string, string>): void" parameters={[]}>
  Establece varias etiquetas que se enviarán con los eventos de Sentry.
</SdkApi>

<SdkApi name="setContext" signature="function setContext(name: string, context: Record<string, unknown>): void" parameters={[]}>
  Establece un contexto que se enviará con los eventos de Sentry. Los contextos personalizados te permiten adjuntar datos arbitrarios a un evento.
  No puedes buscarlos, pero se pueden ver en la página del issue; si
  necesitas poder filtrar ciertos datos, usa [etiquetas](./#setTag) en su lugar.

  No hay restricciones para el nombre del contexto. En el objeto de contexto, todas las claves están permitidas excepto `type`, que se usa internamente.

  De forma predeterminada, los SDK de Sentry normalizan los datos de contexto estructurados y anidados hasta tres niveles de profundidad.
  Cualquier dato más allá de esta profundidad se truncará y se marcará utilizando su tipo.
  Para ajustar este valor predeterminado, utiliza la opción del SDK <PlatformLink to="/configuration/options#normalize-depth">`normalizeDepth`</PlatformLink>.

  Obtén más información sobre las convenciones para contextos comunes en la [documentación para desarrolladores de la interfaz de contextos](https://develop.sentry.dev/sdk/data-model/event-payloads/contexts/).

  <Expandable title="Example">
    Los datos de contexto están estructurados y pueden contener cualquier dato que quieras:

    ```javascript
    Sentry.setContext("character", {
      name: "Mighty Fighter",
      age: 19,
      attack_type: "melee",
    });
    ```
  </Expandable>
</SdkApi>

<SdkApi name="setExtra" signature="function setExtra(name: string, extra: unknown): void" parameters={[]}>
  Establece datos adicionales que se enviarán con los eventos de Sentry.
</SdkApi>

<SdkApi name="setExtras" signature="function setExtras(extras: Record<string, unknown>): void" parameters={[]}>
  Establece varias entradas de datos adicionales que se enviarán con los eventos de Sentry.
</SdkApi>

<SdkApi
  name="setUser"
  signature="function setUser(user: User | null): void"
  parameters={[
  {
    name: "user",
    type: {
      name: "User",
      properties: [
        {
          name: "id",
          type: "string | number",
          description: "Tu identificador interno para el usuario",
        },
        {
          name: "email",
          type: "string",
          description:
            "Sentry reconoce las direcciones de correo electrónico y puede mostrar elementos como Gravatars y habilitar capacidades de mensajería",
        },
        {
          name: "username",
          type: "string",
          description:
            "Normalmente se usa como una etiqueta más descriptiva que el id interno",
        },
        {
          name: "ip_address",
          type: "string",
          description:
            "La dirección IP del usuario. Si el usuario no está autenticado, Sentry usa la dirección IP como identificador único del usuario",
        },
      ],
    },
  },
]}
>
  Establece un usuario para enviarlo con los eventos de Sentry. Establécelo en `null` para eliminar el usuario. Además de las propiedades especificadas del objeto `User`, también puedes agregar pares clave/valor arbitrarios adicionales.

  <Expandable title="Captura de direcciones IP de usuarios">
    <PlatformCategorySection supported={['server', 'serverless']}>
      En el servidor, la dirección IP se inferirá de la solicitud HTTP entrante, si está disponible.
      Esto se hace automáticamente si has configurado `sendDefaultPii: true` en tu <PlatformLink to="/configuration/options/#sendDefaultPii">configuración del SDK</PlatformLink>.
    </PlatformCategorySection>

    <PlatformCategorySection supported={["browser"]}>
      En el navegador, si la `ip_address` de los usuarios se establece en `"{{ auto }}"`, Sentry
      inferirá la dirección IP de la conexión entre tu aplicación y el servidor de Sentry. `{{auto}}` se establece automáticamente si has configurado `sendDefaultPii:
          true` en tu <PlatformLink to="/configuration/options/#sendDefaultPii">configuración del SDK</PlatformLink>.
    </PlatformCategorySection>

    Para asegurar que las direcciones IP de tus usuarios nunca se almacenen en los datos de tus eventos, puedes ir a la configuración de tu proyecto, hacer clic en &quot;Security &amp; Privacy&quot; y habilitar &quot;Prevent Storing of IP Addresses&quot; o usar la [limpieza de datos del lado del servidor](/es/security-legal-pii/scrubbing/) de Sentry para eliminar `$user.ip_address`. Agregar esta regla anula cualquier otra lógica.
  </Expandable>

  <PlatformCategorySection supported={["server"]}>
    <Expandable title="Establecer el usuario para la solicitud actual">
      <PlatformSection notSupported={['javascript.bun', 'javascript.cloudflare', 'javascript.deno', 'javascript.react-router', 'javascript.aws-lambda', 'javascript.azure-functions', 'javascript.gcp-functions']}>
        `Sentry.setUser()` establecerá el usuario para la solicitud actualmente activa - consulta <PlatformLink to="/enriching-events/request-isolation">Aislamiento de solicitudes</PlatformLink> para más información. Por ejemplo, si quieres establecer el usuario para una sola solicitud, puedes hacerlo de esta manera:
      </PlatformSection>

      <PlatformContent includePath="enriching-events/set-user-request" />

      O si quieres establecer el usuario para todas las solicitudes, podrías usar un middleware como este:

      <PlatformContent includePath="enriching-events/set-user-middleware" />
    </Expandable>
  </PlatformCategorySection>
</SdkApi>

<SdkApi
  name="addBreadcrumb"
  signature="function addBreadcrumb(breadcrumb: Breadcrumb, hint?: Hint): void"
  parameters={[
  {
    name: "breadcrumb",
    required: true,
    type: {
      name: "Breadcrumb",
      properties: [
        {
          name: "message",
          type: "string",
          description:
            "Si se proporciona un mensaje, se muestra como texto conservando todos los espacios en blanco.",
        },
        {
          name: "type",
          type: '"default" | "debug" | "error" | "info" | "navigation" | "http" | "query" | "ui" | "user"',
          defaultValue: '"default"',
          description:
            "El tipo influye en cómo se representa un breadcrumb en Sentry. En caso de duda, déjalo en `default`.",
        },
        {
          name: "level",
          type: '"fatal" | "error" | "warning" | "log" | "info" | "debug"',
          defaultValue: '"info"',
          description:
            "El nivel se usa en la interfaz para resaltar o atenuar el breadcrumb.",
        },
        {
          name: "category",
          type: "string",
          description:
            "Por lo general, es un nombre de módulo o una cadena descriptiva. Por ejemplo, `ui.click` podría usarse para indicar que ocurrió un clic.",
        },
        {
          name: "data",
          type: "Record<string, unknown>",
          description:
            "Datos adicionales que se deben enviar con el breadcrumb.",
        },
      ],
    },
  },
  {
    name: "hint",
    type: "Record<string, unknown>",
    description:
      "Un objeto hint que contiene información adicional sobre el breadcrumb.",
  },
]}
>
  Puedes añadir breadcrumbs manualmente cuando pase algo interesante. Por
  ejemplo, podrías registrar manualmente un breadcrumb si el usuario se autentica o
  se produce otro cambio de estado.
</SdkApi>

<div id="tracing">
  ## Trazas
</div>

<SdkApi
  name="startSpan"
  signature="function startSpan<T>(options: StartSpanOptions, callback: (span: Span) => T): T"
  parameters={[
{
  name: "options",
  required: true,
  type: {
    name: 'StartSpanOptions',
    properties: [
      { name: "name", type: "string", required: true },
      { name: 'attributes', type: 'Record<string, string | number | boolean | null | undefined>', description: 'Atributos para añadir al span.' },
      { name: 'startTime', type: 'number', description: 'La marca de tiempo que se usará para el inicio del span. Si no se proporciona, se usará la hora actual.' },
      { name: 'op', type: 'string', description: 'El nombre de la operación del span. Se usa para agrupar spans en la interfaz.' },
      { name: 'forceTransaction', type: 'boolean', description: 'Si es true, el span se enviará forzosamente como una transacción, incluso si no es el span raíz.' },
      { name: 'parentSpan', type: 'Span | null', description: 'El span padre del nuevo span. Si no se proporciona, se usará el span actual.' },
      { name: 'onlyIfParent', type: 'boolean', description: 'Si es true, el span solo se creará si hay un span activo.' },
    ]
  },
},
{ name: "callback", type: "(span: Span) => T", required: true },
]}
>
  Inicia un nuevo span, activo dentro del callback proporcionado.
  Este span será hijo del span actualmente activo, si existe.

  Cualquier span creado dentro del callback será hijo de este span.

  El span iniciado finalizará automáticamente cuando el callback termine y, por lo tanto, medirá la duración del callback. El callback también puede ser una función async.

  <Expandable title="Ejemplos">
    ```javascript
    // Ejemplo sincrónico
    Sentry.startSpan({ name: 'my-span' }, (span) => {
      measureThis();
    });

    // Ejemplo asincrónico
    const status = await Sentry.startSpan({ name: 'my-span' }, async (span) => {
      const status = await doSomething();
      return status;
    });
    ```
  </Expandable>

  Consulta <PlatformLink to="/tracing/instrumentation/">Tracing Instrumentation</PlatformLink> para más información sobre cómo trabajar con spans.
</SdkApi>

<SdkApi
  name="startInactiveSpan"
  signature="function startInactiveSpan<T>(options: StartSpanOptions): Span"
  parameters={[
{
  name: "options",
  required: true,
  type: {
    name: 'StartSpanOptions',
    properties: [
      { name: "name", type: "string", required: true },
      { name: 'attributes', type: 'Record<string, string | number | boolean | null | undefined>', description: 'Atributos para añadir al span.' },
      { name: 'startTime', type: 'number', description: 'La marca de tiempo que se usará para el inicio del span. Si no se proporciona, se usará la hora actual.' },
      { name: 'op', type: 'string', description: 'El nombre de la operación del span. Se usa para agrupar spans en la interfaz.' },
      { name: 'forceTransaction', type: 'boolean', description: 'Si es true, el span se enviará forzosamente como una transacción, incluso si no es el span raíz.' },
      { name: 'parentSpan', type: 'Span | null', description: 'El span padre del nuevo span. Si no se proporciona, se usará el span actual.' },
      { name: 'onlyIfParent', type: 'boolean', description: 'Si es true, el span solo se creará si hay un span activo.' },
    ]
  },
}
]}
>
  Inicia un nuevo span. Este span será hijo del span actualmente activo, si existe.
  El span devuelto debe finalizarse manualmente con `span.end()` cuando termine.

  <Expandable title="Ejemplos">
    ```javascript
    const span = Sentry.startInactiveSpan({ name: 'my-span' });
    doSomething();
    span.end();
    ```
  </Expandable>

  Consulta <PlatformLink to="/tracing/instrumentation/">Tracing Instrumentation</PlatformLink> para más información sobre cómo trabajar con spans.
</SdkApi>

<SdkApi
  name="startSpanManual"
  signature="function startSpanManual<T>(options: StartSpanOptions, callback: (span: Span) => T): T"
  parameters={[
{
  name: "options",
  required: true,
  type: {
    name: 'StartSpanOptions',
    properties: [
      { name: "name", type: "string", required: true },
      { name: 'attributes', type: 'Record<string, string | number | boolean | null | undefined>', description: 'Atributos que se añadirán al span.' },
      { name: 'startTime', type: 'number', description: 'La marca de tiempo que se usará para el inicio del span. Si no se proporciona, se usará la hora actual.' },
      { name: 'op', type: 'string', description: 'El nombre de la operación del span. Se usa para agrupar spans en la interfaz.' },
      { name: 'forceTransaction', type: 'boolean', description: 'Si es true, el span se enviará forzadamente como una transacción, incluso si no es el span raíz.' },
      { name: 'parentSpan', type: 'Span | null', description: 'El span padre del nuevo span. Si no se proporciona, se usará el span actual.' },
      { name: 'onlyIfParent', type: 'boolean', description: 'Si es true, el span solo se creará si hay un span activo.' },
    ]
  },
},
{ name: "callback", type: "(span: Span) => T", required: true },
]}
>
  Inicia un nuevo span que estará activo dentro del callback proporcionado.
  Este span será hijo del span activo actual, si existe.

  Cualquier span creado dentro del callback será hijo de este span.

  El span iniciado *no* terminará automáticamente: debes llamar a `span.end()` cuando el span haya terminado. Ten en cuenta que el span solo será el padre de los spans creados dentro del callback mientras este esté activo. En la mayoría de los casos, querrás usar `startSpan` o `startInactiveSpan` en su lugar.

  <Expandable title="Ejemplos">
    ```javascript
    const status = await Sentry.startSpanManual({ name: 'my-span' }, async (span) => {
    const status = await doSomething();
    span.end();
    return status;
    });
    ```
  </Expandable>

  Consulta <PlatformLink to="/tracing/instrumentation/">Tracing Instrumentation</PlatformLink> para obtener más información sobre cómo trabajar con spans.
</SdkApi>

<SdkApi name="setActiveSpanInBrowser" signature="function setActiveSpanInBrowser(span: Span): void" availableSince="10.15.0" categorySupported={["browser"]}>
  Establece el span pasado como el span activo en el alcance actual.
  Probablemente no necesites esta funcionalidad y deberías [usar `startSpan`](#startSpan)
  en su lugar.
  Sin embargo, en algunas situaciones, podrías preferir que un span esté activo fuera de un callback.
  En ese caso, la combinación de [`startInactiveSpan`](#startInactiveSpan) con esta función
  te permite iniciar un span, mantener una referencia a él y mantenerlo activo hasta que lo termines, sin que
  la duración activa esté ligada al callback (a diferencia de [`startSpanManual`](#startSpanManual)).

  <Expandable title="Ejemplos">
    ```javascript
    let checkoutSpan;

    on('startCheckout', () => {
      checkoutSpan = Sentry.startInactiveSpan({name: 'checkout-flow'});
      Sentry.setActiveSpanInBrowser(checkoutSpan);
    })

    doSomeWork();

    on('endCheckout', () => {
      // Al finalizar el span, se elimina automáticamente como span activo del alcance
      checkoutSpan.end();
    })
    ```
  </Expandable>

  Consulta <PlatformLink to="/tracing/instrumentation/">Tracing Instrumentation</PlatformLink> para obtener más información sobre cómo trabajar con spans.
</SdkApi>

<SdkApi
  name="continueTrace"
  signature="function continueTrace<T>(options: TraceOptions, callback: () => T): T"
  parameters={[
  {
    name: "options",
    type: {
      name: "TraceOptions",
      properties: [
        {
          name: "sentryTrace",
          type: "string",
          description: "El encabezado sentry-trace.",
        },
        {
          name: "baggage",
          type: "string",
          description: "El encabezado baggage.",
        },
      ],
    },
  },
  {
    name: "callback",
    type: "() => T",
    description: "El callback para continuar el trace.",
  },
]}
>
  Continúa un trace en el callback proporcionado. Cualquier span creado dentro del
  callback quedará vinculado al trace.
</SdkApi>

<SdkApi name="suppressTracing" signature="function suppressTracing<T>(callback: () => T): T">
  Garantiza que todos los spans creados dentro del callback proporcionado no se envíen a
  Sentry.
</SdkApi>

<SdkApi name="startNewTrace" signature="function startNewTrace<T>(callback: () => T): T">
  Inicia un nuevo trace que estará activo en el callback proporcionado.
</SdkApi>

<SdkApi name="startBrowserTracingPageLoadSpan" signature="function startBrowserTracingPageLoadSpan(client: Client, options: StartSpanOptions): Span | undefined" categorySupported={["browser"]}>
  Inicia un span de carga de página que se finalizará automáticamente cuando la página se
  considere inactiva. Si hay un span de carga de página/navegación en curso, se
  finalizará automáticamente primero. En la mayoría de los casos, no necesitas llamar a esto, ya que
  la `browserTracingIntegration` lo hará automáticamente por ti. Sin embargo,
  si decides no usar spans de carga de página, puedes usar este método para iniciar manualmente
  dicho span. Ten en cuenta que esta función no hará nada si
  `browserTracingIntegration` no está habilitada.
</SdkApi>

<SdkApi name="startBrowserTracingNavigationSpan" signature="function startBrowserTracingNavigationSpan(client: Client, options: StartSpanOptions): Span | undefined" categorySupported={["browser"]}>
  Inicia un span de navegación que se finalizará automáticamente cuando la página se
  considere inactiva. Si hay un span de carga de página/navegación en curso, se
  finalizará automáticamente primero. En la mayoría de los casos, no necesitas llamar a esto, ya que
  la `browserTracingIntegration` lo hará automáticamente por ti. Sin embargo,
  si decides no usar spans de navegación, puedes usar este método para iniciar manualmente
  dicho span. Ten en cuenta que esta función no hará nada si
  `browserTracingIntegration` no está habilitada.
</SdkApi>

<SdkApi name="reportPageLoaded" signature="function reportPageLoaded(): void" categorySupported={["browser"]} availableSince="10.13.0">
  Indica al SDK de Sentry que la página inicial se cargó por completo.
  Requiere la opción <PlatformLink to="/tracing/instrumentation/automatic-instrumentation/#enableReportPageLoaded">`enableReportPageLoaded`</PlatformLink> en `browserTracingIntegration`
  configurada en `true`. Una vez que se ejecuta, el SDK finaliza automáticamente el span de carga de página.

  De forma predeterminada, el SDK se encarga de finalizar automáticamente el span de carga de página, basándose en
  un período de inactividad en el que no se agregan nuevos spans secundarios al trace de carga de página.
  Alternativamente, puedes usar el reporte explícito de carga de página si las heurísticas de inactividad de
  `browserTracingIntegration` no funcionan bien para tu caso de uso.
  Sin embargo, debes asegurarte de llamar a `reportPageLoaded` en todas las situaciones.
  Si no se llama a `reportPageLoaded`, el span de carga de página se finalizará después de 30 segundos
  o el valor personalizado que se haya establecido en la opción <PlatformLink to="/tracing/instrumentation/automatic-instrumentation/#enableReportPageLoaded">`finalTimeout`</PlatformLink>.

  <Expandable title="Ejemplos">
    ```javascript
    Sentry.init({
      // 1. Habilita el reporte manual de carga de página:
      integrations: [browserTracingIntegration({ enableReportPageLoaded: true })]
    })

    // 2. Cuando consideres que la página está cargada:
    Sentry.reportPageLoaded();
    ```
  </Expandable>
</SdkApi>

<div id="tracing-utilities">
  ## Utilidades de trazado
</div>

Estas utilidades pueden usarse para casos de uso de trazado más avanzados.

<SdkApi name="spanToJSON" signature="function spanToJSON(span: Span): SpanJSON">
  Convierte un span en un objeto JSON.
</SdkApi>

<SdkApi name="updateSpanName" signature="function updateSpanName(span: Span, name: string): void">
  Actualiza el nombre de un span. Usa esto en lugar de `span.updateName(name)` para asegurarte
  de que el span se actualice en todos los backends.
</SdkApi>

<SdkApi name="setHttpStatus" signature="function setHttpStatus(span: Span, httpStatus: number): void">
  Establece el estado de un span según el código de estado HTTP indicado.
</SdkApi>

<SdkApi name="getActiveSpan" signature="function getActiveSpan(): Span | undefined">
  Obtén el span activo actualmente.
</SdkApi>

<SdkApi name="getRootSpan" signature="function getRootSpan(span: Span): Span">
  Obtén el span raíz de un span.
</SdkApi>

<SdkApi name="withActiveSpan" signature="function withActiveSpan<T>(span: Span | null, callback: () => T): T">
  Ejecuta el callback proporcionado con el span dado como span activo. Si se proporciona `null`,
  el callback no tendrá ningún span activo.
</SdkApi>

<div id="sessions">
  ## Sesiones
</div>

Las sesiones te permiten hacer un seguimiento de la salud de la versión de tu aplicación.
Consulta la página <PlatformLink to="/configuration/releases/#sessions">Releases y salud</PlatformLink> para más información.

<SdkApi name="startSession" signature="function startSession(): void">
  Inicia una nueva sesión.
</SdkApi>

<SdkApi name="endSession" signature="function endSession(): void">
  Finaliza la sesión actual (pero no la envía a Sentry).
</SdkApi>

<SdkApi name="captureSession" signature="function captureSession(end = false): void">
  Envía la sesión actual del scope a Sentry. Pasa `true` como argumento para
  finalizar primero la sesión.
</SdkApi>

<div id="scopes">
  ## Ámbitos
</div>

Consulta <PlatformLink to="/enriching-events/scopes/">Ámbitos</PlatformLink> para obtener más información sobre cómo usar los ámbitos y una explicación de los distintos tipos (ámbito actual, ámbito de aislamiento y ámbito global).

<SdkApi name="withScope" signature="function withScope(callback: (scope: Scope) => void): void">
  Crea un fork del ámbito actual y llama al callback con ese ámbito bifurcado.
</SdkApi>

<SdkApi name="withIsolationScope" signature="function withIsolationScope(callback: (scope: Scope) => void): void">
  Crea un fork del ámbito de aislamiento actual y llama al callback con ese
  ámbito bifurcado.
</SdkApi>

<SdkApi name="getCurrentScope" signature="function getCurrentScope(): Scope">
  Devuelve el <PlatformLink to="/enriching-events/scopes/#current-scope">ámbito actual</PlatformLink>.

  Ten en cuenta que, en la mayoría de los casos, no deberías usar esta API, sino `withScope` para generar y acceder a un ámbito local. No se garantiza la coherencia de `getCurrentScope` en las distintas partes de tu aplicación, ya que la bifurcación de ámbitos puede producirse internamente en varios puntos.
</SdkApi>

<SdkApi name="getIsolationScope" signature="function getIsolationScope(): Scope">
  Devuelve el{" "}

  <PlatformLink to="/enriching-events/scopes/#isolation-scope">
    ámbito de aislamiento
  </PlatformLink>

  .
</SdkApi>

<SdkApi name="getGlobalScope" signature="function getGlobalScope(): Scope">
  Devuelve el{" "}

  <PlatformLink to="/enriching-events/scopes/#global-scope">
    ámbito global
  </PlatformLink>

  .
</SdkApi>

<div id="user-feedback">
  ## Comentarios de usuarios
</div>

<SdkApi
  name="captureFeedback"
  signature="function captureFeedback(feedback: Feedback, hint?: Hint): string"
  parameters={[
  {
    name: "feedback",
    type: {
      name: "Feedback",
      properties: [
        { name: "message", type: "string", required: true },
        { name: "name", type: "string" },
        { name: "email", type: "string" },
        { name: "url", type: "string" },
        { name: "source", type: "string" },
        {
          name: "associatedEventId",
          type: "string",
          description: "El ID del evento con el que está asociado este feedback.",
        },
        { name: "tags", type: "Record<string, string>" },
      ],
    },
    description: "El feedback que se capturará.",
  },
  {
    name: "hint",
    type: {
      name: "Hint",
      properties: [
        {
          name: "captureContext",
          type: {
            name: "CaptureContext",
            properties: [
              {
                name: "user",
                type: {
                  name: "User",
                  properties: [
                    { name: "id", type: "string | number" },
                    { name: "email", type: "string" },
                    { name: "ip_address", type: "string" },
                    { name: "username", type: "string" },
                  ],
                },
              },
              {
                name: "level",
                type: '"fatal" | "error" | "warning" | "log" | "info" | "debug"',
              },
              {
                name: "extra",
                type: "Record<string, unknown>",
                description:
                  "Datos adicionales que deben enviarse con la excepción.",
              },
              {
                name: "tags",
                type: "Record<string, string>",
                description:
                  "Etiquetas adicionales que deben enviarse con la excepción.",
              },
              {
                name: "contexts",
                type: "Record<string, Record<string, unknown>>",
              },
              { name: "fingerprint", type: "string[]" },
            ],
          },
          description:
            "Datos adicionales opcionales para adjuntar al evento de Sentry.",
        },
      ],
    },
    description:
      "Objeto hint opcional que contiene información adicional sobre el feedback.",
  },
]}
>
  Envía feedback de usuarios a Sentry.
</SdkApi>

<SdkApi name="getFeedback" signature="function getFeedback(): ReturnType<feedbackIntegration> | undefined">
  Obtén la integración de feedback, si se ha añadido. Esto puede usarse para acceder
  a la integración de feedback de forma segura con tipos.
</SdkApi>

<SdkApi
  name="sendFeedback"
  signature="function sendFeedback(feedback: Feedback, hint?: Hint): Promise<string>"
  parameters={[
  {
    name: "feedback",
    type: {
      name: "Feedback",
      properties: [
        { name: "message", type: "string", required: true },
        { name: "name", type: "string" },
        { name: "email", type: "string" },
        { name: "url", type: "string" },
        { name: "source", type: "string" },
        {
          name: "associatedEventId",
          type: "string",
          description: "El ID del evento al que está asociado este feedback.",
        },
        { name: "tags", type: "Record<string, string>" },
      ],
    },
    description: "El feedback que se va a capturar.",
  },
  {
    name: "hint",
    type: {
      name: "Hint",
      properties: [
        {
          name: "captureContext",
          type: {
            name: "CaptureContext",
            properties: [
              {
                name: "user",
                type: {
                  name: "User",
                  properties: [
                    { name: "id", type: "string | number" },
                    { name: "email", type: "string" },
                    { name: "ip_address", type: "string" },
                    { name: "username", type: "string" },
                  ],
                },
              },
              {
                name: "level",
                type: '"fatal" | "error" | "warning" | "log" | "info" | "debug"',
              },
              {
                name: "extra",
                type: "Record<string, unknown>",
                description:
                  "Datos adicionales que deben enviarse con la excepción.",
              },
              {
                name: "tags",
                type: "Record<string, string>",
                description:
                  "Etiquetas adicionales que deben enviarse con la excepción.",
              },
              {
                name: "contexts",
                type: "Record<string, Record<string, unknown>>",
              },
              { name: "fingerprint", type: "string[]" },
            ],
          },
          description:
            "Datos adicionales opcionales para adjuntar al evento de Sentry.",
        },
      ],
    },
    description:
      "Objeto hint opcional que contiene información adicional sobre el feedback.",
  },
]}
>
  Este método es similar a [`captureFeedback`](#capturefeedback), pero
  devuelve una promesa que se resuelve solo cuando el feedback se ha enviado
  correctamente a Sentry. Se rechazará si no se puede enviar el feedback.
</SdkApi>

<PlatformCategorySection supported={['server']}>
  ## Monitoreo de cron

  <SdkApi
    name="captureCheckIn"
    signature="function captureCheckIn(checkIn: CheckIn, monitorConfig?: MonitorConfig): string"
    categorySupported={["server"]}
    parameters={[
  {
    name: "checkIn",
    type: {
      name: "CheckIn",
      properties: [
        {
          name: "status",
          type: '"ok" | "error" | "in_progress"',
          required: true,
        },
        { name: "monitorSlug", type: "string", required: true },
        { name: "checkInId", type: "string" },
        { name: "duration", type: "number" },
      ],
    },
    required: true,
  },
  {
    name: "monitorConfig",
    type: {
      name: "MonitorConfig",
      properties: [
        {
          name: "schedule",
          type: '{ type: "crontab", value: string } | { type: "interval", value: number, unit: "year" | "month" | "day" | "hour" | "minute" }',
          required: true,
        },
        { name: "checkinMargin", type: "number" },
        { name: "maxRuntime", type: "number" },
        { name: "timezone", type: "string" },
        { name: "failureIssueThreshold", type: "number" },
        { name: "recoveryThreshold", type: "number" },
      ],
    },
  },
]}
  >
    Crea un registro de monitor de cron y envíalo a Sentry.
  </SdkApi>

  <SdkApi
    name="withMonitor"
    signature={`function withMonitor(
monitorSlug: string,
callback: () => any,
monitorConfig?: MonitorConfig
): string`}
    categorySupported={['server']}
    parameters={[
{
name: "monitorSlug",
type: 'string',
required: true,
},
{
name: "callback",
type: '() => any',
required: true,
},
{
name: "monitorConfig",
type: {
  name: "MonitorConfig",
  properties: [
    {
      name: "schedule",
      type: '{ type: "crontab", value: string } | { type: "interval", value: number, unit: "year" | "month" | "day" | "hour" | "minute" }',
      required: true,
    },
    { name: "checkinMargin", type: "number" },
    { name: "maxRuntime", type: "number" },
    { name: "timezone", type: "string" },
    { name: "failureIssueThreshold", type: "number" },
    { name: "recoveryThreshold", type: "number" },
  ],
},
},
]}
  >
    Envuelve un callback con un registro de monitor de cron. El registro se enviará a Sentry cuando el callback finalice.
  </SdkApi>
</PlatformCategorySection>

<PlatformSection supported={["javascript.sveltekit"]}>
  ## Instrumentación de funciones load

  Las funciones `load` universales y de servidor de SvelteKit se instrumentan automáticamente de forma predeterminada. Si no quieres usar la autoinstrumentación de `load`, puedes [desactivarla](/es/platforms/javascript/guides/sveltekit/configuration/build/#auto-instrumentation-options) e instrumentar manualmente funciones `load` específicas usando los siguientes envoltorios de función:

  <SdkApi
    name="wrapLoadWithSentry"
    signature={`function wrapLoadWithSentry<T extends (...args: any) => any>(
originalLoad: T
): T`}
  >
    Envuelve una función `load` de SvelteKit declarada en `+page.(js|ts)` o `+layout.(js|ts)` con el monitoreo de errores y rendimiento de Sentry.

    <Expandable title="Ejemplos">
      ```javascript
      import { wrapLoadWithSentry } from "@sentry/sveltekit";

      export const load = wrapLoadWithSentry(({ fetch }) => {
          const res = await fetch("/api/data");
          const data = await res.json();
          return { data };
      });
      ```
    </Expandable>
  </SdkApi>

  <SdkApi
    name="wrapServerLoadWithSentry"
    signature={`function wrapServerLoadWithSentry<T extends (...args: any) => any>(
originalServerLoad: T
): T`}
  >
    Envuelve una función `load` solo de servidor de SvelteKit declarada en `+page.server.(js|ts)` o `+layout.server.(js|ts)` con el monitoreo de errores y rendimiento de Sentry.

    <Expandable title="Ejemplos">
      ```javascript
      import { wrapServerLoadWithSentry } from "@sentry/sveltekit";

      export const load = wrapServerLoadWithSentry(({ fetch }) => {
        const res = await fetch("/api/data");
        const data = await res.json();
        return { data };
      });
      ```
    </Expandable>
  </SdkApi>

  ## Instrumentación de rutas de servidor

  <SdkApi
    name="wrapServerRouteWithSentry"
    signature={`function wrapServerRouteWithSentry<T extends RequestEvent>(
originalRouteHandler: (request: T) => Promise<Response>
): (requestEvent: T) => Promise<Response>`}
  >
    Envuelve un [controlador de ruta de servidor](https://kit.svelte.dev/docs/routing#server) de SvelteKit registrado en `+server.(js|ts)` con el monitoreo de errores y rendimiento de Sentry. Esto es útil si tienes rutas de servidor personalizadas que quieres trazar o si quieres capturar invocaciones a `error()` dentro de tus rutas de servidor.

    <Expandable title="Ejemplos">
      ```javascript
      import { wrapServerRouteWithSentry } from "@sentry/sveltekit";

      export const GET = wrapServerRouteWithSentry(async () => {
        // lógica de tu endpoint
        return new Response("Hello World");
      });
      ```
    </Expandable>
  </SdkApi>
</PlatformSection>

<PlatformSection supported={["javascript.nextjs"]}>
  ## Server Actions

  <SdkApi
    name="withServerActionInstrumentation"
    signature={`function withServerActionInstrumentation(
serverActionName: string,
options?: Options,
callback: A
): Promise<ReturnType<A>>`}
  >
    Para instrumentar las Server Actions de Next.js, envuelve su contenido con `withServerActionInstrumentation` y asigna un nombre que describa tu Server Action.
    Opcionalmente puedes pasar datos de formulario y encabezados para registrarlos, y configurar el wrapper para registrar las respuestas de la Server Action.

    <Expandable title="Examples">
      ```tsx
      import * as Sentry from "@sentry/nextjs";
      import { headers } from "next/headers";

      export default function ServerComponent() {
          async function myServerAction(formData: FormData) {
              "use server";
              return await Sentry.withServerActionInstrumentation(
              "myServerAction", // El nombre con el que quieres asociar esta Server Action en Sentry
              {
                  formData, // Opcionalmente pasa los datos del formulario
                  headers: await headers(), // Opcionalmente pasa los encabezados
                  recordResponse: true, // Opcionalmente registra la respuesta de la Server Action
              },
              async () => {
                  // ... Tu código de Server Action

                  return { name: "John Doe" };
              }
              );
          }

          return (
              <form action={myServerAction}>
              <input type="text" name="some-input-value" />
              <button type="submit">Run Action</button>
              </form>
          );
      }
      ```
    </Expandable>
  </SdkApi>

  ## Instrumentación de rutas y obtención de datos

  <SdkApi
    name="wrapApiHandlerWithSentry"
    signature={`function wrapApiHandlerWithSentry(
apiHandler: NextApiHandler,
parameterizedRoute: string
): NextApiHandler`}
  >
    Instrumenta el controlador de ruta de API proporcionado con Sentry para
    monitoreo de errores y rendimiento. Esta función envuelve el controlador
    exportado desde el archivo de la ruta de la página de API del usuario (que
    puede o no estar ya envuelto con `withSentry`).
  </SdkApi>

  <SdkApi
    name="wrapGetInitialPropsWithSentry "
    signature={`function wrapGetInitialPropsWithSentry(
origGetInitialProps: GetInitialProps
): GetInitialProps`}
  >
    Instrumenta una función `getInitialProps` con el monitoreo de errores y
    rendimiento de Sentry creando y devolviendo una versión envuelta de la
    función.
  </SdkApi>

  <SdkApi
    name="wrapGetServerSidePropsWithSentry "
    signature={`function wrapGetServerSidePropsWithSentry(
origGetInitialProps: GetInitialProps,
parameterizedRoute: string
): GetServerSideProps`}
  >
    Instrumenta una función `getServerSideProps` con el monitoreo de errores y
    rendimiento de Sentry creando y devolviendo una versión envuelta de la
    función.
  </SdkApi>

  <SdkApi
    name="wrapGetStaticPropsWithSentry "
    signature={`function wrapGetStaticPropsWithSentry(
origGetStaticPropsa: GetStaticProps<Props>,
_parameterizedRoute: string
): GetStaticProps<Props>`}
  >
    Instrumenta una función `getStaticProps` con el monitoreo de errores y
    rendimiento de Sentry creando y devolviendo una versión envuelta de la
    función.
  </SdkApi>

  <SdkApi
    name="wrapErrorGetInitialPropsWithSentry "
    signature={`function wrapErrorGetInitialPropsWithSentry(
origErrorGetInitialProps: ErrorGetInitialProps
): ErrorGetInitialProps`}
  >
    Instrumenta una función `getInitialProps` en una página de error personalizada (`_error.js`)
    con el monitoreo de errores y rendimiento de Sentry, creando y devolviendo una
    versión envuelta de la función.
  </SdkApi>

  <SdkApi
    name="wrapAppGetInitialPropsWithSentry "
    signature={`function wrapAppGetInitialPropsWithSentry(
origAppGetInitialProps: AppGetInitialProps
): AppGetInitialProps`}
  >
    Instrumenta una función `getInitialProps` en una app personalizada (`_app.js`) con
    el monitoreo de errores y rendimiento de Sentry, creando y devolviendo una
    versión envuelta de la función.
  </SdkApi>

  <SdkApi
    name="wrapDocumentGetInitialPropsWithSentry "
    signature={`function wrapDocumentGetInitialPropsWithSentry(
origDocumentGetInitialProps: DocumentGetInitialProps
): DocumentGetInitialProps`}
  >
    Instrumenta una función `getInitialProps` en un documento personalizado (`_document.js`)
    con el monitoreo de errores y rendimiento de Sentry, creando y devolviendo una
    versión envuelta de la función.
  </SdkApi>
</PlatformSection>
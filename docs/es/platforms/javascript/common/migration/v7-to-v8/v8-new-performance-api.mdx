---
title: Nuevas APIs de Tracing
sidebar_order: 8920
description: "Conoce las nuevas APIs de Tracing en Sentry JavaScript SDK 8.x"
notSupported:
  - javascript.capacitor
  - javascript.cordova
  - javascript.electron
---

La versión `8.x` del SDK introduce nuevas APIs para el monitoreo del rendimiento. Estas APIs están diseñadas para ofrecer más control sobre cómo se recopilan y se envían los datos de rendimiento a Sentry.

Estas APIs también están disponibles en `7.x`, por lo que puedes migrar gradualmente a las nuevas APIs antes de actualizar a `8.x`.

Antes, había dos APIs clave para añadir instrumentación manual de rendimiento a tus aplicaciones:

* `startTransaction()`
* `span.startChild()`

Estas APIs se basaban en el modelo de datos original de Sentry. Ese modelo partía de una transacción raíz que podía contener un árbol anidado de spans.

En el nuevo modelo, las transacciones desaparecen a nivel conceptual. Ahora, las operaciones siempre se realizan sobre spans, sin importar su posición en el árbol. Ten en cuenta que los spans aún pueden agruparse en una transacción para la interfaz de Sentry. Sin embargo, esto ocurre en segundo plano y, desde el punto de vista del SDK, solo necesitas ocuparte de los spans.

El nuevo modelo no diferencia entre una transacción o un span al iniciarlos o finalizarlos manualmente. En su lugar, siempre usas las mismas APIs para iniciar un nuevo span. Esto creará automáticamente un nuevo Root Span (un span normal sin padre, conceptualmente similar a una transacción) o un Child Span, según cuál sea el span activo en ese momento.

Hay tres APIs clave disponibles para iniciar spans:

* `startSpan()`
* `startSpanManual()`
* `startInactiveSpan()`

Las tres APIs de spans aceptan `StartSpanOptions` como primer argumento, con la siguiente estructura:

```TypeScript
interface StartSpanOptions {
  // El único campo obligatorio - el nombre del span
  name: string;
  attributes?: SpanAttributes;
  op?: string;
  scope?: Scope;
  forceTransaction?: boolean;
}
```


<div id="startspan">
  ### `startSpan()`
</div>

Esta es la API más común y debería usarse en la mayoría de los casos. Inicia un nuevo span, lo establece como span activo
durante la ejecución de un callback dado y lo finaliza automáticamente cuando el callback termina. Puedes usarla así:

```js
Sentry.startSpan(
  {
    name: "my-span",
    attributes: {
      attr1: "my-attribute",
      attr2: 123,
    },
  },
  (span) => {
    // haz algo que quieras medir
    // cuando esto termine, el span se finalizará automáticamente
  }
);
```

También puedes pasar una función asíncrona:

```js
Sentry.startSpan(
  {
    name: "my-span",
    attributes: {},
  },
  async (span) => {
    // haz algo que quieras medir
    await waitOnSomething();
    // una vez que esto termine, el span finaliza automáticamente
  }
);
```

Dado que `startSpan()` convierte el span creado en el span activo, cualquier instrumentación automática o manual que cree
spans dentro del callback adjuntará nuevos spans como hijos del span que acabamos de iniciar.

Ten en cuenta que, si se lanza un error dentro del callback, el estado del span se establecerá automáticamente como con error.


<div id="startspanmanual">
  ### `startSpanManual()`
</div>

Es una variación de `startSpan()` cuya única diferencia es que no finaliza automáticamente el span cuando termina el callback. Al usarla, debes llamar a `span.end()` manualmente:

```js
Sentry.startSpanManual(
  {
    name: "my-span",
  },
  (span) => {
    // haz algo que quieras medir

    // Ahora finalizamos el span manualmente nosotros mismos
    span.end();
  }
);
```

En la mayoría de los casos, `startSpan()` será todo lo que necesites para la instrumentación manual. Pero si te encuentras en una situación
en la que el cierre automático de los spans, por cualquier motivo, no te funciona, puedes usar `startSpanManual()`
en su lugar.

Esta función *también* establecerá el span creado como el span activo durante el callback, y *también*
actualizará el estado del span a “errored” si se lanza un error dentro del callback.


<div id="startinactivespan">
  ### `startInactiveSpan()`
</div>

A diferencia de los otros dos métodos, este no recibe un callback y no convierte en activo el span creado.
Puedes usar este método si quieres crear spans independientes que no necesiten tener hijos:

```js
Sentry.startSpan({ name: "outer" }, () => {
  const inner1 = Sentry.startInactiveSpan({ name: "inner1" });
  const inner2 = Sentry.startInactiveSpan({ name: "inner2" });

  // hacer algo

  // finalizar los spans manualmente
  inner1.end();
  inner2.end();
});
```

Nunca se creará un span como hijo de un span inactivo.


<div id="creating-a-child-span-of-a-specific-span">
  ### Crear un span hijo de un span específico
</div>

Puedes usar el helper `withActiveSpan` para crear un span como hijo de un span específico:

```js
Sentry.withActiveSpan(parentSpan, () => {
  Sentry.startSpan({ name: "my-span" }, (span) => {
    // el span será un hijo directo de parentSpan
  });
});
```


<div id="creating-a-transaction">
  ### Creación de una transacción
</div>

Aunque en la mayoría de los casos no deberías preocuparte por crear un span o una transacción (simplemente llama a `startSpan()` y nosotros haremos lo apropiado tras bambalinas), puede haber ocasiones en las que *necesites* asegurarte de crear una transacción (por ejemplo, si necesitas verla como transacción en la interfaz de Sentry). Para estos casos, puedes pasar `forceTransaction: true` a las APIs de inicio de span, por ejemplo:

```js
const transaction = Sentry.startInactiveSpan({
  name: "transaction",
  forceTransaction: true,
});
```


<div id="the-span-schema">
  ## El esquema de Span
</div>

Antes, los spans y las transacciones tenían muchas propiedades y métodos disponibles. La mayoría se han eliminado en favor de una API más ligera y directa, alineada también con los Spans de OpenTelemetry. Puedes consultar la siguiente tabla para ver qué existía antes y cómo puede/debe mapearse de ahora en adelante:

El SDK exporta `spanToJSON`, `getRootSpan`, `setHttpStatus`, `spanToTraceHeader` y `spanToTraceContext` para su uso.

| Nombre anterior            | Sustituir por                                               |
| -------------------------- | ----------------------------------------------------------- |
| `span.traceId`             | `span.spanContext().traceId`                                |
| `span.spanId`              | `span.spanContext().spanId`                                 |
| `span.parentSpanId`        | `spanToJSON(span).parent_span_id`                           |
| `span.status`              | `spanToJSON(span).status`                                   |
| `span.sampled`             | `spanIsSampled(span)`                                       |
| `span.startTimestamp`      | `span.startTime` - ten en cuenta que tiene un formato distinto |
| `span.tags`                | usa attributes, o define tags en el scope                   |
| `span.data`                | `spanToJSON(span).data`                                     |
| `span.transaction`         | `getRootSpan(span)`                                         |
| `span.instrumenter`        | Eliminado                                                   |
| `span.finish()`            | `span.end()`                                                |
| `span.end()`               | Igual                                                       |
| `span.setTag()`            | `span.setAttribute()`, o define tags en el scope            |
| `span.setData()`           | `span.setAttribute()`                                       |
| `span.setStatus()`         | `span.setStatus` - ten en cuenta que tiene una firma distinta |
| `span.setHttpStatus()`     | `setHttpStatus(span, status)`                               |
| `span.setName()`           | `span.updateName()`                                         |
| `span.startChild()`        | Llama a `Sentry.startSpan()` de forma independiente         |
| `span.isSuccess()`         | `spanToJSON(span).status === 'ok'`                          |
| `span.toTraceparent()`     | `spanToTraceHeader(span)`                                   |
| `span.toContext()`         | Eliminado                                                   |
| `span.updateWithContext()` | Eliminado                                                   |
| `span.getTraceContext()`   | `spanToTraceContext(span)`                                  |

Además, una transacción tiene esta API:

| Nombre anterior             | Sustituir por                                   |
| --------------------------- | ------------------------------------------------ |
| `name`                      | `spanToJSON(span).description`                   |
| `trimEnd`                   | Eliminado                                        |
| `parentSampled`             | `spanIsSampled(span)` & `spanContext().isRemote` |
| `metadata`                  | Usa attributes en su lugar o configúralo en el scope |
| `setContext()`              | Configura el contexto en el scope en su lugar    |
| `setMeasurement()`          | `Sentry.setMeasurement()`                        |
| `setMetadata()`             | Usa attributes en su lugar o configúralo en el scope |
| `getDynamicSamplingContext` | `getDynamicSamplingContextFromSpan(span)`        |

<div id="attributes-vs-data-vs-tags-vs-context">
  ### Atributos vs. Datos vs. Etiquetas vs. Contexto
</div>

Anteriormente, el modelo tenía los conceptos de **Datos**, **Etiquetas** y **Contexto**, que podían usarse para distintas cosas. Sin embargo, esto tenía dos desventajas principales: primero, no siempre estaba claro qué concepto usar en una situación determinada; segundo, estos conceptos no se mostraban de la misma manera en transacciones o spans.

Para resolver estos problemas, el nuevo modelo solo tiene **Atributos** que pueden establecerse en spans. De forma general, se corresponden con lo que antes se conocía como Datos.

Si de verdad aún *necesitas* establecer etiquetas o contexto, puedes hacerlo en el scope antes de iniciar un span:

```JavaScript
Sentry.withScope((scope) => {
  scope.setTag("my-tag", "tag-value");
  Sentry.startSpan({ name: "my-span" }, (span) => {
    // haz algo aquí
    // el span heredará las etiquetas del scope contenedor
  });
});
```


<div id="other-notable-changes">
  ## Otros cambios destacados
</div>

Además de los cambios generales en las API de rendimiento, esto también trae consigo algunos cambios menores.

<div id="changed-samplingcontext-for-tracessampler">
  ### Se cambió `SamplingContext` para `tracesSampler()`
</div>

Actualmente, `tracesSampler()` puede recibir un `SamplingContext` arbitrario como argumento. Aunque esto no está definido con detalle en ningún lugar, la estructura de este contexto cambiará en la v8. En adelante, recibirá principalmente los atributos del span, así como otros datos relevantes del span. Algunas propiedades que antes (a veces) pasábamos ahí, como `req` para los SDK basados en Node o `location` para el rastreo en el navegador, ya no se enviarán.

<div id="no-more-undefined-spans">
  ### Se acabaron los spans `undefined`
</div>

En v7, las APIs de rendimiento `startSpan()` / `startInactiveSpan()` / `startSpanManual()` recibían un span `undefined`
si el tracing estaba desactivado o el span no se muestreaba.

En v8, en línea con OpenTelemetry, estas *siempre* devolverán un span, *pero* el span puede ser un Noop-Span, es decir,
un span que nunca se envía. Esto significa que ya no tienes que añadir comprobaciones por todo tu código para verificar que el span exista:

```TypeScript
Sentry.startSpan((span: Span | undefined) => {
  // antes, para mantener la seguridad de tipos, tenías que usar encadenamiento opcional o similar
  span?.setAttribute("attr", 1);
});

// En la v8, la firma cambia a:
Sentry.startSpan((span: Span) => {
  // ¡ya no hace falta protegerlo!
  span.setAttribute("attr", 1);
});
```


<div id="forcing-a-sampling-decision">
  ### Forzar una decisión de muestreo
</div>

En la v7, podías forzar una decisión de muestreo positiva o negativa al llamar a `startTransaction` estableciendo la opción `sampled`.
Esto básicamente reemplazaba tu <PlatformLink to="/configuration/sampling">configuración de muestreo</PlatformLink> para esa transacción específica.
En la v8, la opción `sampled` se eliminó para alinearse con OpenTelemetry. Aun así, puedes forzar una decisión definiendo un
callback `tracesSampler` en `Sentry.init` y devolviendo `1` o `0` para spans específicos:

```JavaScript
// v7
Sentry.startTransition({op: 'function.myFunction', sampled: true});

// v8
// 1. definir un tracesSampler
Sentry.init({
  tracesSampler: (samplingContext) => {
    // forzar una decisión de muestreo positiva para un span específico
    if (samplingContext.op === 'function.myFunction') {
      return 1;
    }
    // forzar una decisión de muestreo negativa para un span específico
    if (samplingContext.op === 'function.healthCheck') {
      return 0;
    }
    // devolver 0.1 como tasa de muestreo predeterminada para todos los demás spans
    return 0.1;
  }
});

// 2. iniciar el span
Sentry.startSpan({op: 'function.myFunction'}, {/*...*/});
```

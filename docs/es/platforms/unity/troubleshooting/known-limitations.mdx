---
title: Limitaciones conocidas
sidebar_order: 9000
description: "Más información sobre las limitaciones conocidas del SDK de Unity."
og_image: /og-images/platforms-unity-troubleshooting-known-limitations.png
---

<div id="file-system-access-permissions">
  ## Permisos de acceso al sistema de archivos
</div>

![Una ventana emergente solicitando permisos para leer la carpeta `Downloads`](./img/unity-file-system-access-permissions.png)

A partir de macOS Mojave (10.14), directorios como `Desktop`, `Documents` y `Downloads` se consideran ubicaciones sensibles a la privacidad y están protegidos por el sandbox de seguridad del sistema operativo. Al ejecutar una aplicación de Unity desde una de estas ubicaciones, los usuarios pueden encontrarse con una ventana emergente solicitando acceso. Esto ocurre porque el `HttpMessageHandler` predeterminado de .NET intenta resolver nombres de dominio, lo que requiere acceso al sistema de archivos. Ten en cuenta que denegar el acceso a estas ubicaciones no impide que el SDK informe errores.

<div id="stack-traces">
  ## Rastros de pila
</div>

<div id="line-numbers-missing-on-button-click-events">
  ### Faltan números de línea en eventos de clic de Button
</div>

Actualmente, los números de línea no aparecen al suscribirse de forma programática a eventos de clic mediante `Button.onClick.AddListener`. Sin embargo, puedes configurar callbacks desde el editor para evitar esto.

<div id="line-numbers-missing-in-events-captured-through-debuglogerror-or-sentrysdkcapturemessage">
  ### Falta de números de línea en eventos capturados mediante `Debug.LogError` o `SentrySdk.CaptureMessage`
</div>

El SDK actualmente está limitado a resolver números de línea de IL2CPP al capturar errores. El SDK depende de que haya una excepción disponible para extraer el rastro de pila. Esto significa que o bien una excepción no controlada debe ser capturada automáticamente por el SDK, o se debe llamar manualmente a `SentrySdk.CaptureException`.

Al registrar un error con `Debug.LogError`, la integración de registro lo captura como un mensaje.

<div id="line-numbers-missing-in-events-captured-through-debuglogexception">
  ### Faltan números de línea en los eventos capturados mediante `Debug.LogException`
</div>

La excepción que Unity proporciona y que captura la integración de registro no incluye un rastreo de pila. Usa `SentrySdk.CaptureException` en su lugar.

<div id="events-captured-through-debuglogexception-are-marked-as-unhandled">
  ### Los eventos capturados mediante `Debug.LogException` se marcan como `Unhandled`
</div>

Actualmente, el SDK no puede distinguir entre cuando el usuario llama a `Debug.LogException` y cuando el SDK captura una excepción no controlada. Para capturar una excepción y marcarla como controlada, puedes usar `SentrySDK.CaptureException` en su lugar.

<div id="line-numbers-missing-when-building-with-mono">
  ### Falta de números de línea al compilar con Mono
</div>

Al compilar con Mono, asegúrate de establecer `ManagedStrippingLevel` en `None`. De lo contrario, Unity eliminará la información de depuración del ensamblado, lo que impedirá que el SDK recupere el ID de depuración que permite vincular el ensamblado con los símbolos de depuración correctos para la simbolización.

<div id="c-as-part-of-the-stack-trace">
  ### C++ como parte del rastro de pila
</div>

Tus rastros de pila pueden contener fotogramas de C++. Esto puede deberse a:

- El código C++ generado no incluye la anotación `<source_info>` para remitir al código C# del que se generó. Esto puede ocurrir por optimizaciones o porque el compilador IL2CPP genera código para manejar características específicas de C#.
- La excepción de C++ puede devolver un número de línea incorrecto, lo que hace que Sentry pase por alto la anotación `<source_info>`. Puedes probar a habilitar la carga de tu código fuente en las opciones de símbolos de depuración para revisar el código C++ generado.

![Un evento de Sentry con un rastro de pila mixto](./img/unity-cpp-stacktrace.jpg)

Por eso también puedes acabar con números de línea muy altos (de varios miles) aunque tu script de C# sea muy pequeño; los números de línea se corresponden con el código C++ generado.

<div id="stack-traces-contain-frames-with-n__0-c-or-c__displayclass">
  ### Las trazas de pila contienen fotogramas con `<>n__0`, `<>c` o `<>c__DisplayClass`
</div>

Al ver trazas de pila en Sentry, puedes encontrarte nombres de clases y métodos generados por el compilador con patrones como `<>c`, `<>c__DisplayClass#_#`, `<>n__0` o `{ <lambda> }`. Estos los crea el compilador de C# cuando usas:

* **Expresiones lambda**: Funciones anónimas como `items.Where(x => x.IsActive)`
* **Delegados**: Definiciones de delegados en línea como `Action`, `Func`
* **Expresiones LINQ**: Sintaxis de consulta y encadenamiento de métodos
* **Async/await**: Métodos de máquina de estados para operaciones asincrónicas (puede aparecer `MoveNext`)
* **Métodos iteradores**: Corutinas y métodos que usan `yield return` (puede aparecer `MoveNext`)
* **Controladores de eventos**: Expresiones lambda en suscripciones a eventos
* **Callbacks de UI**: Controladores de clic en Unity como `button.onClick.AddListener(() => {...})`

**Patrones comunes que verás:**

| Patrón | Qué significa | Ejemplo |
|---------|---------------|---------|
| `YourClass+<>c` | Clase de delegado en caché para lambdas simples | `YourClass+<>c in ThrowExceptionInLinq { <lambda> }` |
| `YourClass+<>c__DisplayClass#_#` | Clase auxiliar para cierres (closures) que capturan variables locales | `YourClass+<>c__DisplayClass12_0 in ThrowExceptionInClosure { <lambda> }` |
| `<>n__0`, `<>n__1` | Nombres de métodos generados por el compilador (pueden aparecer en trazas de pila detalladas) | Sufijo del nombre del método que distingue múltiples lambdas |
| `{ <lambda> }` | Indica que el fotograma proviene de una expresión lambda | Se muestra en los títulos de issues de Sentry |
| `MoveNext` | Método de máquina de estados para async/await o métodos iteradores | Común en métodos async y corutinas de Unity |

**Ejemplo:**

Si tu código contiene:

```csharp
public void ThrowExceptionInLinq()
{
    var numbers = new List<int> { 1, 2, 3, 4, 5 };
    var result = numbers.Where(n =>
    {
        if (n == 3) throw new InvalidOperationException("Error");
        return n > 2;
    }).ToList();
}
```

El issue de Sentry mostrará algo como:

```
YourClass+<>c en ThrowExceptionInLinq { <lambda> }
```

**Cómo interpretar estos frames:**

1. **`+<>c`**: El `+` indica una clase anidada. `<>c` es una clase de delegado en caché que contiene el código compilado de la lambda
2. **`+<>c__DisplayClass#_#`**: Similar a `<>c`, pero se usa cuando la lambda captura variables locales (crea un “closure”)
3. **Nombre del método mostrado**: Revisa el nombre del método contenedor (después de “in”) para identificar dónde en tu código se definió la lambda
4. **`{ <lambda> }`**: Confirma que la excepción ocurrió dentro de la propia expresión lambda
5. **`MoveNext`**: Para métodos asíncronos y coroutines, este es el método de la máquina de estados que ejecuta tu código

Estos frames son normales y esperables en aplicaciones de C#. Proporcionan información precisa sobre dónde ocurrió una excepción dentro de expresiones lambda y código generado por el compilador.


<div id="cysharp">
  ## Cysharp
</div>

**Nota: Este problema está obsoleto y resuelto a partir de Unity 2021+ con UniTask 2.5.10+**

En versiones anteriores, el SDK no proporcionaba números de línea ni contexto de código al usarse con Cysharp. Esto se debe a que el SDK depende del backend IL2CPP de Unity para suministrar direcciones de instrucción, que Sentry utiliza para generar los números de línea en los eventos. Sin embargo, cuando el stack trace entraba en la biblioteca de Cysharp, esas direcciones de instrucción pasaban a 0x0, lo que impedía informar los números de línea.

Este problema se ha resuelto en versiones más recientes. Si estás experimentando este problema, actualizar a Unity 2021 o posterior junto con UniTask 2.5.10 o posterior debería solucionarlo.

<div id="webgl-support">
  ## Compatibilidad con WebGL
</div>

Al compilar para WebGL, tienes la opción de configurar `PlayerSettings.WebGL.exceptionSupport`, pero ten en cuenta estas limitaciones:

- Establecerlo en `WebGLExceptionSupport.None` no es compatible con el SDK.
- Para que el SDK pueda proporcionar trazas de pila, debe establecerse en `WebGLExceptionSupport.FullWithStacktrace`.
- Actualmente, el SDK no puede proporcionar números de línea porque el backend IL2CPP no está disponible.
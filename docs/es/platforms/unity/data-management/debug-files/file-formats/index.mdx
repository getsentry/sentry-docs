---
title: "Depurar formatos de archivo"
description: "Conoce los formatos de archivo específicos de cada plataforma y la información de depuración que contienen."
sidebar_order: 1
---

Sentry distingue cuatro tipos de información de depuración:

* **Información de depuración:** Proporciona nombres de funciones, rutas a archivos fuente, números de línea y frames en línea. El proceso de resolver esta información a partir de direcciones de instrucción se denomina &quot;symbolication&quot;. Esta información es relativamente grande en comparación con el ejecutable y, por lo general, se coloca en un archivo separado. En Sentry, estos archivos se designan como *debug companions* y muestran la etiqueta `debug`.

* **Tablas de símbolos:** Si no hay información de depuración disponible para una biblioteca determinada, Sentry puede usar tablas de símbolos como alternativa para obtener nombres de funciones. Las tablas de símbolos suelen incluirse tanto en el ejecutable como en los archivos de acompañamiento de depuración. Sin embargo, no contienen información suficiente para resolver funciones en línea ni nombres de archivo y números de línea. La etiqueta `symtab` indica tablas de símbolos.

* **Código fuente:** Por convención, el código fuente no forma parte de los archivos habituales de información de depuración. Sentry CLI puede empaquetar el código fuente de tu aplicación y cargarlo para mostrar contexto de código en los stack traces en Sentry. Estos paquetes aparecen con la etiqueta `sources`.

* **Información de desenrollado:** Permite a Sentry extraer stack traces de Minidumps y otros formatos binarios de fallos en compilaciones optimizadas. A este proceso se le llama &quot;stack unwinding&quot; o &quot;stack walking&quot;. Dado que también se requiere al lanzar excepciones en C++, esta información a menudo se incluye en el ejecutable o la biblioteca. Si un archivo cargado contiene esta información, muestra la etiqueta `unwind`. Ten en cuenta que en algunas plataformas no se realiza ningún desenrollado real. Por ejemplo, WebAssembly actualmente no tiene el equivalente de minidumps, lo que significa que no se requiere ese tipo de información en esos casos.

Los compiladores colocan la información de depuración anterior en distintos archivos según la plataforma de destino, la arquitectura, las flags de compilación o el nivel de optimización. En consecuencia, Sentry podría no necesitar toda la información anterior para procesar informes de fallos. Aun así, siempre es buena idea proporcionar toda la información de depuración disponible.

`sentry-cli` se puede usar para listar propiedades de archivos de depuración compatibles y validar su contenido. Consulta [*Archivos de información de depuración en sentry-cli*](/es/cli/dif/) para más información.

<div id="mach-o-and-dsym">
  ## Mach-O y dSYM
</div>

Los ejecutables, las bibliotecas dinámicas y los complementos de depuración en todas las plataformas de Apple usan el formato de contenedor *Mach Object*, o, en corto, *Mach-O*. Esto se aplica a iOS, iPadOS, tvOS, watchOS, macOS y visionOS.

* **Los ejecutables** no llevan extensión de archivo. En aplicaciones de escritorio, a menudo se colocan en estructuras de paquetes de apps con el sufijo `.app`. A menos que se elimine manualmente, los ejecutables contienen información de desenrollado (unwind) y una tabla de símbolos. La información de depuración nunca se almacena en los ejecutables.

* **Las bibliotecas dinámicas** usan la extensión `.dylib` y, por lo demás, se comportan exactamente igual que los ejecutables.

* **Los complementos de depuración** se colocan en una estructura de carpetas con la extensión `.dSYM` y se ubican en `<name>.dSYM/Contents/Resources/DWARF/<name>`. Por lo general contienen una tabla de símbolos e información de depuración, pero rara vez información de desenrollado (unwind).

Al compilar una aplicación con Xcode o con el compilador `clang`, la información de depuración se coloca automáticamente en un archivo dSYM. Sin embargo, al enlazar manualmente, el archivo dSYM debe crearse con el siguiente comando:

```bash
dsymutil /ruta/a/salida[.dylib]
```

<div id="executable-and-linkable-format-elf">
  ## Formato Ejecutable y Enlazable (ELF)
</div>

En las distribuciones de Linux, los ejecutables y la información de depuración se almacenan en contenedores *ELF*. A diferencia de otras plataformas, no existe un contenedor ni un especificador específico para los archivos de depuración asociados.

La información de depuración forma parte del binario (ejecutable o biblioteca) y se elimina al generar compilaciones de lanzamiento debido a su tamaño. No obstante, existe una forma de conservarla en un archivo independiente (ya sea en otra ubicación o con la extensión `.debug`):

```bash
# Hay un ejecutable llamado "binary" en el CWD
objcopy --only-keep-debug binary binary.debug
objcopy --strip-debug --strip-unneeded binary
objcopy --add-gnu-debuglink=binary.debug binary
```

Esto da como resultado la siguiente estructura:

* **Ejecutables** no llevan extensión de archivo. Si se eliminan símbolos como arriba,
  los ejecutables contienen una tabla de símbolos, pero no información de depuración. Si en la compilación
  se omiten los punteros de marco, también se conservará la información de desenrollado. Ambos pueden
  reducirse aún más usando flags como `--strip-all`.

* **Bibliotecas compartidas** usan la extensión `.so` y, por lo demás, se comportan exactamente
  igual que los ejecutables.

* **Archivos de depuración** no tienen una extensión estándar, pero a menudo
  se llaman `.debug`. Si se eliminan símbolos como arriba, estos archivos contienen información de desenrollado,
  información de depuración y una tabla de símbolos.

Las bibliotecas compartidas instaladas mediante gestores de paquetes suelen proporcionar su información de depuración
en paquetes `*-dev` independientes y la colocan en ubicaciones como
`/usr/local/debug/...`. Para recibir trazas de pila simbolizadas de esas
bibliotecas, asegúrate de subir también sus símbolos además de los símbolos de tu aplicación.

ELF admite la compresión de la información de depuración, lo que puede reducir significativamente
el tiempo necesario para subir archivos de información de depuración a Sentry y, por lo tanto, mejorar
los tiempos de compilación. `gcc` (versión 5 o posterior) y `clang` (versión 5 o posterior) lo admiten
pasando la flag `-gz` tanto al compilador como al enlazador. La forma más común
de comprimir la información de depuración, sin embargo, es al hacer strip del ejecutable:

```bash
# Ten en cuenta la opción --compress-debug-sections
objcopy --only-keep-debug --compress-debug-sections=zlib binary binary.debug
```

Esto puede verificarse comprobando el indicador `C` en `readelf`, que corresponde a
`SHF_COMPRESSED`:

```bash
readelf -S ruta/al/archivo
  ...
  [21] .debug_info       PROGBITS         0000000000000000  00000370
       000000000000e133  0000000000000000   C       0     0     1
```

<div id="pe-and-pdb">
  ## PE y PDB
</div>

Los ejecutables y las bibliotecas dinámicas en Microsoft Windows, y los creados por la
plataforma .NET en todos los sistemas operativos, usan el formato de contenedor *Portable Executable* (*PE*).
La información de depuración asociada se almacena en archivos *Program Database*
(*PDB*).

* **Los ejecutables** usan la extensión de archivo `.exe`. Solo cuando se compilan para arquitecturas de 64 bits
  incluyen información de desenrollado (unwind). De lo contrario, no contienen
  información útil y se omitirán al subirlos a Sentry.

* **Las bibliotecas dinámicas** usan la extensión `.dll` y, por lo demás, se comportan
  exactamente igual que los ejecutables.

* **Los archivos de depuración asociados** se almacenan en archivos `.pdb`. Por lo general incluyen información de depuración
  y, en la mayoría de los casos, tablas de símbolos. En programas de 32 bits, también
  incluyen información de desenrollado (unwind). En casos poco frecuentes, podrían tener nombres de archivo distintos
  a los de su ejecutable correspondiente.

* La plataforma .NET usa una variación de este formato, llamada [Portable PDBs](https://github.com/dotnet/core/blob/main/Documentation/diagnostics/portable_pdb.md).
  Las Portable PDBs son compatibles desde Sentry 22.11.0 (o Sentry CLI 2.8.0, o Symbolic 10.0.0).

<div id="breakpad-symbols">
  ## Símbolos de Breakpad
</div>

La biblioteca Google Breakpad ha establecido un formato ASCII independiente de la plataforma
para almacenar información de depuración. Estos archivos suelen generarse para aplicaciones
que usan Breakpad, Crashpad o el framework Electron.

El repositorio de Breakpad incluye herramientas `dump_syms` para cada plataforma que pueden
convertir archivos de depuración nativos en símbolos de Breakpad. Estos convertidores agrupan toda
la información disponible en un único archivo, de modo que solo sea necesario cargar un archivo.

A diferencia de los archivos de depuración nativos, los símbolos de Breakpad descartan mucha información
que no se requiere para procesar minidumps. En particular, las funciones inline
no se declaran, por lo que Sentry no puede mostrar frames inline en los seguimientos de pila.

<div id="wasm">
  ## WASM
</div>

Para WebAssembly, admitimos [DWARF en contenedores WASM](https://yurydelendik.github.io/webassembly-dwarf/).
Ten en cuenta que no admitimos los source maps, que también son un formato usado para la depuración de WASM,
pero presentan limitaciones que los hacen poco prácticos para una herramienta de reporte de fallos como Sentry.

[WebAssembly admite IDs de compilación](https://github.com/WebAssembly/tool-conventions/blob/main/BuildId.md) como una
[sección personalizada](https://webassembly.github.io/spec/core/binary/modules.html#custom-section). Esta sección
es compatible con `LLVM` [desde la versión 17](https://github.com/llvm/llvm-project/commit/c7af9ae577bb04c5fe120fc07844a500818c8f47) (y, con ello, la correspondiente toolchain de `emscripten`).

Además, ofrecemos una herramienta para añadir IDs de compilación y dividir archivos llamada [wasm-split](https://github.com/getsentry/symbolicator/blob/master/crates/wasm-split)
que te ayuda a crear un archivo de depuración complementario listo para subir a Sentry
mientras elimina toda la información de depuración del binario de la versión.

<div id="proguard-mappings">
  ## Mapeos de ProGuard
</div>

Los archivos de mapeo de ProGuard permiten que Sentry convierta rutas de clase y nombres de métodos de Java ofuscados a su forma original. En ese sentido, funcionan como archivos de información de depuración para aplicaciones de Java y Android.
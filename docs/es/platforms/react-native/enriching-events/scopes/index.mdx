---
title: Ámbitos
description: "Los SDKs suelen gestionar automáticamente los ámbitos por ti en las integraciones con frameworks. Descubre qué es un ámbito y cómo puedes aprovecharlo."
---

Cuando se captura un evento y se envía a Sentry, los SDKs combinan esos datos del evento con información adicional del ámbito actual. Por lo general, los SDKs gestionan automáticamente los ámbitos por ti en las integraciones con frameworks y no tienes que preocuparte por ellos. Sin embargo, conviene que sepas qué es un ámbito y cómo puedes sacarle partido.

<div id="whats-a-scope">
  ## ¿Qué es un scope?
</div>

Los scopes contienen información útil que se envía junto con el
evento. Por ejemplo, [contexts](../context/) y
[breadcrumbs](../breadcrumbs/) se almacenan en
el scope. Cuando se crea una bifurcación (fork) de un scope, este hereda todos los datos de su scope padre.

Las integraciones predeterminadas del SDK bifurcan scopes de forma inteligente. Por
ejemplo, las integraciones de frameworks web bifurcan scopes alrededor de tus
rutas o controladores de solicitudes.

<div id="how-scopes-work">
  ## Cómo funcionan los scopes
</div>

Los scopes son básicamente pilas de datos que se adjuntan a los eventos. Cuando se captura un evento, el SDK fusiona los datos de los scopes activos con el evento. Esto te permite añadir datos a los eventos que sean relevantes para el contexto en el que se capturó el evento.

Un scope generalmente es válido dentro de un callback o un contexto de ejecución. Esto significa que varias partes de tu aplicación pueden tener scopes distintos activos al mismo tiempo. Por ejemplo, un servidor web podría gestionar varias solicitudes a la vez, y cada solicitud puede tener datos de scope diferentes para aplicar a sus eventos.

<div id="different-kinds-of-scopes">
  ## Tipos de scopes
</div>

El SDK de Sentry tiene tres tipos de scopes:

- [Scope global](#global-scope)
- [Scope de aislamiento](#isolation-scope)
- [Scope actual](#current-scope)

<div id="global-scope">
  ### Alcance global
</div>

El alcance global se aplica a _todos_ los eventos, sin importar de dónde provengan. Puedes usarlo para almacenar datos que deban aplicarse a todos los eventos, como información del entorno.

Puedes acceder al alcance global mediante `Sentry.getGlobalScope()`.

Ten en cuenta que el alcance global solo puede usarse para escribir datos, no para capturar eventos. Los eventos solo pueden capturarse en el alcance actual (por ejemplo, `getCurrentScope().captureException()` y APIs similares).

<div id="isolation-scope">
  ### Ámbito de aislamiento
</div>

El ámbito de aislamiento se utiliza para aislar los eventos entre sí. Por ejemplo, cada solicitud en un servidor web podría tener su propio ámbito de aislamiento para que los eventos de una solicitud no interfieran con los de otra. En la mayoría de los casos, querrás poner en el ámbito de aislamiento los datos que deban aplicarse a tus eventos. Por eso, todos los métodos `Sentry.setXXX`, como `Sentry.setTag()`, escribirán datos en el ámbito de aislamiento activo. Un ejemplo clásico de datos que pertenecen al ámbito de aislamiento es la información del usuario: cada solicitud puede tener un usuario diferente, por lo que querrás asegurarte de que el usuario esté definido en el ámbito de aislamiento.

Puedes acceder al ámbito de aislamiento mediante `Sentry.getIsolationScope()`, pero normalmente usarás los métodos `Sentry.setXXX` para establecer datos en el ámbito de aislamiento activo:

```javascript
Sentry.setTag("my-tag", "my value");
// Es equivalente a:
Sentry.getIsolationScope().setTag("my-tag", "my value");
```

<PlatformCategorySection supported={["browser"]}>
  En el navegador, el ámbito de aislamiento nunca se bifurca porque es imposible hacer un seguimiento de dónde debería pertenecer. Por eso, en la práctica, el ámbito de aislamiento es global en el navegador.
</PlatformCategorySection>

Ten en cuenta que el ámbito de aislamiento solo puede usarse para escribir datos, no para capturar eventos. Los eventos solo pueden capturarse en el ámbito actual (por ejemplo, `getCurrentScope().captureException()` y API similares).


<div id="current-scope">
  ### Alcance actual
</div>

El alcance actual es el alcance local que está activo en este momento. A diferencia del alcance de aislamiento —que rara vez se bifurca—, el alcance actual puede bifurcarse con más frecuencia y de forma interna. Puede utilizarse para almacenar datos que solo deban aplicarse a eventos específicos. En la mayoría de los casos, no deberías acceder a este alcance directamente, sino usar `Sentry.withScope` para crear un nuevo alcance que solo esté activo en una parte específica de tu código:

```javascript
Sentry.withScope((scope) => {
  // scope es el alcance actual dentro de este callback
  scope.setTag("my-tag", "my value");
  // esta etiqueta solo se aplicará a los eventos capturados dentro de este callback
  // el siguiente evento tendrá la etiqueta:
  Sentry.captureException(new Error("mi error"));
});
// este evento no tendrá la etiqueta:
Sentry.captureException(new Error("mi otro error"));
```

Puedes acceder al alcance actual mediante `Sentry.getCurrentScope()`, pero en la mayoría de los casos deberías usar `Sentry.withScope()` para interactuar con alcances locales.


<div id="how-scope-data-is-applied-to-events">
  ## Cómo se aplica el alcance (scope) a los eventos
</div>

Antes de que un evento (como un error o una transacción) se envíe a Sentry, se le aplican los alcances (scopes) activos.

Primero se aplica el alcance global, luego el de aislamiento y, por último, el actual. Esto significa que cualquier dato configurado en el alcance actual tendrá prioridad sobre el configurado en los alcances de aislamiento y global:

```javascript
Sentry.getGlobalScope().setExtras({
  shared: "global",
  global: "data",
});
Sentry.getIsolationScope().setExtras({
  shared: "isolation",
  isolation: "data",
});
Sentry.getCurrentScope().setExtras({
  shared: "current",
  current: "data",
});

Sentry.captureException(new Error("mi error"));
// --> Tendrá los siguientes extras:
// { shared: 'current', global: 'data', isolation: 'data', current: 'data' }
```


<div id="configuring-the-scope">
  ## Configuración del scope
</div>

Hay dos formas principales de interactuar con el scope. Puedes acceder al scope actual mediante `Sentry.getCurrentScope()` y usar los setters en el scope resultante, o puedes usar métodos globales como `Sentry.setTag()` directamente, que establecerán los valores en el scope correspondiente bajo el capó (este será el scope de aislamiento).

Primero tendrás que importar el SDK, como de costumbre:

<PlatformContent includePath="enriching-events/import" />

Puedes, por ejemplo, añadir etiquetas personalizadas o informar a Sentry sobre el usuario que está autenticado actualmente.

```javascript
/// Normalmente no querrás escribir en el ámbito actual, así que úsalo con cuidado.
const scope = Sentry.getCurrentScope();
scope.setTag("my-tag", "my value");
scope.setUser({
  id: 42,
  email: "john.doe@example.com",
});

// O usa los métodos globales (que establecerán los datos en el ámbito de aislamiento):
Sentry.setTag("my-tag", "my value");
Sentry.setUser({
  id: 42,
  email: "john.doe@example.com",
});
```

Para saber qué información útil se puede asociar a los scopes, consulta
[context](../context/), [tags](../tags), [users](../identify-user) y [breadcrumbs](../breadcrumbs/).


<div id="using-withscope">
  ## Uso de `withScope`
</div>

En el siguiente ejemplo usamos <PlatformIdentifier name="with-scope" /> para adjuntar un `level` y una `tag` a un único error específico:

<PlatformContent includePath="enriching-events/scopes/with-scope" />

El scope dentro del callback de `withScope()` solo es válido dentro del propio callback. Una vez que el callback termina, el scope se elimina y deja de aplicarse. El scope interno solo se aplica a los eventos que se capturan dentro del callback. `withScope()` clonará (o bifurcará) el scope actual, por lo que el scope actual no se modificará. Esto te permite aislar más fácilmente fragmentos de información de contexto en ubicaciones específicas de tu código o incluso llamar a <PlatformIdentifier name="clear" /> para eliminar temporalmente toda la información de contexto.
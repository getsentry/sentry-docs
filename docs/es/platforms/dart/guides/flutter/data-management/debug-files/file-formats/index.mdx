---
title: "Depurar formatos de archivo"
description: "Conoce los formatos de archivo específicos de cada plataforma y la información de depuración que contienen."
sidebar_order: 1
---

Sentry distingue cuatro tipos de información de depuración:

* **Información de depuración:** Proporciona nombres de funciones, rutas a archivos fuente, números de línea y marcos en línea. El proceso de resolver esta información a partir de direcciones de instrucción se denomina &quot;symbolication&quot;. Esta información es relativamente voluminosa en comparación con el ejecutable y suele colocarse en un archivo aparte. En Sentry, estos archivos se denominan *debug companions* y muestran la etiqueta `debug`.

* **Tablas de símbolos:** Si no hay información de depuración disponible para una biblioteca determinada, Sentry puede usar tablas de símbolos como alternativa para recuperar nombres de funciones. Las tablas de símbolos suelen incluirse tanto en el ejecutable como en los archivos debug companion. Sin embargo, no contienen suficiente información para resolver funciones en línea ni nombres de archivo y números de línea. La etiqueta `symtab` indica tablas de símbolos.

* **Código fuente:** Por lo general, el código fuente no forma parte de los archivos de información de depuración habituales. Sentry CLI puede empaquetar el código fuente de tu aplicación y cargarlo para mostrar el contexto del código en los stack traces en Sentry. Estos paquetes aparecen con la etiqueta `sources`.

* **Información de desenrollado:** Permite a Sentry extraer stack traces de Minidumps y otros formatos binarios de fallos en compilaciones optimizadas. A este proceso se le llama &quot;stack unwinding&quot; o &quot;stack walking&quot;. Dado que esto también se requiere al lanzar excepciones en C++, esta información suele incluirse en el ejecutable o la biblioteca. Si un archivo cargado contiene esta información, mostrará la etiqueta `unwind`. Ten en cuenta que en algunas plataformas no se realiza un desenrollado real. Por ejemplo, WebAssembly actualmente no tiene el equivalente de minidumps, lo que significa que no se requiere ese tipo de información en esos casos.

Los compiladores colocan la información de depuración anterior en distintos archivos según la plataforma de destino, la arquitectura, las banderas de compilación o el nivel de optimización. En consecuencia, Sentry puede no necesitar toda la información anterior para procesar informes de fallos. Aun así, siempre es buena idea proporcionar toda la información de depuración disponible.

`sentry-cli` se puede usar para listar propiedades de los archivos de depuración compatibles y validar su contenido. Consulta [*Archivos de información de depuración en sentry-cli*](/es/cli/dif/) para obtener más información.

<div id="mach-o-and-dsym">
  ## Mach-O y dSYM
</div>

Los ejecutables, bibliotecas dinámicas y archivos de depuración en todas las plataformas de Apple usan el formato contenedor *Mach Object*, o *Mach-O* para abreviar. Esto aplica a iOS, iPadOS, tvOS, watchOS, macOS y visionOS.

* **Los ejecutables** no llevan extensión de archivo. En aplicaciones de escritorio, a menudo se encuentran dentro de paquetes de apps con el sufijo `.app`. A menos que se eliminen manualmente, los ejecutables contienen información de desenrollado (unwind) y una tabla de símbolos. La información de depuración nunca se almacena en los ejecutables.

* **Las bibliotecas dinámicas** usan la extensión `.dylib` y, por lo demás, se comportan exactamente igual que los ejecutables.

* **Los archivos de depuración** se ubican en una estructura de carpetas con la extensión `.dSYM`, y se encuentran en `<name>.dSYM/Contents/Resources/DWARF/<name>`. Por lo general, contienen una tabla de símbolos e información de depuración, pero rara vez información de desenrollado.

Al compilar una aplicación con Xcode o con el compilador `clang`, la información de depuración se coloca automáticamente en un archivo dSYM. Sin embargo, al enlazar manualmente, el archivo dSYM debe crearse usando el siguiente comando:

```bash
dsymutil /ruta/a/salida[.dylib]
```

<div id="executable-and-linkable-format-elf">
  ## Formato ejecutable y enlazable (ELF)
</div>

En las distribuciones Linux, los ejecutables y la información de depuración se almacenan en contenedores *ELF*. A diferencia de otras plataformas, no existe un contenedor ni un especificador específico para archivos de depuración asociados.

La información de depuración forma parte del binario (ejecutable o biblioteca) y se elimina al generar compilaciones de release debido a su tamaño. No obstante, es posible conservarla en un archivo aparte (ya sea en otra ubicación o con la extensión `.debug`):

```bash
# Hay un ejecutable llamado "binary" en el CWD
objcopy --only-keep-debug binary binary.debug
objcopy --strip-debug --strip-unneeded binary
objcopy --add-gnu-debuglink=binary.debug binary
```

Esto da como resultado la siguiente estructura:

* **Ejecutables** no llevan extensión de archivo. Si se les aplica `strip` como arriba,
  los ejecutables contienen una tabla de símbolos, pero no información de depuración. Si en la
  compilación se omiten los punteros de marco, también se conservará la información de desenrollado. Ambos pueden
  eliminarse aún más usando opciones como `--strip-all`.

* **Bibliotecas compartidas** usan la extensión `.so` y, por lo demás, se comportan exactamente
  igual que los ejecutables.

* **Archivos de depuración** no llevan una extensión estándar, pero a menudo
  se llaman `.debug`. Si se les aplica `strip` como arriba, estos archivos contienen información de desenrollado,
  información de depuración y una tabla de símbolos.

Las bibliotecas compartidas instaladas a través de gestores de paquetes normalmente proporcionan su información de
depuración en paquetes `*-dev` separados y la colocan en ubicaciones como
`/usr/local/debug/...`. Para obtener trazas de pila simbolizadas de esas
bibliotecas, asegúrate de subir también sus símbolos además de los símbolos de tu app.

ELF admite la compresión de la información de depuración, lo que puede reducir significativamente
el tiempo necesario para subir archivos de información de depuración a Sentry y así mejorar
los tiempos de compilación. `gcc` (versión 5 o posterior) y `clang` (versión 5 o posterior) lo admiten
pasando la opción `-gz` tanto al compilador como al enlazador. La forma más común
de comprimir la información de depuración, sin embargo, es al aplicar `strip` al ejecutable:

```bash
# Ten en cuenta la opción --compress-debug-sections
objcopy --only-keep-debug --compress-debug-sections=zlib binary binary.debug
```

Esto puede verificarse comprobando la marca `C` en `readelf`, que corresponde a
`SHF_COMPRESSED`:

```bash
readelf -S ruta/al/archivo
  ...
  [21] .debug_info       PROGBITS         0000000000000000  00000370
       000000000000e133  0000000000000000   C       0     0     1
```

<div id="pe-and-pdb">
  ## PE y PDB
</div>

Los ejecutables y las bibliotecas dinámicas en Microsoft Windows, y los creados por la
plataforma .NET en todos los sistemas operativos, usan el formato de contenedor *Portable Executable* (*PE*).
La información de depuración asociada se almacena en archivos *Program Database*
(*PDB*).

* **Ejecutables** usan la extensión de archivo `.exe`. Solo cuando se compilan para arquitecturas
  de 64 bits contienen información de desenrollado. De lo contrario, no contienen
  ninguna información útil y se omitirán al cargarlos en Sentry.

* **Bibliotecas dinámicas** usan la extensión `.dll` y, por lo demás, se comportan
  exactamente igual que los ejecutables.

* **Archivos de depuración** se almacenan en `.pdb`. Por lo general, contienen información
  de depuración y, en la mayoría de los casos, tablas de símbolos. En programas de 32 bits, también
  contienen información de desenrollado. En casos raros, pueden tener nombres de archivo distintos a los de su ejecutable correspondiente.

* La plataforma .NET usa una variante de este formato, llamada [Portable PDBs](https://github.com/dotnet/core/blob/main/Documentation/diagnostics/portable_pdb.md).
  Las Portable PDBs son compatibles a partir de Sentry 22.11.0 (o Sentry CLI 2.8.0, o Symbolic 10.0.0).

<div id="breakpad-symbols">
  ## Símbolos de Breakpad
</div>

La biblioteca Google Breakpad ha establecido un formato ASCII independiente de la plataforma
para almacenar información de depuración. Estos archivos suelen generarse para aplicaciones
que usan Breakpad, Crashpad o el framework Electron.

El repositorio de Breakpad incluye herramientas `dump_syms` para cada plataforma que pueden
convertir archivos de depuración nativos en símbolos de Breakpad. Estos conversores agrupan toda
la información disponible en un único archivo, de modo que solo sea necesario cargar
un archivo.

A diferencia de los archivos de depuración nativos, los símbolos de Breakpad descartan mucha información
que no se requiere para procesar minidumps. En particular, las funciones en línea no
se declaran, por lo que Sentry no puede mostrar marcos en línea en los seguimientos de pila.

<div id="wasm">
  ## WASM
</div>

Para WebAssembly, ofrecemos compatibilidad con [DWARF en contenedores WASM](https://yurydelendik.github.io/webassembly-dwarf/).
Ten en cuenta que no admitimos los source maps, que también son un formato usado para la depuración de WASM,
pero presentan limitaciones que los hacen poco prácticos para una herramienta de informes de fallos como Sentry.

[WebAssembly admite identificadores de compilación (build IDs)](https://github.com/WebAssembly/tool-conventions/blob/main/BuildId.md) como una
[sección personalizada](https://webassembly.github.io/spec/core/binary/modules.html#custom-section). Esta sección
está disponible en `LLVM` [desde la versión 17](https://github.com/llvm/llvm-project/commit/c7af9ae577bb04c5fe120fc07844a500818c8f47) (y, con ello, en la correspondiente toolchain de `emscripten`).

Además, ofrecemos una herramienta para añadir build IDs y dividir archivos llamada [wasm-split](https://github.com/getsentry/symbolicator/blob/master/crates/wasm-split)
que te ayuda a crear un archivo de depuración complementario listo para subir a Sentry,
al tiempo que elimina toda la información de depuración del binario de la versión.

<div id="proguard-mappings">
  ## Mapas de ProGuard
</div>

<Alert>
  El método recomendado para [usuarios de Android es usar el plugin de Gradle](/es/platforms/android/configuration/gradle/).
</Alert>

Los archivos de mapeo de ProGuard permiten que Sentry resuelva rutas de clases y nombres de métodos de Java ofuscados a su forma original. En ese sentido, actúan como archivos de información de depuración para aplicaciones Java y Android.
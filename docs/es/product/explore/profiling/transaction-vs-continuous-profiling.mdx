---
title: Perfilado por transacciones vs. continuo y de UI
sidebar_order: 140
description: "Conoce las diferencias entre el perfilado basado en transacciones y los nuevos productos de Perfilado continuo y de UI."
---

Hemos lanzado dos nuevos productos: Perfilado continuo (centrado en aplicaciones de backend) y Perfilado de UI (centrado en aplicaciones de frontend), con la intención de reemplazar nuestro anterior producto de perfilado basado en transacciones. Sigue leyendo para conocer más sobre las diferencias entre estas implementaciones.

<div id="historical-context-on-transaction-based-profiling">
  ## Contexto histórico del perfilado basado en transacciones
</div>

Nuestra implementación inicial de perfilado es lo que a lo largo de este documento denominamos *perfilado basado en transacciones*. Como su nombre indica, en este modo el perfilado estaba acoplado al ciclo de vida de una transacción (término que usamos para describir un [span raíz](/es/concepts/key-terms/tracing/)). Cuando la transacción comenzaba, el perfilado se iniciaba automáticamente y, cuando la transacción terminaba, el perfilado finalizaba automáticamente. Esto significaba que, si tu aplicación ya estaba instrumentada con trazas, el perfilado podía habilitarse con un esfuerzo adicional mínimo. Si bien este enfoque simplificaba la configuración, tenía algunas desventajas.

Una limitación importante era que los perfiles no podían exceder los 30 segundos de duración. Dado que los perfiles debían enviarse junto con su transacción correspondiente, los SDK tenían que almacenar en búfer los datos de perfilado en el cliente durante toda la duración de la transacción. Las transacciones pueden ser arbitrariamente largas, pero las cargas útiles de perfiles son grandes en comparación con los spans y, por lo tanto, no podíamos mantener en búfer los datos de perfilado indefinidamente sin arriesgar un uso excesivo de memoria y estados OOM (out-of-memory) en el cliente. Debido a esta limitación, no era posible usar el perfilado basado en transacciones para operaciones de larga duración (p. ej., perfilar sesiones completas de usuario en el frontend o tareas de larga duración en el backend).

Otra limitación era que, al acoplarlo a las transacciones, el perfilado quedaba restringido únicamente a las partes de la aplicación que tenían una cobertura de instrumentación de trazas adecuada. Si alguna parte de la aplicación no estaba instrumentada con spans, tampoco se recopilaban datos de perfilado. La existencia de estas brechas de datos dificulta determinar con precisión cuáles son los cuellos de botella de rendimiento más importantes.

Continuous Profiling y UI Profiling se diseñaron para abordar estas limitaciones y ofrecer capacidades de perfilado más potentes, útiles en una gama más amplia de escenarios. **Estos productos no tienen límite en la duración máxima del perfil porque los datos se transmiten por partes, y proporcionan control total sobre cuándo se está ejecutando el profiler.**

<div id="continuous-profiling">
  ## Perfilado continuo
</div>

El producto de perfilado continuo fue diseñado para ayudar a depurar cuellos de botella de rendimiento en aplicaciones y servicios backend. La forma recomendada de usar el perfilado continuo es iniciar el profiler cuando se inicia un servicio y detenerlo cuando el servicio finaliza. Al ejecutar el profiler de forma continua durante toda la vida útil del servicio, Sentry puede ofrecer visibilidad completa de rutas de código que podrían estar causando un uso excesivo de recursos y, en consecuencia, altos costos de infraestructura.

El uso del perfilado continuo puede limitarse de varias maneras si te preocupa el costo o la [sobrecarga de rendimiento](/es/product/explore/profiling/performance-overhead):

* Usar controles de muestreo del lado del cliente para recopilar perfiles en menos instancias del mismo servicio (por ejemplo, perfilar solo el 10% de las instancias de un servicio)
* Usar las API `start_profiler` y `stop_profiler` para perfilar selectivamente solo las partes del servicio conocidas por ser críticas para el rendimiento

<div id="ui-profiling">
  ## Perfilado de UI
</div>

El producto de Perfilado de UI está diseñado para ayudar a depurar cuellos de botella de rendimiento en aplicaciones de frontend. Estos cuellos de botella suelen causar problemas visibles para el usuario, como desplazamientos o animaciones entrecortados, alta latencia en las interacciones y tiempos de carga lentos. La forma recomendada de usar Perfilado de UI es iniciar el perfilador cuando comienza la sesión del usuario y detenerlo cuando la sesión termina (cuando la aplicación se cierra o, en dispositivos móviles, cuando pasa a segundo plano). Al perfilar sesiones completas, Sentry puede ofrecer visibilidad total de las rutas de código que podrían estar degradando la experiencia del usuario y provocando un consumo excesivo de batería en el dispositivo del usuario.

El uso de Perfilado de UI se puede limitar de varias maneras si te preocupan los costos o la [sobrecarga de rendimiento](/es/product/explore/profiling/performance-overhead):

* Usar controles de muestreo del lado del cliente para recopilar perfiles en menos sesiones de usuario (p. ej., perfilar solo el 10% de todas las sesiones)
* Usar las API `start_profiler` y `stop_profiler` para perfilar selectivamente solo las partes de la aplicación críticas para el rendimiento

<div id="lifecycle-modes-manual-and-trace">
  ## Modos de ciclo de vida: Manual y Trace
</div>

Continuous Profiling y UI Profiling presentan dos nuevos modos de ciclo de vida que te ayudan a controlar exactamente cómo se comporta el perfilado en tu aplicación.

El modo de ciclo de vida **manual** brinda control total sobre cuándo se ejecuta el profiler mediante las nuevas API `start_profiler` y `stop_profiler`. Este es el modo de ciclo de vida predeterminado. Si no se invoca `start_profiler`, nunca se recopilarán datos de perfilado.

Uno de los beneficios del perfilado basado en transacciones era la sencillez de poder recopilar perfiles junto con trazas automáticamente sin tener que instrumentar manualmente el código. El modo de ciclo de vida **trace** ofrece un comportamiento similar al del antiguo perfilado basado en transacciones, en el que el perfilado se iniciará y detendrá automáticamente cuando haya una transacción activa o un span raíz. Este modo de ciclo de vida no requiere llamadas manuales a `start_profiler`, pero sí requiere que el tracing esté habilitado y que la aplicación haya sido instrumentada con spans.

<div id="sampling">
  ## Muestreo
</div>

Al igual que el perfilado basado en transacciones, Continuous Profiling y UI Profiling admiten controles de muestreo del lado del cliente. Sin embargo, ahora el muestreo se realiza a nivel de **sesión** en lugar de a nivel de un perfil individual. Para obtener más información sobre cómo funciona el muestreo, consulta la [guía de migración](/es/product/explore/profiling/continuous-ui-profiling-migration-guide/).

<div id="next-steps">
  ## Próximos pasos
</div>

Si ya usas el perfilado basado en transacciones, consulta la [guía de migración](/es/product/explore/profiling/continuous-ui-profiling-migration-guide/) para ver cómo pasar a las nuevas API.

Si eres nuevo, consulta la guía de [introducción](/es/product/explore/profiling/getting-started/) del SDK que utilizas.
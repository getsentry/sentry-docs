---
title: Flame graphs diferenciales
sidebar_order: 110
description: Aprende a usar e interpretar los flame graphs diferenciales.
og_image: /og-images/product-explore-profiling-differential-flamegraphs.png
---

Hay varias formas de visualizar y usar datos de perfilado, entre ellas los flame graphs diferenciales, que ayudan a identificar fácilmente regresiones de funciones o cambios en el contexto de ejecución.

<div id="what-are-differential-flame-graphs">
  ## ¿Qué son los flame graphs diferenciales?
</div>

Los flame graphs diferenciales son visualizaciones que resaltan cómo han cambiado las frecuencias de la pila de llamadas de un programa, una tarea que puede ser tediosa sin ellos. Se usan a menudo para encontrar regresiones de funciones y entender qué funciones se volvieron más lentas, más rápidas o se añadieron recientemente. Ten en cuenta que los flame graphs diferenciales no son un concepto nuevo, sino flame graphs agregados dibujados con los colores generados por el diff entre ambos.

En Sentry, los flame graphs diferenciales se muestran siempre que se detecta una regresión de una función. Cuando ocurre una regresión, Sentry genera dos flame graphs agregados: uno del período previo a la regresión y otro del momento inmediatamente posterior. Luego se usa un flame graph diferencial para visualizar la diferencia entre ambos.

<Alert>

En un flame graph diferencial, el color rojo indica que el tiempo de ejecución de una función ha aumentado o que hay una función nueva. El color azul indica que el tiempo de ejecución ha disminuido.

</Alert>

Presta atención a los frames rojos al interpretar flame graphs diferenciales. Son la razón por la que el código de tu aplicación ha estado rindiendo peor.

![Differential flame graph lock contention](./img/differential-flamegraph.png)

El flame graph diferencial de arriba muestra que la llamada a la función `ModuleLock.acquire` ha aumentado en duración, lo que sugiere un problema de contención de bloqueo que está ralentizando el código.

Veamos otro ejemplo:

![Differential flame graph new functions](./img/differential-flamegraph-new.png)

El flame graph diferencial anterior muestra que se introdujeron nuevas llamadas de función a `OrganizationTeamsEndpoint.dispatch`, lo cual hizo que el código se ejecutara más lento, mientras que disminuyeron las llamadas a `ChunkUploadEndpoint.get`.

Si miras de cerca, notarás que en la esquina superior derecha hay un selector `Before -> After` y `After -> Before`. Esto se debe a que, de forma predeterminada, los flame graphs diferenciales dibujan el flame graph agregado de después de que ocurrió una regresión como fuente de verdad. Esto significa que cualquier código que haya sido eliminado ya no se dibuja (al fin y al cabo, ya no está). Por eso es útil invertir la vista, ya que nos permite comparar los datos de antes y echar un vistazo a cómo cambiará nuestro código.

Aquí tienes un ejemplo de cómo se ve nuestro problema de bloqueo de módulo cuando usamos los datos de perfilado de después de la regresión como fuente de verdad:

![Differential flame graph new functions](./img/differential-flamegraph-regular.png)

Y así es como se ve si usamos los datos de antes de que ocurriera la regresión como nuestra fuente de verdad:

![Differential flame graph new functions](./img/differential-flamegraph-inverted.png)

Al usar el selector `Before -> After` podemos ver que `ModuleLock.acquire` era más rápido antes de la regresión, y también algunas de las llamadas de función dentro de nuestro `ChunkUploadEndpoint`, que ya no se están ejecutando.

Aunque los flame graphs diferenciales en Sentry usan una paleta de colores distinta y extraen de una fuente de datos diferente a la de los flame graphs regulares, puedes desplazarte y hacer zoom por el gráfico y buscar frames del mismo modo que con un flame graph regular.

La tabla debajo del flame graph diferencial muestra tanto los mayores aumentos como las mayores disminuciones en la duración de las funciones.

![Differential flame graph table](./img/differential-flamegraph-table.png)

Los flame graphs diferenciales son una buena manera de visualizar rápidamente posibles fuentes de regresiones o mejoras de rendimiento. Actualmente, solo están disponibles como parte del flujo de trabajo automatizado de regresión de funciones, pero estamos trabajando para añadirlos a otras partes del flujo de trabajo de perfilado.
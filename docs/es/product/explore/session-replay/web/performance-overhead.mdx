---
title: "Sobrecarga de rendimiento de Replay"
sidebar_order: 48
description: "Conoce cómo habilitar Session Replay afecta el rendimiento de tu aplicación web."
---

<Include name="session-replay-web-report-bug.mdx" />

Session Replay funciona observando y registrando los cambios en el DOM de tu aplicación web y transmitiendo esos datos a servidores de ingesta de eventos a través de la Internet pública. Para realizar este trabajo sin afectar negativamente el rendimiento de la página de origen, el SDK de Session Replay procura añadir el mínimo tamaño de archivo posible, observar y registrar el contenido del DOM de forma no intrusiva, enviar la cantidad mínima absoluta de bytes necesaria y usar endpoints de ingesta de baja latencia geográficamente cercanos a tus usuarios finales.

**Para la mayoría de las aplicaciones web, la sobrecarga de rendimiento de nuestro SDK del lado del cliente será imperceptible para los usuarios finales.**

<div id="how-is-session-replay-optimized">
  ## ¿Cómo se optimiza Session Replay?
</div>

El SDK de Session Replay de Sentry toma varias medidas para evitar afectar negativamente el rendimiento de la página en la que se ejecuta:

* Desde la versión [7.78.0](https://blog.sentry.io/sentry-bundle-size-how-we-reduced-replay-sdk-by-35/), el complemento de Session Replay añade ~36 KB comprimidos con gzip.
  * Según nuestras propias investigaciones, este está entre los SDK de Session Replay con el tamaño de archivo más pequeño disponibles.
  * Ofrecemos varias formas de cargar el paquete de Replay, incluida [mediante nuestro Loader Script](/es/platforms/javascript/install/loader/).
* El SDK de Session Replay funciona tomando instantáneas del Document Object Model (DOM) de la página web y transmitiendo su contenido a los servidores de Sentry. Para minimizar la cantidad de bytes transferidos, se emplean varias estrategias:
  * Una vez que se toma la instantánea inicial del árbol del DOM, el SDK registra y transmite los *cambios* (deltas) en el DOM en lugar de volver a capturar el árbol completo. Esto garantiza que se transmita la menor cantidad de estado para facilitar la reproducción. Además, el SDK no consume ciclos de CPU buscando cambios por sí mismo; en su lugar, escucha los cambios emitidos por [`MutationObserver`](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver), una API interna del navegador.
  * El contenido del DOM se comprime con gzip en el cliente antes de la transmisión por HTTP. La operación de compresión se ejecuta en un hilo en segundo plano mediante un [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers), lo que significa que el hilo de la interfaz de usuario del navegador no se ve afectado.
  * El SDK no hace que el navegador descargue ni transmita otros recursos estáticos, como imágenes, vídeos, etc. En su lugar, durante la reproducción, esos recursos se obtienen directamente del servidor de origen.
* La infraestructura de ingesta de eventos de Sentry utiliza [Puntos de Presencia (PoP) distribuidos](https://blog.sentry.io/2022/03/31/sentry-points-of-presence-how-we-built-a-distributed-ingestion/) que sitúan servidores de ingesta en todo el mundo y cerca de tus usuarios. Cuando se transmite un evento de Session Replay, el navegador del usuario se conecta y envía la carga útil del evento al PoP más cercano disponible para su región. Esto reduce en gran medida la latencia de extremo a extremo y minimiza la sobrecarga de red del navegador.
* El SDK está diseñado para degradarse de forma elegante cuando sea necesario. Si ocurren varios miles de mutaciones del DOM a la vez, el SDK deshabilitará la grabación para evitar que registrar el sitio web degrade aún más la experiencia del usuario. Los [valores del límite de mutaciones son configurables](/es/platforms/javascript/session-replay/configuration/#mutation-limits).

<div id="factors-in-performance-overhead">
  ## Factores que afectan la sobrecarga de rendimiento
</div>

Si bien la sobrecarga de rendimiento de nuestro SDK del lado del cliente será imperceptible para los usuarios finales la mayor parte del tiempo, puede variar según la complejidad de tu aplicación. Si una aplicación tiene un DOM grande y numerosas mutaciones de nodos del DOM, habrá mayor sobrecarga en comparación con sitios más simples y en su mayoría estáticos.

Existen distintas etapas en el ciclo de vida de una página web, cada una con diferentes características de rendimiento. A continuación encontrarás una lista de esas etapas y las métricas de rendimiento más importantes que debes tener en cuenta.

<div id="pageload-stage">
  ### Etapa de carga de la página
</div>

* [Optimizamos el tamaño del paquete del SDK.](https://blog.sentry.io/sentry-bundle-size-how-we-reduced-replay-sdk-by-35/) Asegúrate de tener habilitado el tree-shaking y de haber actualizado a la versión más reciente del SDK (al menos la 7.78.0) para obtener los paquetes más pequeños.
* El tamaño de tu página HTML inicial afecta el tiempo que tarda el SDK en leer la instantánea inicial. Con las herramientas de desarrollo del navegador, filtra el panel Network para mostrar &quot;type=document&quot; y revisa el tamaño para hacerte una idea del impacto en tu sitio. Una SPA típica que muestra una pantalla de carga y necesita esperar a que JavaScript renderice todo tendrá una sobrecarga mínima por la instantánea inicial.
* Todos los datos del Replay SDK se comprimen antes de enviarse por la red. El HTML es muy compresible; nos sorprendió lo efectiva que es la compresión en sitios web reales. La sobrecarga de red se reduce aún más si tienes habilitado [PII Masking and Blocking](/es/platforms/javascript/session-replay/privacy/) (que es el valor predeterminado). El texto enmascarado se reemplaza por `*`, lo que gzip reduce muy bien, mientras que el contenido bloqueado no se incluye en absoluto.

<div id="capturing-mousetouch-events">
  ### Captura de eventos de mouse/táctiles
</div>

* Los eventos de movimiento del mouse, clic/toque y hover son extremadamente ligeros y rápidos de registrar; la sobrecarga es insignificante.
* Eliminamos los clics duplicados (sin dejar de detectar rage clicks) y aplicamos suavizado a los eventos de movimiento del mouse para equilibrar el nivel de detalle que ves al depurar con la cantidad de datos redundantes capturados.

<div id="dynamic-content-dom-mutations">
  ### Contenido dinámico y mutaciones del DOM
</div>

* La frecuencia de las mutaciones del DOM depende mucho de cada aplicación. Si no hay mutaciones, no verás que el SDK envíe datos de reproducción a Sentry. En cambio, si tienes temporizadores de JavaScript que actualizan el HTML con regularidad, verás un flujo constante de cambios de HTML enviados por la red.
* El tamaño de las mutaciones del DOM también depende mucho de cada aplicación. Agregar, eliminar o cambiar muchos nodos del DOM de una sola vez aumentará el tiempo necesario para analizar y minificar los datos. Ten en cuenta, sin embargo, que esta sobrecarga ocurre después de que se aplican los cambios al DOM tal como se muestran al usuario (dentro de un callback de `MutationObserver`).
  El SDK tiene [límites de mutación](/es/platforms/javascript/session-replay/configuration/#mutation-limits) para mitigar una mala experiencia de usuario: cambiar 750 nodos registrará un breadcrumb de advertencia en la repetición, mientras que superar los 10,000 nodos hará que la repetición termine.

<div id="page-unload-stage">
  ### Etapa de descarga de la página
</div>

* El SDK no aplica ningún manejo especial durante la descarga de la página; todo lo que esté en memoria será liberado por el navegador y el usuario pasará a su siguiente página web lo más rápido posible.

<div id="measuring-performance-overhead">
  ## Medir la sobrecarga de rendimiento
</div>

La única forma de obtener métricas precisas es medir tú mismo la sobrecarga de rendimiento. Puedes aplicar patrones de acceso realistas en tu propio sitio web e infraestructura y correlacionarlos con tus métricas principales del negocio.
Para aprender a medir la sobrecarga de rendimiento de Session Replay en tus aplicaciones sin desplegar en producción, lee nuestra publicación del blog: [Measuring Session Replay Overhead](https://sentry.engineering/blog/measuring-session-replay-overhead).

Medimos la sobrecarga del Replay SDK en la interfaz web de Sentry utilizando la metodología del blog. Estos son los resultados (se muestran valores medianos):

| Métrica                          | Sin Sentry     | Solo Sentry SDK | Sentry + Replay SDK |
| -------------------------------- | -------------- | --------------- | ------------------- |
| Largest Contentful Paint (LCP)* | 1599.19 ms     | 1546.07 ms      | 1529.11 ms          |
| Cumulative Layout Shift (CLS)    | 0.40 ms        | 0.40 ms         | 0.40 ms             |
| First Input Delay (FID)          | 1.26 ms        | 1.30 ms         | 1.50 ms             |
| Total Blocking Time (TBT)        | 2621.67 ms     | 2663.35 ms      | 3036.80 ms          |
| Average Memory                   | 119.26 MB      | 125.12 MB       | 124.84 MB           |
| Max Memory                       | 320.66 MB      | 359.21 MB       | 339.03 MB           |
| Network Upload                   | 21 B           | 3.84 KB         | 272.51 KB           |
| Network Download                 | 8.06 MB        | 8.09 MB         | 8.07 MB             |

<Alert>
  * La desviación estándar para el LCP fue de 386, 511 y 354 ms, respectivamente. Esto
    significa que los valores de LCP están bastante dispersos y explica por qué el
    valor de LCP con Sentry solo es mayor que el valor con Sentry y Replay.

  {/* prettier-ignore */}

  Benchmarks actualizados por última vez el 25 de septiembre de 2023
</Alert>

Los benchmarks se ejecutaron en un MacBook Pro con Apple M1, contra un servidor de vista previa remoto y un backend de API remoto, con 50 iteraciones. El escenario puede resumirse como: cargar Sentry, navegar a Discover, añadir 4 columnas, esperar los resultados, añadir otra columna y, finalmente, esperar nuevamente los resultados.

La prueba de benchmark fue un escenario de grabación exigente (la tabla de datos de Discover es una de nuestras más complejas en cuanto a nodos y mutaciones del DOM). También se ejecutó un escenario más simple que consistía en navegar a cuatro páginas diferentes de &quot;Settings&quot;, y produjo un aumento de ~100 ms en el tiempo total de bloqueo de JS.

{/* prettier-ignore */}

<Alert>
  Hay un problema de rendimiento conocido que ocurre cuando se registran reproducciones con muchas
  mutaciones del DOM. Suele darse al renderizar tablas o cuadrículas de datos grandes.
  Estamos trabajando en una solución, pero mientras tanto te recomendamos{" "}
  <PlatformLink to="/session-replay/privacy/#blocking">usar la función de bloqueo</PlatformLink>
  para evitar registrar mutaciones de gran tamaño que pueden degradar el rendimiento para tus clientes.
</Alert>

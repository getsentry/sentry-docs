---
title: Consultas N+1
sidebar_order: 10
description: Obtén más información sobre las consultas N+1 y cómo diagnosticarlas y solucionarlas.
og_image: /og-images/product-issues-issue-details-performance-issues-n-one-queries.png
---

_Las consultas N+1_ son un problema de rendimiento en el que la aplicación realiza consultas a la base de datos dentro de un bucle, en lugar de hacer una sola consulta que recupere o modifique toda la información de una vez. Cada conexión a la base de datos requiere cierto tiempo, por lo que consultar la base de datos en un bucle puede ser muchas veces más lento que hacerlo solo una vez. Este problema suele ocurrir cuando se utiliza una herramienta de mapeo objeto-relacional (ORM) en frameworks web como Django o Ruby on Rails.

<div id="detection-criteria">
  ## Criterios de detección
</div>

El detector de problemas de rendimiento busca un conjunto de spans de base de datos secuenciales y sin superposición con descripciones similares. También utiliza los siguientes criterios:

- La duración total de los spans implicados debe superar `50 ms`
- El número total de spans implicados debe superar un umbral (generalmente cinco spans)
- Los spans implicados deben tener consultas completas como descripción (algunos SDK truncan las consultas y agregan puntos suspensivos al final)
- Debe haber al menos un span de base de datos que preceda a los spans repetidos (se le llama span “source” y se utiliza para la generación de la huella/fingerprint)

Si Sentry no detecta un problema N+1 donde esperas uno, probablemente sea porque la transacción no cumplió alguno de los criterios anteriores.

Puedes configurar los umbrales del detector para problemas de consultas N+1 en **Project Settings > Performance**:

![Configuración del umbral del detector de consultas N+1](./img/n-plus-one-queries-detector-settings.png)

<div id="span-evidence">
  ## Evidencia de span
</div>

La evidencia de un problema de N+1 queries tiene cuatro aspectos principales:

- Nombre de la transacción
- Span padre: puede ser una vista, un serializador u otro span que agrupe lógicamente las consultas.
- Span repetido: esta es la "N" de las N+1 queries. Es la consulta iterativa que debería haber sido parte de una consulta por lotes.

![Evidencia de span de N+1 Query](./img/n-plus-one-span-evidence.png)

<div id="fingerprinting">
  ## Huellas digitales
</div>

Sentry calcula la huella del problema a partir del span padre, el span de origen y los spans repetidos. Si ves que Sentry no está agrupando correctamente los problemas de consultas N+1, asegúrate de que los spans de base de datos en tus transacciones usen consultas parametrizadas como descripción del span. Por ejemplo, la descripción del span `SELECT * FROM books WHERE books.id = 1` no está correctamente parametrizada porque incluye el ID del libro. El valor del ID del libro debería variar en cada consulta. Esto generaría huellas distintas y separaría los problemas. Una descripción de span correcta debería verse así: `SELECT * FROM books WHERE books.id = %s`. Aunque Sentry intenta parametrizar las consultas al calcular la huella, puede que se le escapen algunos casos.

<div id="example">
  ## Ejemplo
</div>

Piensa en un sitio web de reseñas de libros. Tiene dos modelos de ORM, `Book` y `Author`, cada uno con su tabla de base de datos correspondiente. El sitio muestra una lista de los diez libros más antiguos y sus respectivos autores. El código podría verse así:

```python
from django.http import HttpResponse

def books(request):
    books = Book.objects.all()[:10]
    book_list = [book.title + " de " + book.author.name for book in books]
    return HttpResponse((", ").join(book_list))
```

Este código tiene un sutil problema de rendimiento. Cada llamada a `book.author.name` realiza una consulta para obtener el autor del libro. En total, este código hace 11 consultas: una para obtener la lista de libros y 10 más para obtener el autor de cada libro. Esto provoca una característica cascada en el intervalo de consultas:

![Consultas N+1 en una aplicación de ejemplo](./img/n-plus-one-queries-before.png)

Para solucionar este problema de rendimiento, puedes usar el método `select_related` en Django, así:

```python
from django.http import HttpResponse

def books(request):
    books = Book.objects.select_related("author").all()[:10]
    book_list = [book.title + " de " + book.author.name for book in books]
    return HttpResponse((", ").join(book_list))
```

Django hará un `JOIN` de las tablas por adelantado y precargará la información del autor. Así, al acceder a `book.author.name` no hace falta realizar una consulta adicional. En lugar de una larga cascada, hay una única consulta `SELECT`:

![Consultas N+1 resueltas en una aplicación de ejemplo](./img/n-plus-one-queries-after.png)

Las N+1 también pueden ocurrir al modificar datos. Por ejemplo, en lugar de crear objetos en un bucle:

```python
for i in range(1, 11):
    Book.objects.create(title: f"Libro {i}")
```

En su lugar, puedes crear los objetos en una única consulta:

```python
Book.objects.bulk_create(
    [Book(title=f"Libro {i}") for i in range(1, 11)]
)
```

---
title: Regex en el hilo principal
sidebar_order: 30
description: Obtén más información sobre los problemas de Regex en el hilo principal y cómo diagnosticarlos y solucionarlos.
og_image: >-
  /og-images/product-issues-issue-details-performance-issues-regex-main-thread.png
---

El hilo principal (o de la interfaz) en una app móvil se encarga de manejar toda la interacción del usuario y debe poder responder a gestos y toques en tiempo real. Si una operación de larga duración bloquea el hilo principal, la app deja de responder, lo que afecta la calidad de la experiencia del usuario.

Evaluar coincidencias entre cadenas y expresiones regulares (regex) puede ser una operación prolongada que impacte la capacidad de respuesta de la app. Si se detecta en el hilo principal una operación de regex de larga duración que pueda trasladarse al segundo plano, Sentry la marcará como un problema.

<div id="detection-criteria">
  ## Criterios de detección
</div>

[Profiling](/es/product/explore/profiling/) debe estar habilitado para que Sentry detecte problemas de Regex en el hilo principal. Sentry busca funciones relacionadas con expresiones regulares que hayan estado ejecutándose en el hilo principal durante al menos 40 ms. Este umbral garantiza que la función aparezca en un número suficiente de muestras recopiladas por el perfil (~10 ms por muestra × 4 = ~40 ms en total) antes de que se detecte como un problema.

<div id="function-evidence">
  ## Evidencia de la función
</div>

Para encontrar información adicional sobre tu problema de Regex en el hilo principal, ve a la página de **Detalles del issue** y desplázate hasta la sección &quot;Evidencia de la función&quot;, que muestra lo siguiente:

* **Nombre de la transacción:** El nombre de la transacción donde se detectó el issue.
* **Función sospechosa:** La función que desencadenó la detección del issue (en este caso, una función de expresión regular).
* **Duración:** Cuánto tardó en ejecutarse la función y la cantidad de muestras consecutivas recopiladas por el generador de perfiles que contenían la función.

![Evidencia de la función Regex en el hilo principal](./img/regex-function-evidence.png)

Para ver el perfil completo asociado con el issue, haz clic en el botón &quot;Ver perfil&quot;.

El perfil indicará desde dónde se llamó a la función sospechosa, junto con otras funciones llamadas *por* la función sospechosa:

![Perfil de Regex en el hilo principal](./img/regex-profile.png)

<div id="stack-trace">
  ## Rastreo de pila
</div>

La sección “Rastreo de pila” muestra un rastreo completo de la pila que indica desde dónde se llamó la función de regex detectada:

![Regex en el rastreo de pila del hilo principal](./img/regex-stack-trace.png)

<div id="example">
  ## Ejemplo
</div>

<div id="ios">
  ### iOS
</div>

El siguiente código busca coincidencias de una expresión regular en una cadena larga:

```swift
let url = Bundle.main.url(forResource: "mobydick", withExtension: "txt")!
let text = try! String(contentsOf: url)
let regex = try! NSRegularExpression(pattern: #"([tT]he)?.*([wW]hale)"#, options: [.dotMatchesLineSeparators])
let results = regex.matches(in: text, range: NSMakeRange(0, text.count))
```

El rendimiento podría mejorar si se trasladan tanto las llamadas para crear como para usar la expresión regular a una cola de menor prioridad (así como las llamadas para cargar el campo de texto que se va a buscar, en este ejemplo):

```swift
DispatchQueue.global(qos: .userInitiated).async {
    let url = Bundle.main.url(forResource: "mobydick", withExtension: "txt")!
    let text = try! String(contentsOf: url)
	let regex = try! NSRegularExpression(pattern: #"([tT]he)?.*([wW]hale)"#, options: [.dotMatchesLineSeparators])
	let results = regex.matches(in: text, range: NSMakeRange(0, text.count))
	DispatchQueue.main.async {
		// mostrar resultados...
	}
}
```

<div id="android">
  ### Android
</div>

El siguiente código llama a `String.matches` en el hilo de la interfaz de usuario para buscar coincidencias con una expresión regular en un texto extenso:

```kotlin
fun matchRegex(text: String, regexPattern: String) {
  val matches = text.matches(regexPattern.toRegex())
  if (matches) {
    // Hacer algo
  }
}
```

El rendimiento podría mejorar si se traslada el match a una corrutina:

```kotlin
fun matchRegex(text: String, regexPattern: String) {
  lifecycleScope.launch(Dispatchers.Default) {
    val pattern = Pattern.compile(regexPattern)
    val matches = pattern.matcher(text).matches()

    withContext(Dispatchers.Main) {
      if (matches) {
        // Hacer algo
      }
    }
  }
}
```

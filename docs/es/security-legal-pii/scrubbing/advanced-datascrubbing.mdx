---
title: Depuración avanzada de datos
sidebar_order: 2
keywords:
  - pii
  - gdpr
  - personally identifiable data
  - compliance
description: >-
  Obtén información sobre cómo usar la Depuración avanzada de datos como una alternativa para redactar
  información sensible justo antes de que se guarde en Sentry.
og_image: /og-images/security-legal-pii-scrubbing-advanced-datascrubbing.png
---

Además de <PlatformLink to="/data-management/sensitive-data/">usar hooks en tu SDK</PlatformLink> o nuestras [funciones de depuración de datos del lado del servidor](/es/security-legal-pii/scrubbing/server-side-scrubbing/) para redactar datos sensibles, la Depuración avanzada de datos es una alternativa para redactar información sensible justo antes de que se guarde en Sentry. Te permite:

* Definir expresiones regulares personalizadas para detectar datos sensibles
* Ajustar con detalle qué partes de un evento se depuran
* Eliminar parcialmente o aplicar hash a datos sensibles en lugar de borrarlos

<Alert title="Prioridad de las reglas">
  Las reglas de Depuración avanzada de datos tienen prioridad sobre otros ajustes de Depuración de datos del lado del servidor. En concreto, cualquier regla avanzada se aplicará independientemente de si el campo coincidente está o no en Campos seguros.
</Alert>

<div id="a-basic-example">
  ## Un ejemplo básico
</div>

Ve a la configuración de tu proyecto u organización, haz clic en *Security and Privacy* y luego en *Advanced Data Scrubbing*.

1. Haz clic en *Add Rule*. Aparecerá un nuevo cuadro de diálogo.
2. Selecciona *Mask* como *Method*.
3. Selecciona *Credit card numbers* como *Data Type*.
4. Ingresa `$string` como *Source*.

En cuanto presiones *Save*, Sentry intentará encontrar todos los números de tarjeta de crédito en tus eventos de aquí en adelante y los reemplazará por una serie de `******`.

Para un tutorial más detallado, consulta [esta publicación del blog](https://blog.sentry.io/2020/07/02/sentry-data-wash-now-offering-advanced-scrubbing/).

Las reglas generalmente constan de tres partes:

* Un [*Method*](#methods): qué hacer.
* Un [*Data Type*](#data-types): qué buscar.
* Un [*Source*](#sources): dónde buscar.

<div id="methods">
  ## Métodos
</div>

* *Eliminar*: Elimina todo el campo. Podemos optar por establecerlo en `null`, eliminarlo por completo o reemplazarlo por una cadena vacía según las limitaciones técnicas.
* *Enmascarar*: Reemplaza todos los caracteres con `*`.
* *Hash*: Reemplaza la subcadena coincidente por un valor con hash.
* *Reemplazar*: Reemplaza la subcadena coincidente por un valor constante de *marcador de posición* (por defecto, `[Filtered]`).

<div id="data-types">
  ## Tipos de datos
</div>

* *Coincidencias de regex*: Expresión regular personalizada. Por ejemplo: `[a-zA-Z0-9]+`. Algunas notas:

  * No escribas `/[a-zA-Z0-9]+/g`, porque eso buscará los literales `/` y `/g`.
  * Para hacerla insensible a mayúsculas/minúsculas, antepone tu regex con `(?i)`.
  * Si intentas usar uno de los populares “IDE” de regex como [regex101.com](https://regex101.com/), selecciona el dialecto de Rust.
  * Escapa usando `\`; p. ej., `\*` es un `*` literal. Esto funciona para cualquiera de los siguientes caracteres: `\.+*?()|[]{}^$`.

* *Números de tarjeta de crédito*: Cualquier subcadena que parezca un número de tarjeta de crédito.

* *Campos de contraseña*: Cualquier subcadena que parezca contener contraseñas. Cualquier cadena que mencione contraseñas, tokens de autenticación o credenciales; cualquier variable llamada `password` o `auth`.

* *Direcciones IP*: Cualquier subcadena que parezca una dirección IPv4 o IPv6 válida.

* *Números IMEI*: Cualquier subcadena que parezca un IMEI o IMEISV.

* *Direcciones de correo electrónico*

* *UUID*

* *Claves PEM*: Cualquier subcadena que parezca el contenido de un archivo de clave PEM.

* *Auth en URLs*: Nombres de usuario y contraseñas en URLs como `https://user:pass@example.com/foo`.

* *Números de seguro social de EE. UU.*: Números de seguro social de 9 dígitos para EE. UU.

* *Nombres de usuario en rutas de archivos*: Por ejemplo, `myuser` en `/Users/myuser/file.txt`, `C:\Users\myuser\file.txt`, `C:\Documents and Settings\myuser\file.txt`, `/home/myuser/file.txt`, ...

* *Direcciones MAC*

* *Cualquier cosa*: Coincide con cualquier valor. Esto es útil si quieres eliminar una determinada clave JSON por ruta usando [*Sources*](#sources), sin importar el valor.

<Alert title="Sentry no sabe qué hace tu código" level="warning">
  Sentry no sabe si una variable local que parece un número de tarjeta de crédito realmente lo es. Por lo tanto, debes esperar no solo falsos positivos, sino también falsos negativos. [*Sources*](#sources) puede ayudarte a limitar el alcance en el que se ejecuta tu regla.
</Alert>

<div id="sources">
  ## Fuentes
</div>

Los selectores te permiten restringir reglas a ciertas partes del evento. Esto es útil para eliminar incondicionalmente ciertos datos según atributos del evento, y también puede usarse para probar reglas de forma conservadora con datos reales. Algunos ejemplos:

* `**` para limpiar [todos los campos PII predeterminados del evento](/es/security-legal-pii/scrubbing/server-side-scrubbing/event-pii-fields/) (otros campos, como la descripción del span, requieren selectores específicos)
* `$error.value` para limpiar el mensaje de la excepción
* `$message` para limpiar el mensaje de registro a nivel de evento
* `extra.'My Value'` para limpiar la clave `My Value` en &quot;Datos adicionales&quot;
* `extra.**` para limpiar todo en &quot;Datos adicionales&quot;
* `$http.headers.x-custom-token` para limpiar el encabezado de la solicitud `X-Custom-Token`
* `$user.ip_address` para limpiar la dirección IP del usuario
* `$frame.vars.foo` para limpiar una variable de marco del stack trace llamada `foo`
* `contexts.device.timezone` o `contexts.culture.timezone` para limpiar una clave del contexto Device
* `tags.server_name` para limpiar la etiqueta `server_name`

Todos los nombres de claves se tratan sin distinción entre mayúsculas y minúsculas.

<div id="using-an-event-id-to-auto-complete-sources">
  ### Usar un ID de evento para autocompletar fuentes
</div>

Encima del campo de entrada *Source* encontrarás otro campo para un ID de evento. Ingresar un valor allí permite un autocompletado más preciso de campos arbitrarios de *Additional Data* y nombres de variables.

El ID de evento es completamente opcional y su valor no se guarda como parte de tu configuración. La limpieza de datos se aplica siempre a todos los eventos nuevos dentro de un proyecto u organización de aquí en adelante.

<div id="advanced-source-names">
  ### Nombres avanzados de fuentes
</div>

La limpieza de datos siempre se aplica sobre la carga útil del evento sin procesar. Ten en cuenta que algunos campos en la interfaz pueden tener un nombre distinto en el esquema JSON. Al ver un evento, siempre debería haber un enlace llamado &quot;JSON&quot; que te permita ver lo mismo que ve el limpiador de datos.

Por ejemplo, lo que en la interfaz se llama &quot;Datos adicionales&quot; se denomina `extra` en la carga útil del evento. Para eliminar una clave específica llamada `foo`, escribirías:

```
[Eliminar] [cualquier cosa] de [extra.foo]
```

Otro ejemplo. Sentry reconoce dos tipos de mensajes de error: el mensaje de la excepción y el mensaje de registro de nivel superior. Aquí tienes un ejemplo de cómo se vería una carga útil de evento enviada por el SDK (y descargable desde la interfaz):

```json
{
  "logentry": {
    "formatted": "No se pudo implementar el dinglebop"
  },
  "exception": {
    "values": [
      {
        "type": "ZeroDivisionError",
        "value": "división entera o módulo entre cero"
      }
    ]
  }
}
```

Dado que el «mensaje de error» se toma del `value` de la `exception`, y el «mensaje» se toma de `logentry`, tendríamos que escribir lo siguiente para eliminar ambos del evento:

```
[Eliminar] [cualquier cosa] de [exception.values.*.value]
[Eliminar] [cualquier cosa] de [logentry.formatted]
```

<div id="boolean-logic">
  ### Lógica booleana
</div>

Puedes combinar fuentes usando lógica booleana.

* Añade el prefijo `!` para invertir la fuente. `foo` coincide con la clave JSON `foo`, mientras que `!foo` coincide con todo excepto `foo`.
* Construye la conjunción (AND) con `&&`, por ejemplo: `foo && !extra.foo` para hacer coincidir la clave `foo` excepto cuando está dentro de `extra`.
* Construye la disyunción (OR) con `||`, por ejemplo: `foo || bar` para hacer coincidir `foo` o `bar`.

<div id="wildcards">
  ### Comodines
</div>

* `**` coincide con todas las subrutas, por lo que `foo.**` abarca todas las claves JSON dentro de `foo`.
* `*` coincide con un solo elemento de la ruta, por lo que `foo.*` abarca todas las claves JSON un nivel por debajo de `foo`.

Al usar selectores `**` en reglas de limpieza, ten en cuenta que solo se aplican a los [campos de PII de eventos predeterminados](/es/security-legal-pii/scrubbing/server-side-scrubbing/event-pii-fields/). Los campos que no estén en esa lista **no** se limpiarán automáticamente, incluso si los encuentra un selector `**`.

Por ejemplo, dado el siguiente payload del evento:

```json
{
  "exception": {
    "values": [
      {
        "type": "Error",
        "value": "Se produjo un error",
        "stacktrace": {
          "frames": [
            {
              "filename": "test/example/script.js",
              "abs_path": "test/example/script.js?id=12345"
            }
          ]
        }
      }
    ]
  }
}
```

Usar la regla de limpieza `[Mask] [Anything] from [$frame.**]` no limpiará los campos `filename` o `abs_path`, ya que no están incluidos en la lista predeterminada de campos PII.

Para limpiar esos campos, usa una de las siguientes reglas:

```
[Mask] [Anything] from [$frame.*]
[Mask] [Anything] from [$frame.filename]
[Mask] [Anything] from [$frame.abs_path]
```

<div id="value-types">
  ### Tipos de valores
</div>

Selecciona subsecciones por tipo de JSON usando lo siguiente:

* `$string`: Coincide con cualquier valor de cadena
* `$number`: Coincide con cualquier valor entero o de coma flotante
* `$datetime`: Coincide con cualquier campo del evento que represente una marca de tiempo
* `$array`: Coincide con cualquier valor de matriz (array) JSON
* `$object`: Coincide con cualquier objeto JSON

Selecciona partes conocidas del esquema usando lo siguiente:

* `$error`: Coincide con una instancia única de excepción. Alias de `exception.values.*`
* `$stack`: Coincide con una instancia de traza de pila. Alias de `stacktrace || $error.stacktrace || $thread.stacktrace`
* `$frame`: Coincide con un frame en una traza de pila. Alias de `$stacktrace.frames.*`
* `$http`: Coincide con el contexto de la solicitud HTTP de un evento. Alias de `request`
* `$user`: Coincide con el contexto de usuario de un evento. Alias de `user`
* `$message`: Coincide con el mensaje de registro de nivel superior. Alias de `$logentry.formatted`
* `$logentry`: Coincide con el atributo `logentry` de un evento. Alias de `logentry`
* `$thread`: Coincide con una instancia única de hilo. Alias de `threads.values.*`
* `$breadcrumb`: Coincide con una única miga (breadcrumb). Alias de `breadcrumbs.values.*`
* `$span`: Coincide con un [span de traza](/es/product/sentry-basics/tracing/distributed-tracing/#spans). Alias de `spans.*`
* `$sdk`: Coincide con el contexto del SDK. Alias de `sdk`

Selecciona adjuntos y partes de los adjuntos; consulta [limpieza de adjuntos](../attachment-scrubbing) para más detalles.

* `$attachments`: Selector raíz para adjuntos.
* `$minidump`: Selector para adjuntos de [minidump](/es/platforms/native/guides/minidumps).
* `$binary`: Coincide con todos los campos de datos binarios en adjuntos.

<div id="escaping-special-characters">
  ### Escape de caracteres especiales
</div>

Si la clave del objeto que quieres hacer coincidir contiene espacios en blanco o caracteres especiales, puedes usar comillas para escaparla:

```
[Eliminar] [cualquier cosa] de [extra.'mi valor especial']
```

Esto coincide con la clave `my special value` en *Additional Data*.

Para escapar `'` (comilla simple) dentro de las comillas, sustitúyela por `''` (dos comillas):

```
[Eliminar] [cualquier cosa] de [extra.'mi valor '' especial']
```

Esto coincide con la clave `my special ' value` en *Datos adicionales*.

<div id="known-limitations-of-server-side-data-scrubbing">
  ## Limitaciones conocidas del saneamiento de datos del lado del servidor
</div>

Las siguientes limitaciones se aplican en general a todo saneamiento de datos del lado del servidor, ya sea el uso básico de Safe Fields o el Advanced Data Scrubbing.

* Aplicar hashing, enmascarar o reemplazar un objeto, array o número JSON (cualquier cosa que no sea una cadena) no puede hacerse en todas las circunstancias, ya que cambiaría el tipo JSON del valor y violaría suposiciones que los sistemas internos de Sentry hacen sobre el esquema de datos. En esos casos, el saneamiento de datos ignorará el *Method* y siempre eliminará/reemplazará con `null`, ya que eso siempre es seguro.

* Los sistemas internos de Sentry requieren que la dirección IP del usuario del evento sea `null` o una dirección IPv4/IPv6 válida. Si intentas aplicar hashing, enmascarar o reemplazar direcciones IP, el saneamiento de datos moverá el valor de reemplazo al ID de usuario (si aún no está establecido) para evitar incumplir este requisito y, a la vez, proporcionar datos útiles para el conteo de usuarios en un issue.

* En los stack traces, el saneamiento actúa sobre las rutas de archivo pero no sobre el nombre base del archivo. Esto violaría suposiciones en la canalización de procesamiento, resultando en una mala experiencia de usuario. En su lugar, puedes sanear el nombre base de un archivo en el propio SDK, usando la integración [`RewriteFrames`](/es/platforms/javascript/configuration/integrations/rewriteframes/) o [`beforeSend`](/es/platforms/javascript/configuration/filtering/).

<div id="data-scrubbing-for-logs">
  ## Depuración de datos para Logs
</div>

[Logs](/es/product/explore/logs/) respetará las [reglas de depuración de datos del lado del servidor](/es/security-legal-pii/scrubbing/server-side-scrubbing/#geographic-information) predeterminadas aplicadas a tus proyectos. Para añadir reglas avanzadas de depuración de datos para Logs, comienza eligiendo el conjunto de datos.

![Cuadro de diálogo para añadir una regla avanzada de depuración de datos que muestra la selección de conjunto de datos, método, tipo de datos y campos de origen](img/data_scrub_rule.png)

<Alert>
  Los comodines profundos (&quot;**&quot;) o los selectores de valor $string / $number se aplicarán en todos los conjuntos de datos. Para tipos de datos específicos, puedes seleccionar el atributo del log que debe depurarse.
</Alert>

![Campo de atributo con menú desplegable de autocompletado que muestra atributos de log disponibles](img/scrub_attribute.png)

También puedes editar las reglas de depuración existentes

![Cuadro de diálogo de edición que muestra una regla existente con un marcador de posición personalizado y configuración de atributos](img/scrub_edit.png)
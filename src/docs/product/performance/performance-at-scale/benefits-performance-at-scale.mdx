---
title: Benefits of Performance at Scale
sidebar_order: 25
redirect_from:
  - /product/sentry-basics/metrics/
  - /product/sentry-basics/sampling/
description: "Learn more about the benefits of Performance at Scale."
---

<Note>

This feature is only available on the latest version of our plans, starting from 1M reserved transactions. Anyone in your org with owner or billing-level permissions can update your plan by going to Settings > Subscription, and clicking the "Manage Subscription" button.

</Note>

At low volumes, storing all your data is feasible and reasonable, but as your application scales, storing a raw copy of everything has diminishing returns. Thatâ€™s where retention priorities come in - to help manage your application's scale while ensuring you have the comprehensive data to manage the performance and health of your application.

Sentry's [retention priorities](/product/performance/performance-at-scale/#retention-priorities) are better than using SDK sampling to control how much and which transaction data you send to Sentry. It's difficult to decide what an appropriate client-side sample rate would be, how to target and only send your most valuable transactions and this can change over time. Instead, we recommend you send us 100% of your data and let us manage this for you. Here are the benefits.

## Automatic Retention of High Quality Data

Sentry's retention priority features automatically identify and retain the highest quality transaction samples for your application at higher volumes. This allows you to scale up affordably without having to micromanage your SDK sampling configuration. Sentry will identify valuable samples to retain on your behalf, while also giving you the ability to specify the priorities that best fit your use case.

Sentry's retention priorities work best when you send high volumes of data. The more data you send, the more accurate a picture of your application we get. This makes it possible to make more precise data retention decisions and to detect and create new issues.

If possible, send us 100% of your data by setting your [tracesSampleRate](/platform-redirect/?next=/performance/) in the SDK to 1.0. Otherwise, the system will operate based on what it can see and will adapt automatically if you purchase more [Performance Units](/product/accounts/pricing/#performance-pricing).

If you want to offset overhead, (with high-volume back-end applications, for example), you can set a lower value, or switch to sampling selectively by using the <PlatformIdentifier name="traces-sampler" /> to filter your transactions based on contextual data.

## Avoid Data Gaps

If you set too low a transaction sample rate in your SDK, you might end up with performance blind spots. Just because you don't see a problem, it doesn't mean it's not there. With a low sample rate and a recurring issue, eventually Sentry will see it, but the delay could have consequences.

With **Performance at Scale**, Sentry calculates accurate metrics, like p95 response time, on the full breadth of the data you send to us. A comprehensive view means that trending, monitoring, and alerting are more accurate and you can respond to changes in your application faster. Put simply, the more data you send us, the more accurate and up to date a picture you'll have of the overall performance of your application.

## Sufficient Troubleshooting Data

Even as you sample your data, you want to be sure you have enough data for troubleshooting purposes. It doesn't make sense to store everything, but when there's a problem you need the details. Sentry automatically prioritises storing high value transactions such as those from [recent releases](/product/performance/performance-at-scale/#latest-release), [dev environments](/product/performance/performance-at-scale/#dev-environments), and deprioritizes low value data like [health checks](/product/performance/performance-at-scale/#health-checks). We also progressively decrease how much raw data is stored as your scale increases. You can be confident that the data you're getting will allow you to dig as deep as you need to fix problem areas in your application.

## Distributed Tracing

Traces can bridge across multiple software services. Each span in a trace can be represented as a `sentry-trace` header, containing the trace id, span id, and sampling details. This `sentry-trace` header can be passed to downstream services so that they can create spans that are a continuation of the trace started in the originating service.

To obtain a trace header from the span, use `ISpan#toTraceHeaders()` method. Then pass it to the downstream service. If the communication happens over HTTP, it is recommended that you set the value to the `sentry-trace` (also available as a constant `SentryTraceHeader.SENTRY_TRACE_HEADER`) HTTP header.

To create a span as a continuation of the trace retrieved from the upstream service, pass the `sentry-trace` header value to the transaction context:

```java
String sentryTrace = request.getHeader(SentryTraceHeader.SENTRY_TRACE_HEADER);
Sentry.startTransaction(TransactionContext.fromSentryTrace("name", "op", new SentryTraceHeader(sentryTrace)));
```

```kotlin
val sentryTrace = request.getHeader(SentryTraceHeader.SENTRY_TRACE_HEADER)
Sentry.startTransaction(TransactionContext.fromSentryTrace("name", "op", SentryTraceHeader(sentryTrace)))
```

<Note>

In Spring and Spring Boot integrations, Spring MVC, `RestTemplate` and OkHttp instrumentation handles trace continuations automatically.

</Note>

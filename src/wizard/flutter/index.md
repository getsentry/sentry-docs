---
name: Flutter
doc_link: https://docs.sentry.io/platforms/flutter/
support_level: production
type: framework
---

Sentry captures data by using an SDK within your applicationâ€™s runtime. Add the following to your `pubspec.yaml`:

```yml {filename:pubspec.yaml}
dependencies:
  sentry_flutter: ^{{@inject packages.version('sentry.dart.flutter') }}
```

Import `sentry_flutter` and initialize it:

```dart
import 'package:flutter/widgets.dart';
import 'package:sentry_flutter/sentry_flutter.dart';

Future<void> main() async {
  await SentryFlutter.init(
    (options) {
      options.dsn = '___PUBLIC_DSN___';
      // Set tracesSampleRate to 1.0 to capture 100% of transactions for performance monitoring.
      // We recommend adjusting this value in production.
      options.tracesSampleRate = 1.0;
    },
    appRunner: () => runApp(MyApp()),
  );

  // or define SENTRY_DSN via Dart environment variable (--dart-define)
}
```

You can configure the `SENTRY_DSN`, `SENTRY_RELEASE`, `SENTRY_DIST`, and `SENTRY_ENVIRONMENT` via the Dart environment variables passing the `--dart-define` flag to the compiler, as noted in the code sample.

Then create an intentional error, so you can test that everything is working:

```dart
import 'package:sentry/sentry.dart';

try {
  aMethodThatMightFail();
} catch (exception, stackTrace) {
  await Sentry.captureException(
    exception,
    stackTrace: stackTrace,
  );
}
```

If you're new to Sentry, use the email alert to access your account and complete a product tour.

If you're an existing user and have disabled alerts, you won't receive this email.

## Performance

You'll be able to monitor the performance of your app using the SDK.
For example:

```dart
import 'package:sentry/sentry.dart';

final transaction = Sentry.startTransaction('processOrderBatch()', 'task');

try {
  await processOrderBatch(transaction);
} catch (exception) {
  transaction.throwable = exception;
  transaction.status = SpanStatus.internalError();
} finally {
  await transaction.finish();
}

Future<void> processOrderBatch(ISentrySpan span) async {
  // span operation: task, span description: operation
  final innerSpan = span.startChild('task', description: 'operation');

  try {
    // omitted code
  } catch (exception) {
    innerSpan.throwable = exception;
    innerSpan.status = SpanStatus.notFound();
  } finally {
    await innerSpan.finish();
  }
}
```

To learn more about the API and automatic instrumentations, check out the [performance documentation](/platforms/flutter/performance/instrumentation/) .

## Debug Symbols

We offer a range of methods to provide Sentry with debug symbols so that you can see symbolicated stack traces and triage issues faster.

Complete stack traces will be shown for your Dart error by default, but if you use [`split-debug-info`](https://flutter.dev/docs/perf/app-size#reducing-app-size) and [`obfuscate`](https://flutter.dev/docs/deployment/obfuscate), you'll need to [upload the debug information files](/platforms/flutter/upload-debug/) generated by the `flutter` build.

You'll also need to [upload the debug information files](/platforms/flutter/upload-debug/) generated by the `flutter` build for iOS, macOS, and Android NDK native crashes.

## Source Context

If Sentry has access to your application's source code, it can show snippets of code (_source context_) around the location of stack frames, which helps to quickly pinpoint problematic code.

To enable source context, you'll need to upload debug symbols to Sentry by following the [Uploading Source Code Context for Flutter Android, iOS, and macOS](/platforms/flutter/upload-debug/#uploading-source-code-context-for-flutter-android-ios-and-macos) guide.

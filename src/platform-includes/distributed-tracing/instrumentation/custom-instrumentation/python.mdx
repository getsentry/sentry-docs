<Alert title="Note" level="note">

There's no additional set up needed to use distributed tracing with the following frameworks: [Django](/platforms/python/guides/django/distributed-tracing/instrumentation/automatic-instrumentation/), [FastAPI](/platforms/python/guides/fastapi/distributed-tracing/instrumentation/automatic-instrumentation/), [Flask](/platforms/python/guides/flask/distributed-tracing/instrumentation/automatic-instrumentation/), [Bottle](/platforms/python/guides/bottle/distributed-tracing/instrumentation/automatic-instrumentation/), [Falcon](/platforms/python/guides/falcon/distributed-tracing/instrumentation/automatic-instrumentation/), [Pyramid](/platforms/python/guides/pyramid/distributed-tracing/instrumentation/automatic-instrumentation/), [Quart](/platforms/python/guides/quart/distributed-tracing/instrumentation/automatic-instrumentation/), [Starlette](/platforms/python/guides/starlette/distributed-tracing/instrumentation/automatic-instrumentation/), [Tornado](/platforms/python/guides/tornado/distributed-tracing/instrumentation/automatic-instrumentation/).

If you are using one of the frameworks listed above, see the <PlatformLink to="/distributed-tracing/instrumentation/automatic-instrumentation/">Automatic Instrumentation</PlatformLink> page for how to configure distributed tracing.

</Alert>

Please read the note above. If you have a vanilla Python project or use an unsupported framework you can still add distributed tracing to your project but need to it "by hand".

Two things need to be done for distributed tracing to work:

- When receiving incoming requests, extract and store incoming tracing information.
- When doing outgoing requests, inject tracing information to the outgoing request.

To learn more, see our <PlatformLink to="/distributed-tracing/">Distributed Tracing</PlatformLink> docs.

## Extract Incoming Tracing Information

Incoming tracing information has to be extracted and stored in memory for later use. Sentry provides the `continue_trace` function to help with this.
Incoming tracing information can come from different places:

- In a web environment it will be sent with HTTP headers, for example, by another Sentry SDK used in your frontend project.
- In a job queue, like Celery, it can be retrieved from meta or header variables.
- You also can pick up tracing information from environment variables.

Here's an example of how to extract and store incoming tracing information using `continue_trace`:

```python
import sentry_sdk
from my_project import get_incoming_headers_as_dict

headers = get_incoming_headers_as_dict()

sentry_sdk.continue_trace(headers)
```

In this example, `get_incoming_headers_as_dict()` returns a dictionary that contains tracing information. This dictionary would contain information from HTTP headers, environment variables, or any other mechanism your project uses to communicate with the outside world.

Sentry's `continue_from_trace()` will extract the given headers and try to find the `sentry-trace` and `baggage` headers and it will store them in memory for later use.

### Performance Monitoring in Combination With Distributed Tracing

If you want to add new transactions and spans to the trace described in the incoming headers you can do this. `continue_from_trace()` returns a transaction object that you can use to start a custom transaction:

```python
import sentry_sdk
from my_project import get_incoming_headers_as_dict, do_some_heavy_lifting

headers = get_incoming_headers_as_dict()

transaction = sentry_sdk.continue_trace(headers)

with start_transaction(transaction=transaction) as transaction:
    do_some_heavy_lifting()
```

See the Performance docs on <PlatformLink to="/performance/instrumentation/custom-instrumentation/">Custom Instrumentation</PlatformLink> to learn more about using custom transactions and spans to measure the performance of your code.

## Inject Tracing Information to Outgoing Requests

For distributed tracing to work, the two headers that you extracted and stored, `sentry-trace` and `baggage`, must be added to outgoing requests.

If you are sending outgoing HTTP requests with [Requests](https://requests.readthedocs.io/en/latest/), [AIOHTTP](https://docs.aiohttp.org/en/stable/), the low level [http.client](https://docs.python.org/3/library/http.client.html), or [httplib](https://docs.python.org/2/library/httplib.html) on Python 2, this tracing information is automatically added to outgoing requests.

If you are do outgoing requests in another way you can generate the tracing information like follows:

```python
import sentry_sdk
from my_project import make_an_outgoing_request

headers = {}
headers["sentry-trace"] = sentry_sdk.get_traceparent()
headers["baggage"] = sentry_sdk.get_baggage()

make_an_outgoing_request(to="https://example.com", headers=headers)
```

In this example, tracing information is propagated to the project running at `https://example.com`. If this project uses the Sentry Python SDK, it will extract and save the tracing information for later use.

The two services are now connected with your custom distributed tracing implementation.

### Inject Tracing Information Into Rendered HTML

To propagate tracing information into JavaScript running in rendered HTML you have to inject HTML `meta` tags for `sentry-trace` and `baggage` data into your rendered HTML. Here's an example:

```python
import sentry_sdk
from my_project import render

meta = ""
meta += '<meta name="sentry-trace" content="%s">' % sentry_sdk.get_traceparent()
meta += '<meta name="baggage" content="%s">' % sentry_sdk.get_baggage()

html = """
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        {additional_meta}
    </head>
    <body>
        <p>This is a website.</p>
    </body>
</html>
""".format(additional_meta=meta)

render(html)

```

## Verification

If you make outgoing requests from your project to other services, check if the headers `sentry-trace` and `baggage` are present in the request. If so, distributed tracing is working.

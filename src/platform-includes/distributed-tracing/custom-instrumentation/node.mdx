On this page you will learn how to manually propagate trace information into and out of your JavaScript application.

In the following cases, distributed tracing will be set up automatically for you:

- You have our <PlatformLink to="/performance/">performance monitoring feature</PlatformLink> turned on.
- You are using one of the platforms that include distributed tracing out of the box:
  - `@sentry/nextjs`
  - `@sentry/sveltekit`
  - `@sentry/remix`
  - `@sentry/astro`

If you are using a different package, and have not enabled performance monitoring, you can manually set up your application for distributed tracing to work.

## Enabling Distributed Tracing without Performance

You can setup the `Http` integration in combination with `tracesSampleRate: 0` to enable distributed tracing without performance monitoring:

```javascript
Sentry.init({
  dsn: "___PUBLIC_DSN___",
  integrations: [new Sentry.Integrations.Http({ tracing: true })],
  tracesSampleRate: 0,
});
```

## Enabling Distributed Tracing without `Http` Integration

If you do not want to use the `Http` integration in conjuction with `tracing: true`, you can manually extract and inject tracing information into your application. For this, you must:

- Extract and store incoming tracing information from incoming request headers or similar.
- Inject tracing information to the outgoing request when sending outgoing requests.

To learn more, see our <PlatformLink to="/usage/distributed-tracing/">Distributed Tracing</PlatformLink> docs.

### Extracting Incoming Tracing Information

Incoming tracing information has to be extracted and stored in memory for later use. Sentry provides the `continueTrace()` function to help you with this. Incoming tracing information can come from different places:

- In a web environment, it's sent with HTTP headers, for example, by another Sentry SDK used in your frontend project.
- In a job queue, it can be retrieved from meta or header variables.
- You also can pick up tracing information from environment variables.

Here's an example of how to extract and store incoming tracing information using `continueTrace()`:

```javascript
const sentryTrace = getRequestHeader("sentry-trace");
const baggage = getRequestHeader("baggage");

const requestTransaction = Sentry.continueTrace(
  { sentryTrace, baggage },
  (transactionContext) => {
    return Sentry.startTransaction({
      ...transactionContext,
      name: "my request",
      op: "http.server",
    });
  }
);
```

In this example, we create a new transaction that is attached to the trace specified in the `sentry-trace` and `baggage` headers.

### Inject Tracing Information to Outgoing Requests

For distributed tracing to work, the two headers that you extracted and stored in the `requestTransaction`, `sentry-trace` and `baggage`, must be added to outgoing http/fetch requests.

Here's an example of how to collect and inject this tracing information to outgoing requests:

```javascript
// Create `sentry-trace` header
const sentryTraceHeader = requestTransaction.toTraceparent();

// Create `baggage` header
const dynamicSamplingContext = requestTransaction.getDynamicSamplingContext();
const sentryBaggageHeader = dynamicSamplingContextToSentryBaggageHeader(
  dynamicSamplingContext
);

// Make outgoing request
fetch("https://example.com", {
  method: "GET",
  headers: {
    baggage: sentryBaggageHeader,
    "sentry-trace": sentryTraceHeader,
  },
}).then((response) => {
  // ...
});
```

In this example, tracing information is propagated to the project running at `https://example.com`. If this project uses a Sentry SDK, it will extract and save the tracing information for later use.

The two services are now connected with your custom distributed tracing implementation.

## Verification

If you make outgoing requests from your project to other services, check if the headers `sentry-trace` and `baggage` are present in the request. If so, distributed tracing is working.

[
  {
    "type": "Gauge",
    "name": "async_pool.activity",
    "description": "Tracks the activity of the async pool.\n\nThe activity is a value between 0.0 and 100.0 which determines how busy is the pool\nw.r.t. to its provisioned capacity.\n\nThis metric is tagged with:\n- `pool`: the name of the pool.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "async_pool.finished_tasks",
    "description": "Tracks the number of tasks driven to completion by the async pool.\n\nThis metric is tagged with:\n- `pool`: the name of the pool.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "async_pool.queue_size",
    "description": "Tracks the number of futures waiting to be executed in the pool's queue.\n\nUseful for understanding the backlog of work and identifying potential bottlenecks.\n\nThis metric is tagged with:\n- `pool`: the name of the pool.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "async_pool.utilization",
    "description": "Tracks the utilization of the async pool.\n\nThe utilization is a value between 0.0 and 100.0 which determines how busy the pool is doing\nCPU-bound work.\n\nThis metric is tagged with:\n- `pool`: the name of the pool.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "attachment.upload",
    "description": "The number of times an upload of an attachment occurs.\n\nThis metric is tagged with:\n- `result`: `success` or the failure reason.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Gauge",
    "name": "attachment.upload.concurrent",
    "description": "Number of attachment uploads currently in flight.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Gauge",
    "name": "buffer.disk_used",
    "description": "The used disk for the buffer.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "buffer.drain.duration",
    "description": "Timing in milliseconds for the time it takes for the buffer to drain its envelopes.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "buffer.envelope_body_size",
    "description": "The amount of bytes in the item payloads of an envelope pushed to the envelope buffer.\n\nThis is not quite the same as the actual size of a serialized envelope, because it ignores\nthe envelope header and item headers.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "buffer.envelope_size",
    "description": "Size of a serialized envelope pushed to the envelope buffer.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "buffer.envelope_size.compressed",
    "description": "Size of a compressed envelope pushed to the envelope buffer.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "buffer.envelopes_compression",
    "description": "Timing in milliseconds for the time it takes for an envelope to be compressed.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "buffer.envelopes_count",
    "description": "Number of elements in the envelope buffer across all the stacks.\n\nThis metric is tagged with:\n- `storage_type`: The type of storage used in the envelope buffer.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "buffer.envelopes_decompression",
    "description": "Timing in milliseconds for the time it takes for an envelope to be decompressed.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "buffer.envelopes_serialization",
    "description": "Timing in milliseconds for the time it takes for an envelope to be serialized.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "buffer.initialization.duration",
    "description": "Timing in milliseconds for the time it takes for initialize the buffer.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "buffer.peek.duration",
    "description": "Timing in milliseconds for the time it takes for the buffer to peek.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "buffer.pop.duration",
    "description": "Timing in milliseconds for the time it takes for the buffer to pop.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "buffer.project_changed_event",
    "description": "Number of project changed updates received by the buffer.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "buffer.project_pending",
    "description": "Number of times one or more projects of an envelope were pending when trying to pop\ntheir envelope.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "buffer.push.duration",
    "description": "Timing in milliseconds for the time it takes for the buffer to push.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "buffer.spool.duration",
    "description": "Timing in milliseconds for the time it takes for the buffer to pack & spool a batch.\n\nContains the time it takes to pack multiple envelopes into a single memory blob.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "buffer.spooled_envelopes",
    "description": "Number of envelopes spool to disk.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "buffer.stack_count",
    "description": "The number of individual stacks in the priority queue.\n\nPer combination of `(own_key, sampling_key)`, a new stack is created.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "buffer.try_pop",
    "description": "Number of times an envelope from the buffer is trying to be popped.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "buffer.unspool.duration",
    "description": "Timing in milliseconds for the time it takes for the buffer to unspool data from disk.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "buffer.unspooled_envelopes",
    "description": "Number of envelopes unspooled from disk.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "buffer.write.duration",
    "description": "Timing in milliseconds for the time it takes for the buffer to spool data to SQLite.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "cogs.usage",
    "description": "All COGS tracked values.\n\nThis metric is tagged with:\n- `resource_id`: The COGS resource id.\n- `app_feature`: The COGS app feature.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "envelope.check_nested_spans",
    "description": "Timing in milliseconds to count spans in a serialized transaction payload.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "event.accepted",
    "description": "Number of envelopes accepted in the current time slot.\n\nThis represents requests that have successfully passed rate limits and filters, and have\nbeen sent to the upstream.\n\nThis metric is tagged with:\n- `handling`: Either `\"success\"` if the envelope was handled correctly, or `\"failure\"` if\nthere was an error or bug.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "event.corrupted",
    "description": "Number of Events that had corrupted (unprintable) event attributes.\n\nThis currently checks for `environment` and `release`, for which we know that\nsome SDKs may send corrupted values.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "event.item_bytes",
    "description": "Number of bytes we processed per envelope item.\n\nThis metric is tagged with:\n- `item_type`: The type of the items being counted.\n- `is_container`: Whether this item is a container holding multiple items.\n- `sdk`: The name of the Sentry SDK sending the envelope. This tag is only set for\nSentry's SDKs and defaults to \"proprietary\".",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "event.item_size",
    "description": "The number of bytes received by Relay for each individual envelope item type.\n\nThis metric is tagged with:\n- `item_type`: The type of the items being counted.\n- `is_container`: Whether this item is a container holding multiple items.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "event.items",
    "description": "Number of total envelope items we received.\n\nNote: This does not count raw items, it counts the logical amount of items,\ne.g. a single item container counts all its contained items.\n\nThis metric is tagged with:\n- `item_type`: The type of the items being counted.\n- `is_container`: Whether this item is a container holding multiple items.\n- `sdk`: The name of the Sentry SDK sending the envelope. This tag is only set for\nSentry's SDKs and defaults to \"proprietary\".",
    "features": []
  },
  {
    "type": "Counter",
    "name": "event.opentelemetry",
    "description": "Number of Events with an OpenTelemetry Context\n\nThis metric is tagged with:\n- `platform`: The event's platform, such as `\"javascript\"`.\n- `sdk`: The name of the Sentry SDK sending the transaction. This tag is only set for\nSentry's SDKs and defaults to \"proprietary\".",
    "features": []
  },
  {
    "type": "Timer",
    "name": "event.processing_time",
    "description": "Time in milliseconds spent in synchronous processing of envelopes.\n\nThis timing covers the end-to-end processing in the CPU pool and comprises:\n\n- `event_processing.deserialize`\n- `event_processing.pii`\n- `event_processing.serialization`\n\nWith Relay in processing mode, this also includes the following timings:\n\n- `event_processing.process`\n- `event_processing.filtering`\n- `event_processing.rate_limiting`",
    "features": []
  },
  {
    "type": "Counter",
    "name": "event.protocol",
    "description": "Number of events that hit any of the store-like endpoints: Envelope, Store, Security,\nMinidump, Unreal.\n\nThe events are counted before they are rate limited, filtered, or processed in any way.\n\nThis metric is tagged with:\n- `version`: The event protocol version number defaulting to `7`.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "event.rejected",
    "description": "Number of envelopes rejected in the current time slot.\n\nThis includes envelopes being rejected because they are malformed or any other errors during\nprocessing (including filtered events, invalid payloads, and rate limits).\n\nTo check the rejection reason, check `events.outcomes`, instead.\n\nThis metric is tagged with:\n- `handling`: Either `\"success\"` if the envelope was handled correctly, or `\"failure\"` if\nthere was an error or bug.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "event.spans",
    "description": "The number of spans per processed transaction event.\n\nThis metric is tagged with:\n- `platform`: The event's platform, such as `\"javascript\"`.\n- `sdk`: The name of the Sentry SDK sending the transaction. This tag is only set for\nSentry's SDKs and defaults to \"proprietary\".",
    "features": []
  },
  {
    "type": "Timer",
    "name": "event.total_time",
    "description": "Total time in milliseconds an envelope spends in Relay from the time it is received until it\nfinishes processing and has been submitted to the upstream.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "event.transaction",
    "description": "The number of transaction events processed by the source of the transaction name.\n\nThis metric is tagged with:\n- `platform`: The event's platform, such as `\"javascript\"`.\n- `source`: The source of the transaction name on the client. See the [transaction source\ndocumentation](https://develop.sentry.dev/sdk/event-payloads/properties/transaction_info/)\nfor all valid values.\n- `contains_slashes`: Whether the transaction name contains `/`. We use this as a heuristic\nto represent URL transactions.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "event.transaction_name_changes",
    "description": "The number of transaction events processed grouped by transaction name modifications.\nThis metric is tagged with:\n- `source_in`: The source of the transaction name before normalization.\nSee the [transaction source\ndocumentation](https://develop.sentry.dev/sdk/event-payloads/properties/transaction_info/)\nfor all valid values.\n- `change`: The mechanism that changed the transaction name.\nEither `\"none\"`, `\"pattern\"`, `\"rule\"`, or `\"both\"`.\n- `source_out`: The source of the transaction name after normalization.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "event.wait_time",
    "description": "Time spent between the start of request handling and processing of the envelope.\n\nThis includes streaming the request body, scheduling overheads, project config fetching,\nbatched requests and congestions in the internal processor. This does not include delays in\nthe incoming request (body upload) and skips all envelopes that are fast-rejected.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "event_processing.deserialize",
    "description": "Time in milliseconds spent deserializing an event from JSON bytes into the native data\nstructure on which Relay operates.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "event_processing.filtering",
    "description": "Time in milliseconds spent running inbound data filters on an event.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "event_processing.normalization",
    "description": "Time in milliseconds spent running normalization on an event. Normalization\nhappens before envelope filtering and metric extraction.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "event_processing.pii",
    "description": "Time in milliseconds spent in data scrubbing for the current event. Data scrubbing happens\nlast before serializing the event back to JSON.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "event_processing.rate_limiting",
    "description": "Time in milliseconds spent checking for organization, project, and DSN rate limits.\n\nNot all events reach this point. After an event is rate limited for the first time, the rate\nlimit is cached. Events coming in after this will be discarded earlier in the request queue\nand do not reach the processing queue.\n\nThis metric is tagged with:\n- `type`: The type of limiter executed, `cached` or `consistent`.\n- `unit`: The item/unit of work which is being rate limited, only available for new\nprocessing pipelines.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "event_processing.serialization",
    "description": "Time spent converting the event from its in-memory reprsentation into a JSON string.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "events.outcome_quantity",
    "description": "The number of individual outcomes including their quantity.\n\nWhile [`RelayCounters::Outcomes`] tracks the number of times aggregated outcomes\nhave been emitted, this counter tracks the total quantity of individual outcomes.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "events.outcomes",
    "description": "Number of outcomes and reasons for rejected Envelopes.\n\nThis metric is tagged with:\n- `outcome`: The basic cause for rejecting the event.\n- `reason`: A more detailed identifier describing the rule or mechanism leading to the\noutcome.\n- `to`: Describes the destination of the outcome. Can be either 'kafka' (when in\nprocessing mode) or 'http' (when outcomes are enabled in an external relay).\n\nPossible outcomes are:\n- `filtered`: Dropped by inbound data filters. The reason specifies the filter that\nmatched.\n- `rate_limited`: Dropped by organization, project, or DSN rate limit, as well as exceeding\nthe Sentry plan quota. The reason contains the rate limit or quota that was exceeded.\n- `invalid`: Data was considered invalid and could not be recovered. The reason indicates\nthe validation that failed.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "global_config.fetch",
    "description": "Number of global config fetches from upstream. Only 2XX responses are\nconsidered and ignores send errors (e.g. auth or network errors).\n\nThis metric is tagged with:\n- `success`: whether deserializing the global config succeeded.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "global_config.requests.duration",
    "description": "Total time spent to send a request and receive the response from upstream.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "health.message.duration",
    "description": "Timing in milliseconds for handling and responding to a health check request.\n\nThis metric is tagged with:\n- `type`: The type of the health check, `liveness` or `readiness`.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "health.system_memory.total",
    "description": "The total system memory.\n\nRelay uses the same value for its memory health check.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "health.system_memory.used",
    "description": "The currently used memory by the entire system.\n\nRelay uses the same value for its memory health check.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "http_queue.size",
    "description": "The number of upstream requests queued up for sending.\n\nRelay employs connection keep-alive whenever possible. Connections are kept open for _15_\nseconds of inactivity or _75_ seconds of activity. If all connections are busy, they are\nqueued, which is reflected in this metric.\n\nThis metric is tagged with:\n- `priority`: The queueing priority of the request, either `\"high\"` or `\"low\"`. The\npriority determines precedence in executing requests.\n\nThe number of concurrent connections can be configured with:\n- `limits.max_concurrent_requests` for the overall number of connections\n- `limits.max_concurrent_queries` for the number of concurrent high-priority requests",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.in_flight_count",
    "description": "The number of messages waiting to be sent to, or acknowledged by, the broker.\n\nSee <https://docs.confluent.io/platform/7.5/clients/librdkafka/html/rdkafka_8h.html#ad4b3b7659cf9a79d3353810d6b625bb7>.\n\nThis metric is tagged with:\n- `topic`: The Kafka topic being produced to.\n- `variant`: The Kafka message variant.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "kafka.message_size",
    "description": "Size of emitted kafka message in bytes.\n\nThis metric is tagged with:\n- `topic`: The Kafka topic being produced to.\n- `variant`: The Kafka message variant.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.broker.connects",
    "description": "The number of connection attempts, including successful and failed attempts, and name resolution failures.\n\nThis metric is tagged with:\n- `broker_name`: The broker hostname, port, and ID, in the form HOSTNAME:PORT/ID.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.broker.disconnects",
    "description": "The number of disconnections, whether triggered by the broker, the network, the load balancer, or something else.\n\nThis metric is tagged with:\n- `broker_name`: The broker hostname, port, and ID, in the form HOSTNAME:PORT/ID.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.broker.int_latency.avg",
    "description": "Average internal producer queue latency, in milliseconds.\n\nThis metric is tagged with:\n- `broker_name`: The broker hostname, port, and ID, in the form HOSTNAME:PORT/ID.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.broker.int_latency.p99",
    "description": "99th percentile internal producer queue latency, in milliseconds.\n\nThis metric is tagged with:\n- `broker_name`: The broker hostname, port, and ID, in the form HOSTNAME:PORT/ID.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.broker.outbuf.messages",
    "description": "The number of messages awaiting transmission to the broker.\n\nThis metric is tagged with:\n- `broker_name`: The broker hostname, port, and ID, in the form HOSTNAME:PORT/ID.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.broker.outbuf.requests",
    "description": "The number of requests awaiting transmission to the broker.\n\nThis metric is tagged with:\n- `broker_name`: The broker hostname, port, and ID, in the form HOSTNAME:PORT/ID.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.broker.outbuf_latency.avg",
    "description": "Average output buffer latency, in milliseconds.\n\nThis metric is tagged with:\n- `broker_name`: The broker hostname, port, and ID, in the form HOSTNAME:PORT/ID.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.broker.outbuf_latency.p99",
    "description": "99th percentile output buffer latency, in milliseconds.\n\nThis metric is tagged with:\n- `broker_name`: The broker hostname, port, and ID, in the form HOSTNAME:PORT/ID.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.broker.rtt.avg",
    "description": "Average round-trip time to the broker, in milliseconds.\n\nThis metric is tagged with:\n- `broker_name`: The broker hostname, port, and ID, in the form HOSTNAME:PORT/ID.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.broker.rtt.p99",
    "description": "99th percentile round-trip time to the broker, in milliseconds.\n\nThis metric is tagged with:\n- `broker_name`: The broker hostname, port, and ID, in the form HOSTNAME:PORT/ID.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.broker.tx",
    "description": "Total number of requests sent to the broker.\n\nThis metric is tagged with:\n- `broker_name`: The broker hostname, port, and ID, in the form HOSTNAME:PORT/ID.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.broker.txbytes",
    "description": "Total number of bytes sent to the broker.\n\nThis metric is tagged with:\n- `broker_name`: The broker hostname, port, and ID, in the form HOSTNAME:PORT/ID.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.message_count",
    "description": "The current number of messages in producer queues.\n\nThis metric is tagged with:\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.message_count_max",
    "description": "The maximum number of messages allowed in the producer queues.\n\nThis metric is tagged with:\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.message_size",
    "description": "The current total size of messages in producer queues.\n\nThis metric is tagged with:\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.message_size_max",
    "description": "The maximum total size of messages allowed in the producer queues.\n\nThis metric is tagged with:\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "kafka.stats.txmsgs",
    "description": "The total number of messages transmitted (produced) to all brokers.\n\nThis metric is tagged with:\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "metrics.aggregator.message.duration",
    "description": "Timing in milliseconds for processing a task in the aggregator service.\n\nThis metric is tagged with:\n- `task`: The task being executed by the aggregator.\n- `aggregator`: The name of the aggregator.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "metrics.buckets",
    "description": "The total number of metric buckets in Relay's metrics aggregator.\n\nThis metric is tagged with:\n- `aggregator`: The name of the metrics aggregator (usually `\"default\"`).\n- `namespace`: The namespace of the metric.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "metrics.buckets.batches_per_partition",
    "description": "The number of batches emitted per partition.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "metrics.buckets.cost",
    "description": "The total storage cost of metric buckets in Relay's metrics aggregator.\n\nThis metric is tagged with:\n- `aggregator`: The name of the metrics aggregator (usually `\"default\"`).\n- `namespace`: The namespace of the metric.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "metrics.buckets.dropped",
    "description": "Incremented every time a bucket is dropped.\n\nThis should only happen when a project state is invalid during graceful shutdown.\n\nThis metric is tagged with:\n- `aggregator`: The name of the metrics aggregator (usually `\"default\"`).",
    "features": []
  },
  {
    "type": "Counter",
    "name": "metrics.buckets.flush.cost",
    "description": "Incremented with the cost of a partition for every aggregator flush.\n\nThis metric is tagged with:\n- `aggregator`: The name of the metrics aggregator (usually `\"default\"`).\n- `namespace`: The namespace of the metric.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "metrics.buckets.flush.count",
    "description": "Incremented for every aggregator flush.\n\nThis metric is tagged with:\n- `aggregator`: The name of the metrics aggregator (usually `\"default\"`).",
    "features": []
  },
  {
    "type": "Counter",
    "name": "metrics.buckets.merge.hit",
    "description": "Incremented every time two buckets or two metrics are merged.\n\nThis metric is tagged with:\n- `aggregator`: The name of the metrics aggregator (usually `\"default\"`).\n- `namespace`: The namespace of the metric.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "metrics.buckets.merge.miss",
    "description": "Incremented every time a bucket is created.\n\nThis metric is tagged with:\n- `aggregator`: The name of the metrics aggregator (usually `\"default\"`).\n- `namespace`: The namespace of the metric.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "metrics.buckets.parsing_failed",
    "description": "Number of times that parsing a metrics bucket item from an envelope failed.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "metrics.buckets.partition_keys",
    "description": "Distribution of flush buckets over partition keys.\n\nThe distribution of buckets should be even.\nIf it is not, this metric should expose it.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "metrics.buckets.per_batch",
    "description": "The number of buckets in a batch emitted.\n\nThis corresponds to the number of buckets that will end up in an envelope.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "metrics.delay.count",
    "description": "The amount of buckets counted for the [`Self::MetricDelaySum`] metric.\n\nThis metric is tagged with:\n- `namespace`: the metric namespace.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Gauge",
    "name": "metrics.delay.max",
    "description": "Maximum delay of a metric bucket in seconds.\n\nThe maximum is measured from initial creation of the bucket in an internal Relay\nuntil it is produced to Kafka.\n\nThis metric is tagged with:\n- `namespace`: the metric namespace.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Counter",
    "name": "metrics.delay.sum",
    "description": "The total delay of metric buckets in seconds.\n\nThe delay is measured from initial creation of the bucket in an internal Relay\nuntil it is produced to Kafka.\n\nUse [`Self::MetricDelayCount`] to calculate the average delay.\n\nThis metric is tagged with:\n- `namespace`: the metric namespace.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Timer",
    "name": "metrics.router.message.duration",
    "description": "Timing in milliseconds for processing a message in the metric router service.\n\nThis metric is tagged with:\n- `message`: The type of message that was processed.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "metrics.transaction_name",
    "description": "Count extraction of transaction names. Tag with the decision to drop / replace / use original.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "outcomes.aggregator.flush_time",
    "description": "The time it takes the outcome aggregator to flush aggregated outcomes.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "partition_splits",
    "description": "Measures how many splits were performed when sending out a partition.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "processing.event.produced",
    "description": "Number of messages placed on the Kafka queues.\n\nWhen Relay operates as Sentry service and an Envelope item is successfully processed, each\nEnvelope item results in a dedicated message on one of the ingestion topics on Kafka.\n\nThis metric is tagged with:\n- `event_type`: The kind of message produced to Kafka.\n- `namespace` (only for metrics): The namespace that the metric belongs to.\n- `is_segment` (only for event_type span): `true` the span is the root of a segment.\n- `has_parent` (only for event_type span): `false` if the span is the root of a trace.\n- `platform` (only for event_type span): The platform from which the span was spent.\n- `metric_type` (only for event_type metric): The metric type, counter, distribution,\ngauge or set.\n- `metric_encoding` (only for event_type metric): The encoding used for distribution and\nset metrics.\n\nThe message types can be:\n\n- `event`: An error or transaction event. Error events are sent to `ingest-events`,\ntransactions to `ingest-transactions`, and errors with attachments are sent to\n`ingest-attachments`.\n- `attachment`: An attachment file associated with an error event, sent to\n`ingest-attachments`.\n- `user_report`: A message from the user feedback dialog, sent to `ingest-events`.\n- `session`: A release health session update, sent to `ingest-sessions`.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Counter",
    "name": "processing.feedback_attachments",
    "description": "The number of attachments processed in the same envelope as a user_report_v2 event.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "processing.playstation",
    "description": "The amount of times PlayStation processing was attempted.",
    "features": [
      "sentry",
      "processing"
    ]
  },
  {
    "type": "Timer",
    "name": "processor.message.duration",
    "description": "Timing in milliseconds for processing a message in the internal CPU pool.\n\nThis metric is tagged with:\n\n- `message`: The type of message that was processed.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "processor.rate_limit_buckets",
    "description": "Temporary timing metric for how much time was spent evaluating span and transaction\nrate limits using the `RateLimitBuckets` message in the processor.\n\nThis metric is tagged with:\n- `category`: The data category evaluated.\n- `limited`: Whether the batch is rate limited.\n- `count`: How many items matching the data category are contained in the batch.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Counter",
    "name": "producer.enqueue.error",
    "description": "Number of messages that failed to be enqueued in the Kafka producer's memory buffer.\n\nThese errors include, for example, _\"UnknownTopic\"_ errors when attempting to send a\nmessage a topic that does not exist.\n\nThis metric is tagged with:\n- `topic`: The Kafka topic being produced to.\n- `variant`: The Kafka message variant.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "producer.partition_key.rate_limit",
    "description": "Number of messages that were written to the wrong partition because of configured rate limits.\n\nEach topic in Relay can optionally be configured with a per-partition-key rate limit. This\nrate limit does not drop messages, but instead disables semantic partitioning. Everytime\nthis happens for a message, this counter is incremented.\n\nThis metric is tagged with:\n- `topic`: The Kafka topic being produced to.\n- `variant`: The Kafka message variant.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "producer.produce_status.error",
    "description": "Number of failed message produce operations.\n\nThis metric is tagged with:\n- `topic`: The Kafka topic being produced to.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "producer.produce_status.success",
    "description": "Number of successful message produce operations.\n\nThis metric is tagged with:\n- `topic`: The Kafka topic being produced to.\n- `producer_name`: The configured producer name/deployment identifier.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "project_cache.eviction",
    "description": "Number of evicted stale projects from the cache.\n\nRelay scans the in-memory project cache for stale entries in a regular interval configured\nby `cache.eviction_interval`.\n\nThe cache duration for project states can be configured with the following options:\n\n- `cache.project_expiry`: The time after which a project state counts as expired. It is\nautomatically refreshed if a request references the project after it has expired.\n- `cache.project_grace_period`: The time after expiry at which the project state will still\nbe used to ingest events. Once the grace period expires, the cache is evicted and new\nrequests wait for an update.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "project_cache.fetch.duration",
    "description": "Total time spent from starting to fetch a project config update to completing the fetch.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "project_cache.fetches.size",
    "description": "The number of scheduled and in progress fetches in the project cache.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "project_cache.latency",
    "description": "Latency of project config updates until they reach Relay.\n\nThe metric is calculated by using the creation timestamp of the project config\nand when Relay updates its local cache with the new project config.\n\nNo metric is emitted when Relay fetches a project config for the first time.\n\nThis metric is tagged with:\n- `delay`: Bucketed amount of seconds passed between fetches.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "project_cache.refresh",
    "description": "Number of refreshes for stale projects in the cache.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "project_cache.schedule",
    "description": "Number of times a project had a fetch scheduled.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "project_cache.size",
    "description": "Number of project states currently held in the in-memory project cache.\n\nThe cache duration for project states can be configured with the following options:\n\n- `cache.project_expiry`: The time after which a project state counts as expired. It is\nautomatically refreshed if a request references the project after it has expired.\n- `cache.project_grace_period`: The time after expiry at which the project state will still\nbe used to ingest events. Once the grace period expires, the cache is evicted and new\nrequests wait for an update.\n\nThere is no limit to the number of cached projects.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "project_cache.task.duration",
    "description": "Timing in milliseconds for processing a task in the project cache service.\n\nThis metric is tagged with:\n- `task`: The type of the task the project cache does.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "project_state.attempts",
    "description": "Number of attempts required to fetch the config for a given project key.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "project_state.decompression",
    "description": "Time in milliseconds required to decompress a project config from redis.\n\nNote that this also times the cases where project config is uncompressed,\nin which case the timer should be very close to zero.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Counter",
    "name": "project_state.metrics.no_project",
    "description": "The amount of times metrics of a project have been flushed without the project being\nfetched/available.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "project_state.pending",
    "description": "Number of projects in the in-memory project cache that are waiting for their state to be\nupdated.\n\nSee `project_cache.size` for more description of the project cache.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "project_state.received",
    "description": "Number of project states **returned** from the upstream for each batch request.\n\nIf multiple batches are updated concurrently, this metric is reported multiple times.\n\nSee `project_cache.size` for more description of the project cache.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "project_state.redis.requests",
    "description": "Number of times a project state is requested from the central Redis cache.\n\nThis metric is tagged with:\n- `hit`: One of:\n- `revision`: the cached version was validated to be up to date using its revision.\n- `project_config`: the request was handled by the cache.\n- `project_config_revision`: the request was handled by the cache and the revision did\nnot change.\n- `false`: the request will be sent to the sentry endpoint.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Counter",
    "name": "project_state.request",
    "description": "Number of project state HTTP requests.\n\nRelay updates projects in batches. Every update cycle, Relay requests\n`limits.max_concurrent_queries` batches of `cache.batch_size` projects from the upstream.\nThe duration of these requests is reported via `project_state.request.duration`.\n\nNote that after an update loop has completed, there may be more projects pending updates.\nThis is indicated by `project_state.pending`.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "project_state.request.batch_size",
    "description": "Number of project states **requested** from the upstream for each batch request.\n\nIf multiple batches are updated concurrently, this metric is reported multiple times.\n\nThe batch size can be configured with `cache.batch_size`. See `project_cache.size` for more\ndescription of the project cache.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "project_state.request.duration",
    "description": "Total time in milliseconds spent fetching queued project configuration updates requests to\nresolve.\n\nRelay updates projects in batches. Every update cycle, Relay requests\n`limits.max_concurrent_queries * cache.batch_size` projects from the upstream. This metric\nmeasures the wall clock time for all concurrent requests in this loop.\n\nNote that after an update loop has completed, there may be more projects pending updates.\nThis is indicated by `project_state.pending`.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "project_state.size_bytes.compressed",
    "description": "The size of the compressed project config in the redis cache, in bytes.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Distribution",
    "name": "project_state.size_bytes.decompressed",
    "description": "The size of the uncompressed project config in the redis cache, in bytes.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Counter",
    "name": "project_upstream.completed",
    "description": "Number of times an upstream request for a project config is completed.\n\nCompletion can be because a result was returned or because the config request was\ndropped after there still was no response after a timeout.  This metrics has tags\nfor `result` and `attempts` indicating whether it was succesful or a timeout and how\nmany attempts were made respectively.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "project_upstream.failed",
    "description": "Number of times an upstream request for a project config failed.\n\nFailure can happen, for example, when there's a network error. Refer to\n[`UpstreamRequestError`](crate::services::upstream::UpstreamRequestError) for all cases.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "redis.pool.connections",
    "description": "The number of connections currently being managed by the Redis Pool.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Gauge",
    "name": "redis.pool.idle_connections",
    "description": "The number of idle connections in the Redis Pool.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Gauge",
    "name": "redis.pool.max_connections",
    "description": "The maximum number of connections in the Redis pool.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Gauge",
    "name": "redis.pool.waiting_for_connection",
    "description": "The number of futures waiting to grab a connection.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Timer",
    "name": "replay.recording.process",
    "description": "Time in milliseconds spent on parsing, normalizing and scrubbing replay recordings.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "replay.segment_limit_exceeded",
    "description": "Incremented every time a segment exceeds the expected limit.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "requests",
    "description": "Number of HTTP requests reaching Relay.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "requests.body_read.duration",
    "description": "Timing in milliseconds to the time it takes to read an HTTP body.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "requests.duration",
    "description": "Total duration in milliseconds for handling inbound web requests until the HTTP response is\nreturned to the client.\n\nThis does **not** correspond to the full event ingestion time. Requests for events that are\nnot immediately rejected due to bad data or cached rate limits always return `200 OK`. Full\nvalidation and normalization occur asynchronously, which is reported by\n`event.processing_time`.\n\nThis metric is tagged with:\n- `method`: The HTTP method of the request.\n- `route`: Unique dashed identifier of the endpoint.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "requests.timestamp_delay",
    "description": "The delay between the timestamp stated in a payload and the receive time.\n\nSDKs cannot transmit payloads immediately in all cases. Sometimes, crashes require that\nevents are sent after restarting the application. Similarly, SDKs buffer events during\nnetwork downtimes for later transmission. This metric measures the delay between the time of\nthe event and the time it arrives in Relay. The delay is measured after clock drift\ncorrection is applied.\n\nOnly payloads with a delay of more than 1 minute are captured.\n\nThis metric is tagged with:\n\n- `category`: The data category of the payload. Can be one of: `event`, `transaction`,\n`security`, or `session`.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "responses.status_codes",
    "description": "Number of completed HTTP requests.\n\nThis metric is tagged with:\n\n- `status_code`: The HTTP status code number.\n- `method`: The HTTP method used in the request in uppercase.\n- `route`: Unique dashed identifier of the endpoint.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "runtime.alive_tasks",
    "description": "Exposes [`RuntimeMetrics::num_alive_tasks`].",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "runtime.blocking_queue_depth",
    "description": "Exposes [`RuntimeMetrics::blocking_queue_depth`].",
    "features": []
  },
  {
    "type": "Counter",
    "name": "runtime.budget_forced_yield_count",
    "description": "Exposes [`RuntimeMetrics::budget_forced_yield_count`].",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "runtime.idle_threads",
    "description": "Exposes [`RuntimeMetrics::num_idle_threads`].",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "runtime.num_blocking_threads",
    "description": "Exposes [`RuntimeMetrics::num_blocking_threads`].",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "runtime.num_idle_blocking_threads",
    "description": "Exposes [`RuntimeMetrics::num_idle_blocking_threads`].",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "runtime.num_workers",
    "description": "Exposes [`RuntimeMetrics::num_workers`].",
    "features": []
  },
  {
    "type": "Counter",
    "name": "runtime.task.spawn.created",
    "description": "Number of runtime tasks created/spawned.\n\nEvery call to [`spawn`](`crate::spawn()`) increases this counter by one.\n\nThis metric is tagged with:\n- `id`: A unique identifier for the task, derived from its location in code.\n- `file`: The source filename where the task is created.\n- `line`: The source line where the task is created within the file.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "runtime.task.spawn.terminated",
    "description": "Number of runtime tasks terminated.\n\nThis metric is tagged with:\n- `id`: A unique identifier for the task, derived from its location in code.\n- `file`: The source filename where the task is created.\n- `line`: The source line where the task is created within the file.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "runtime.worker_local_queue_depth",
    "description": "Exposes [`RuntimeMetrics::worker_local_queue_depth`].\n\nThis metric is tagged with:\n- `worker`: the worker id.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "runtime.worker_local_schedule_count",
    "description": "Exposes [`RuntimeMetrics::worker_local_schedule_count`].\n\nThis metric is tagged with:\n- `worker`: the worker id.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "runtime.worker_mean_poll_time",
    "description": "Exposes [`RuntimeMetrics::worker_mean_poll_time`].\n\nThis metric is tagged with:\n- `worker`: the worker id.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "runtime.worker_noop_count",
    "description": "Exposes [`RuntimeMetrics::worker_noop_count`].\n\nThis metric is tagged with:\n- `worker`: the worker id.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "runtime.worker_overflow_count",
    "description": "Exposes [`RuntimeMetrics::worker_overflow_count`].\n\nThis metric is tagged with:\n- `worker`: the worker id.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "runtime.worker_park_count",
    "description": "Exposes [`RuntimeMetrics::worker_park_count`].\n\nThis metric is tagged with:\n- `worker`: the worker id.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "runtime.worker_poll_count",
    "description": "Exposes [`RuntimeMetrics::worker_poll_count`].\n\nThis metric is tagged with:\n- `worker`: the worker id.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "runtime.worker_steal_count",
    "description": "Exposes [`RuntimeMetrics::worker_steal_count`].\n\nThis metric is tagged with:\n- `worker`: the worker id.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "runtime.worker_steal_operations",
    "description": "Exposes [`RuntimeMetrics::worker_steal_operations`].\n\nThis metric is tagged with:\n- `worker`: the worker id.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "runtime.worker_total_busy_duration",
    "description": "Exposes [`RuntimeMetrics::worker_total_busy_duration`].\n\nThis metric is tagged with:\n- `worker`: the worker id.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "sampling.decision",
    "description": "The number of times a sampling decision was made.\n\nThis metric is tagged with:\n- `item`: what item the decision is taken for (transaction vs span).",
    "features": []
  },
  {
    "type": "Timer",
    "name": "scrubbing.attachments.duration",
    "description": "Time spend on attachment scrubbing.\n\nThis represents the total time spent on evaluating the scrubbing rules for an\nattachment and the attachment scrubbing itself, regardless of whether any rules were\napplied.  Note that minidumps which failed to be parsed (status=\"error\" in\nscrubbing.minidumps.duration) will be scrubbed as plain attachments and count\ntowards this.\n\nThis metric is tagged with:\n\n- `attachment_type`: The type of attachment, e.g. \"minidump\".",
    "features": []
  },
  {
    "type": "Timer",
    "name": "scrubbing.minidumps.duration",
    "description": "Time spent on minidump scrubbing.\n\nThis is the total time spent on parsing and scrubbing the minidump.  Even if no PII\nscrubbing rules applied the minidump will still be parsed and the rules evaluated on\nthe parsed minidump, this duration is reported here with status of \"n/a\".\n\nThis metric is tagged with:\n\n- `status`: Scrubbing status: \"ok\" means successful scrubbed, \"error\" means there\nwas an error during scrubbing and finally \"n/a\" means scrubbing was successful\nbut no scurbbing rules applied.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "scrubbing.view_hierarchy_scrubbing.duration",
    "description": "Time spent on view hierarchy scrubbing.\n\nThis is the total time spent on parsing and scrubbing the view hierarchy json file.\n\nThis metric is tagged with:\n\n- `status`: \"ok\" means successful scrubbed, \"error\" means there was an error during\nscrubbing",
    "features": []
  },
  {
    "type": "Counter",
    "name": "server.http.accepted",
    "description": "Incremented every time the server accepts a new connection.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "server.http.connections",
    "description": "Exposes the amount of currently open and handled connections by the server.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "server.http.idle_timeout",
    "description": "Incremented every time the server aborts a connection because of an idle timeout.",
    "features": []
  },
  {
    "type": "Counter",
    "name": "server.starting",
    "description": "Number of Relay server starts.\n\nThis can be used to track unwanted restarts due to crashes or termination.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "service.back_pressure",
    "description": "A number of messages queued in a services inbound message channel.\n\nThis metric is emitted once per second for every running service. Without backlogs, this\nnumber should be close to `0`. If this number is monotonically increasing, the service is\nnot able to process the inbound message volume.\n\nThis metric is tagged with:\n- `service`: The fully qualified type name of the service implementation.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "service.utilization",
    "description": "Estimated percentage [0-100] of how busy Relay's internal services are.\n\nThis metric is tagged with:\n- `service`: the service name.\n- `instance_id`: a for the service name unique identifier for the running service",
    "features": []
  },
  {
    "type": "Timer",
    "name": "signature.create.duration",
    "description": "The time it needs to create a signature. Includes both the signature used for\ntrusted relays and for register challenges.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "store.message.duration",
    "description": "Timing in milliseconds for processing a message in the metric store service.\n\nThis metric is tagged with:\n- `message`: The type of message that was processed.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Counter",
    "name": "store.produced.span_v2",
    "description": "Number of spans produced in the new format.",
    "features": [
      "processing"
    ]
  },
  {
    "type": "Distribution",
    "name": "upstream.envelope.body_size",
    "description": "Size of queries (projectconfig queries, i.e. the request payload, not the response) sent by\nRelay over HTTP in bytes.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "upstream.metrics.body_size",
    "description": "Size of batched global metrics requests sent by Relay over HTTP in bytes.",
    "features": []
  },
  {
    "type": "Gauge",
    "name": "upstream.network_outage",
    "description": "The state of Relay with respect to the upstream connection.\nPossible values are `0` for normal operations and `1` for a network outage.",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "upstream.query.body_size",
    "description": "Size of envelopes sent over HTTP in bytes.",
    "features": []
  },
  {
    "type": "Timer",
    "name": "upstream.requests.duration",
    "description": "Total time spent to send request to upstream Relay and handle the response.\n\nThis metric is tagged with:\n\n- `result`: What happened to the request, an enumeration with the following values:\n* `success`: The request was sent and returned a success code `HTTP 2xx`\n* `response_error`: The request was sent and it returned an HTTP error.\n* `payload_failed`: The request was sent but there was an error in interpreting the response.\n* `send_failed`: Failed to send the request due to a network error.\n* `rate_limited`: The request was rate limited.\n* `invalid_json`: The response could not be parsed back into JSON.\n- `route`: The endpoint that was called on the upstream.\n- `status-code`: The status code of the request when available, otherwise \"-\".\n- `retries`: Number of retries bucket 0, 1, 2, few (3 - 10), many (more than 10).",
    "features": []
  },
  {
    "type": "Distribution",
    "name": "upstream.retries",
    "description": "Counts the number of retries for each upstream http request.\n\nThis metric is tagged with:\n\n- `result`: What happened to the request, an enumeration with the following values:\n* `success`: The request was sent and returned a success code `HTTP 2xx`\n* `response_error`: The request was sent and it returned an HTTP error.\n* `payload_failed`: The request was sent but there was an error in interpreting the response.\n* `send_failed`: Failed to send the request due to a network error.\n* `rate_limited`: The request was rate limited.\n* `invalid_json`: The response could not be parsed back into JSON.\n- `route`: The endpoint that was called on the upstream.\n- `status-code`: The status code of the request when available, otherwise \"-\".",
    "features": []
  }
]
---
title: Performance Monitoring
sidebar_order: 20
description: "Learn more about how to configure our Performance integrations to get the best experience out of it."
redirect_from:
  - /platforms/javascript/performance/apm-to-tracing/
---


```javascript {tabTitle: ESM}
// Substitude `@sentry/browser` for the integration you're using (if applicable)
import * as Sentry from "@sentry/browser";

// Pull in the additional tracing integration
import { Integrations as TracingIntegrations } from "@sentry/tracing";

Sentry.init({
  dsn: "___PUBLIC_DSN___",
  integrations: [new TracingIntegrations.BrowserTracing()],

  // Be sure to lower this in production, or use tracesSampler for finer control
  tracesSampleRate: 1.0,
});
```

```javascript {tabTitle: CDN}
Sentry.init({
  dsn: "___PUBLIC_DSN___",
  integrations: [new Sentry.Integrations.BrowserTracing()],

  // Be sure to lower this in production, or use tracesSampler for finer control
  tracesSampleRate: 1.0,
});
```







### Connecting Backend and Frontend Transactions

When instrumenting both frontend and backend with Sentry, you can connect the
`pageload` transaction on the frontend with the request transaction that rendered the page on the backend.

Once connected, the backend and frontend transactions will share the same `trace_id`, allowing you to navigate from one transaction to the other in Sentry.

In your backend code, include a `<meta>` tag in the `<head>` of the rendered HTML document as in this example:

```html
<html>
<head>
  <meta name="sentry-trace" content="{{ span.toTraceparent() }}">
  <!-- ... -->
```

The `name` attribute must be the string `"sentry-trace"` and the `content` attribute must be generated by your backend's Sentry SDK using `span.toTraceparent()` (or equivalent, depending on the backend platform).

The `span` reference is either the transaction that rendered the page or any of its child spans. It defines the parent of the `pageload` transaction.

For the correct association of transactions in a trace, make sure your backend will render a new and unique value for the `content` attribute for every request. Reusing the same value will cause unrelated traces to incorrectly share the same `trace_id`.

<Alert level="info" title="Note"><markdown>

JavaScript code running on a browser cannot read the response headers of the current page. Therefore, the `<meta>` tag is used to propagate tracing metadata from the backend instead of the `sentry-trace` HTTP header described earlier.

</markdown></Alert>


## Retrieving an Active Transaction

In cases where you want to attach Spans to an already ongoing transaction you can use `Sentry.getCurrentHub().getScope().getTransaction()`. This function will return a `Transaction` object when there is a running transaction on the scope, otherwise it returns `undefined`. If you are using our BrowserTracing integration, by default we attach the transaction to the Scope, so you could do something like this:

```javascript
function myJsFunction() {
  const transaction = Sentry.getCurrentHub()
    .getScope()
    .getTransaction();
  if (transaction) {
    let span = transaction.startChild({
      op: "encode",
      description: "parseAvatarImages",
    });
    // Do something
    span.finish();
  }
}
```

## Adding Query Information and Parameters to Spans

Currently, every tag has a maximum character limit of 200 characters. Tags over the 200 character limit will become truncated, losing potentially important information. To retain this data, you can split data over several tags instead.

For example, a 200+ character tagged request:

`https://empowerplant.io/api/0/projects/ep/setup_form/?user_id=314159265358979323846264338327&tracking_id=EasyAsABC123OrSimpleAsDoReMi&product_name=PlantToHumanTranslator&product_id=161803398874989484820458683436563811772030917980576`

The 200+ character request above will become truncated to:

`https://empowerplant.io/api/0/projects/ep/setup_form/?user_id=314159265358979323846264338327&tracking_id=EasyAsABC123OrSimpleAsDoReMi&product_name=PlantToHumanTranslator&product_id=1618033988749894848`

Instead, using `span.set_tag` and `span.set_data` preserves the details of this query using structured metadata. This could be done over `baseUrl`, `endpoint`, and `parameters`:

```javascript
const baseUrl = "https://empowerplant.io";
const endpoint = "/api/0/projects/ep/setup_form";
const parameters = {
  user_id: 314159265358979323846264338327,
  tracking_id: "EasyAsABC123OrSimpleAsDoReMi",
  product_name: PlantToHumanTranslator,
  product_id: 161803398874989484820458683436563811772030917980576,
};

const span = transaction.startChild({
  op: "request",
  description: "setup form",
});

span.setTag("baseUrl", baseUrl);
span.setTag("endpoint", endpoint);
span.setData("parameters", parameters);
// you may also find some parameters to be valuable as tags
span.setData("user_id", parameters.user_id);
http.get(`${base_url}/${endpoint}/`, (data = parameters));
```

## Grouping Transactions

When Sentry captures transactions, they are assigned a transaction name. This name is generally auto-generated by the Sentry SDK based on the framework integrations you are using. If you can't leverage the automatic transaction generation (or want to customize how transaction names are generated) you can use a global event processor that is registered when you initialize the SDK with your configuration.

An example of doing this in a node.js application:

```javascript
import { addGlobalEventProcessor } from "@sentry/node";

addGlobalEventProcess(event => {
  // if event is a transaction event
  if (event.type === "transaction") {
    event.transaction = sanitizeTransactionName(event.transaction);
  }
  return event;
});
```

For browser JavaScript applications using the `BrowserTracing` integration, the `beforeNavigate` option can be used to better group `navigation`/`pageload` transactions together based on URL.

```javascript
import * as Sentry from "@sentry/browser";
import { Integrations } from "@sentry/tracing";

Sentry.init({
  // ...
  integrations: [
    new Integrations.BrowserTracing({
      beforeNavigate: context => {
        return {
          ...context,
          // You could use your UI's routing library to find the matching
          // route template here. We don't have one right now, so do some basic
          // parameter replacements.
          name: location.pathname
            .replace(/\d+/g, "<digits>")
            .replace(/[a-f0-9]{32}/g, "<hash>"),
        };
      },
    }),
  ],
});
```

---
title: Automatic Instrumentation
sidebar_order: 20
description: "Learn what transactions are captured after tracing is enabled."
redirect_from:
  - /performance/included-instrumentation
---

<Note>

Capturing transactions requires that you first <PlatformLink to="/performance/">set up performance monitoring</PlatformLink> if you haven't already. You'll also need to enable the <PlatformLink to="/">base Sentry integration for ASP.NET Core</PlatformLink>.

</Note>

### Server Integration

ASP.NET Core integration, once enabled, captures each incoming HTTP request and turns it into a transaction with the help of a custom middleware. To enable tracing on ASP.NET Core, you need to update your pipeline configuration to include a call to `UseSentryTracing()`:

```csharp
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Sentry.AspNetCore;

public class Startup
{
    /* ... */

    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
    {
        if (env.IsDevelopment())
        {
            app.UseDeveloperExceptionPage();
        }
        else
        {
            app.UseExceptionHandler("/Home/Error");
            app.UseHsts();
        }

        app.UseHttpsRedirection();
        app.UseStaticFiles();

        app.UseRouting();

        // Enable automatic tracing integration.
        // Make sure to put this middleware right after `UseRouting()`.
        app.UseSentryTracing();

        app.UseAuthorization();

        app.UseEndpoints(endpoints =>
        {
            endpoints.MapControllerRoute(
                name: "default",
                pattern: "{controller=Home}/{action=Index}/{id?}");
        });
    }
}
```

Transaction names follow the pattern `<HTTP method> <Route>`; for example, a request to the following action will create a transaction named `GET /person/{id}`:

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;

public class HomeController : Controller
{
    [HttpGet("/person/{id}")]
    public IActionResult Person(string id) { /* ... */ }
}
```

Transactions created by this integration are automatically added to the current scope. If you want to start your own spans from the automatically created transaction, you can use the following approach:

```csharp
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using Sentry;

public class HomeController : Controller
{
    private readonly IHub _sentryHub;

    public HomeController(IHub sentryHub) => _sentryHub = sentryHub;

    [HttpGet("/person/{id}")]
    public IActionResult Person(string id)
    {
        var childSpan = _sentryHub.GetSpan()?.StartChild("additional-work");
        try
        {
            // Do the work that gets measured.

            childSpan?.Finish(SpanStatus.Ok);
        }
        catch (Exception e)
        {
            childSpan?.Finish(SpanStatus.InternalError);
            throw;
        }
    }
}
```

### HTTP Client Integration

Sentry also provides a custom filter for HTTP client factory commonly used in ASP.NET Core applications. This filter adds an additional message handler that automatically injects Sentry's trace header and tracks outgoing HTTP requests in separate spans attached to the current transaction.

To enable this integration, you need to have HTTP client factory enabled within your application:

```csharp
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.DependencyInjection;

public class Startup
{
    public void ConfigureServices(IServiceCollection services)
    {
        /* ... */

        services.AddRouting();

        // This is required for HTTP client integration
        services.AddHttpClient();
    }
}
```

If you already have `AddHttpClient()` in your service collection (which is likely the case), then no action is required.

### Entity Framework Core Integration

![Sample transaction  with Entity Framework Core Integration.](EFCore_integration.png)

Since version 3.9.0, the ASP.NET Core SDK will automatically create spans for EF Core queries for the following operations:
* Query compiling: Occurs when EF Core optimizes a query, it then caches it so that future queries with the same input get reused.
The parameters for this span are:
** Operation: db.query_compiler
** Description: the query to be compiled.

* Database connection: Represents the lifecycle of a database connection, one connection may contain one or more query execution spans, and, in some circumstances, may not be registered, due to the nature of EF Core event model.
The parameters for this span are:
** Operation: db.connection
* Query Execution: Happens during the execution of a query, it represents how long a query took to be executed
The parameters for this span are:
** Operation: db.query
** Description: The query to be executed.

### SQLClient Integration.

![Sample transaction  with SQLClient Integration.](SQLClient_integration.png)

Since version 3.9.0, the ASP.NET Core SDK will automatically create spans for SQLClient operations, the integrated operations are described below:

* Database connection: Represents the lifecycle of a database connection, one connection may contain one or more query execution spans.
The parameters for this span are:
** Operation: db.connection
** db.connection_id: the Connection ID from this connection.
** db.operation_id: the Operation ID from this connection.
** rows_sent: The number of rows sent during the connection.
** bytes_received: The amount of data (in bytes) received during the connection.
** bytes_sent: The amount of data (in bytes) sent during the connection.
* Query Execution: Happens during the execution of a query, it represents how long a query took to be executed
The parameters for this span are:
** Operation: db.query
** Description: The query to be executed.
** db.operation_id: the Operation ID from this connection.

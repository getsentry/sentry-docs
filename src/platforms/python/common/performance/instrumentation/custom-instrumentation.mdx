---
title: Custom Instrumentation
sidebar_order: 20
description: "Learn how to capture performance data on any action in your app."
---

The Sentry SDK for Python does a very good job at auto instrumenting your application. If you use one of the popular frameworks we already got you covered. Everything is instrumented out of the box. (The Sentry SDK will check your installed Python packages and will auto enable the matching SDK integrations.)

## Add a Transaction

To instrument certain regions of your code, you can create transactions to capture them.

<Note>

If you are using one of the Sentry SDK integrations, those integrations will create transactions for you!

</Note>

The following example creates a transaction for an expensive operation (for example, `eat_pizza`), and sends the result to Sentry:

```python
import sentry_sdk

def eat_slice(slice):
    ...

def eat_pizza(pizza):
    with sentry_sdk.start_transaction(op="task", name="Eat Pizza"):
        while pizza.slices > 0:
            eat_slice(pizza.slices.pop())
```

## Add Spans to a Transaction

If you want to have more fine grained performance monitoring, you can add so called child spans to your transaction. You can do so in multiple ways:

- Using a context manager or
- Using a decorator (works on sync and `async` functions.)

Calling `sentry_sdk.start_span()` will find the current active transaction, and attach the span to it.

```python {tabTitle:Context Manager}
import sentry_sdk

def eat_slice(slice):
    ...

def eat_pizza(pizza):
    with sentry_sdk.start_transaction(op="task", name="Eat Pizza"):
        while pizza.slices > 0:
            with sentry_sdk.start_span(description="Eat Slice"):
                eat_slice(pizza.slices.pop())

```

```python {tabTitle:Decorator}
import sentry_sdk

@sentry_sdk.trace
def eat_slice(slice):
    ...

def eat_pizza(pizza):
    with sentry_sdk.start_transaction(op="task", name="Eat Pizza"):
        while pizza.slices > 0:
            eat_slice(pizza.slices.pop())

```

## Nested Spans

Spans can be nested to form a span tree. (You can read more about that in the [distributed tracing](/product/sentry-basics/tracing/distributed-tracing/) documentation.)

```python {tabTitle:Context Manager}
import sentry_sdk

def chew():
    ...

def swallow():
    ...

def eat_slice(slice):
    with sentry_sdk.start_span(description="Eat Slice"):
        with sentry_sdk.start_span(description="Chew"):
            chew()
        with sentry_sdk.start_span(description="Swallow"):
            swallow()

```

```python {tabTitle:Decorator}
import sentry_sdk

@sentry_sdk.trace
def chew():
    ...

@sentry_sdk.trace
def swallow():
    ...

@sentry_sdk.trace
def eat_slice(slice):
    chew()
    swallow()
```

## Accessing the Current Transaction

In cases where you want to change data in an already ongoing Transaction you can use `Hub.current.scope.transaction`. This property will return a Transaction in case there is a running Transaction otherwise it returns `None`.

```python
import sentry_sdk

def eat_pizza(pizza):
    transaction = sentry_sdk.Hub.current.scope.transaction

    if transaction is not None:
        transaction.set_tag("num_of_slices", len(pizza.slices))

    while pizza.slices > 0:
        eat_slice(pizza.slices.pop())
```

## Accessing the Current Span

In cases where you want to change data in the current Span you can use `sentry_sdk.Hub.current.scope.span`. This property will return a Span in case there is a running Span otherwise it returns `None`.

In this example we will set a tag in the Span created by the `@sentry_sdk.trace` decorator.

```python
import sentry_sdk

@sentry_sdk.trace
def eat_slice(slice):
    span = sentry_sdk.Hub.current.scope.span

    if span is None:
        span.set_tag("slice_id", slice.id)

    ...
```

---
title: Custom Instrumentation
sidebar_order: 20
supported:
  - javascript
  - javascript.cordova
  - react-native
  - dotnet
  - python
  - go
  - java
  - android
  - ruby
  - java.spring-boot
  - apple
  - unity
description: "Learn how to capture performance data on any action in your app."
redirect_from:
  - /performance/custom-instrumentation
---

<Note>

To capture transactions customized to your organization's needs, you must first <PlatformLink to="/performance/">set up performance monitoring.</PlatformLink>

</Note>

To instrument certain regions of your code, you can create transactions to capture them.

<PlatformContent includePath="performance/enable-manual-instrumentation" />

<PlatformContent includePath="performance/add-spans-example" />

<PlatformSection supported={["java"]}>

<PlatformContent includePath="performance/create-transaction-bound-to-scope" />

</PlatformSection>

<PlatformSection notSupported={["java"]}>

<PlatformContent includePath="performance/retrieve-transaction" />

</PlatformSection>

<PlatformSection supported={["java"]}>

<PlatformContent includePath="performance/connect-errors-spans" />

</PlatformSection>

<PlatformSection supported={["java", "dotnet"]}>

## Distributed Tracing

Traces can bridge across multiple software services. Each span in a trace can be represented as a `sentry-trace` header, containing the trace id, span id, and sampling details. This `sentry-trace` header can be passed to downstream services so that they can create spans that are a continuation of the trace started in the originating service.

<PlatformContent includePath="performance/distributed-tracing" />

</PlatformSection>

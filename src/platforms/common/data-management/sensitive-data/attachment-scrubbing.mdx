---
title: "Attachment Scrubbing"
sidebar_order: 4
keywords: ["pii", "gdpr", "personally identifiable data", "compliance", "minidump"]
---


Events can include attachments. In some cases, attachments may contain PII. [Minidumps](/platforms/native/guides/minidumps) are a common attachment type for native crash reports, and minidumps may contain PII in various sections of the file.

## Data scrubbing methods in attachments

When scrubbing attachments, and especially minidumps, it is often important to be able to do this without destroying the original file format.
This is done by understanding enough of the file format and using custom selectors which will try and only let you modify certain parts of the file, [see below](#source-selectors) for more information on the source selectors.

When modifying data in the file, Sentry cannot modify the length of the file. This has implications for how the [Methods](../advanced-datascrubbing/#methods) behave:

- Any modification that results in replacement text **longer** than the original will be **truncated**.
- Any modification that results in replacement text **shorter** than the original will be **padded** using `x` as the padding character.

Here is how this works specifically for each method:

- *Remove*: As the entire field is removed, it is essentially replaced with the padding character.
- *Mask*: This behaves as normal, all data is replaced with `*` masking character.
- *Hash*: Hashing happens as usual, however the **binary representation** of the match is hashed, regardless of the encoding in which the match was made.  The resulting hash is padded or truncated as described above.
- *Replace*: This behaves like normal, with the replacement being padded or truncated as described above.

## Source selectors

All attachments can be selected using the `$attachments` [Value Type](../advanced-datascrubbing/#value-types) selector at the root of the selector, followed by the specific filename.
The filename must be in quotes to write a specific filename, but wildcards can also be used.

For example, for the filename `minidump.dmp`, you can select all fields to be scrubbed using `$attachments.'minidump.dmp'.**`. To write the same using a wildcard to select all attachments, you would write `$attachmetns.*.**` or even simply `$attachments.**`.

### Minidump selectors

A minidump is always an attachment, but it also has its own [value type](../advanced-datascrubbing/#value-types) of `$minidump`, which allows you to select all fields that can be scrubbed in a minidump using `$minidump.**`.
This really is a shorthand for selecting the fields of all attachments that are minidumps: `$attachments.$minidump.**`.

Our examples thus far have repeatedly referred to all fields in a minidump that can be scrubbed.
For the purpose of PII scrubbing, we currently represent the minidump as a flat structure with the following fields:

- The **stack memory**: These are memory regions in the minidump which are used as stack memory by a thread.
  The [value type](../advanced-datascrubbing/#value-types) selector `$stack_memory` can be used to select these regions.
  Generally they will contain binary data so be careful with the [data types](../advanced-datascrubbing/#data-types) used to scrub these regions.

  In particular for stack memory it is **not recommended** to be scrubbed, since this is used by the event processing pipeline to unwind the stack and build a readable stack trace for the event.
  Inadvertedly modifying the stack in an undesired way will make this process impossible and the event much less useful.

  In general all [data types](../advanced-datascrubbing/#data-types) result in a textual regular expression match on some data, for the stack this regular expression is matched as a binary UTF-8 regular expression so that any UTF-8 embedded in the binary data will be matched.
  Additionally the regular expression is applied to any valid UTF-16LE strings found within the binary data.

- The **heap memory**: For the current implementation this is considered to be any memory region which is not used as stack memory.
  This means it could include other non-stack regions like `mmap`ed files.  All these memory regions can be selected using the `$heap_memory` [value type](../advanced-datascrubbing/#value-types) selector.

  Since the heap memory is not used in the event processing pipeline it is much safer to modify these memory regions.

  Like for stack memory all [data types](../advanced-datascrubbing/#data-types) are matched as a binary UTF-8 regular expression as well as in any valid UTF-16LE strings found within the binary memory region.

- A minidump also contains a list of **code modules** which were loaded at the time the minidump was created.
  This module list contains information about each module, including two fields which could contain file paths: the path of the code file and the path of the associated debug file.

  As these fields are pathnames they could contain a user's home directory, so it makes sense to apply the *Usernames in filepaths* [data type](../advanced-datascrubbing/#data-types) to these fields.  The fields can be selected individually by their respective field names:

  - `code_file`
  - `debug_file`

  Both fields have a [value type](../advanced-datascrubbing/#value-types) of `$string`.
  Any modification will exclude the basename of the pathnames to ensure the event processing pipeline can still operate correctly on the minidump.

  An example of a rule to scrub these fields would be displayed by the UI like this:

  ```
  [Remove] [Usernames in filepaths] from [$minidump.code_file || $minidump.debug_file]
  ```

- Linux minidumps can contain the process's **command line** and **environment variables**, these are included as copies of the files in `/proc/$pid/cmdline` and `/proc/$pid/environ`.
  As they are direct copies of these files, they have this file format: NULL-separated records of `argv` arguments or `VAR=val` pairs respectively.

  To select these you can currently only use their [value types](../advanced-datascrubbing/#value-types): `$binary`.
  This works because they are currently the only fields in the minidump with a binary value type.

  An example of how the UI would display a rule to scrub the home directory from the `$HOME` env var would be:

  ```
  [Remove] [HOME=[^\u0000+]\u0000] from [$minidump.$binary]
  ```

  Note the syntax to denote a string delimited by NULL in the regular expression: any sequence of characters not containing NULL, but ending in NULL.
  Here NULL itself is represented by its unicode codepoint: `\u0000`.

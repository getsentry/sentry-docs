---
title: Distributed Tracing
sidebar_order: 40
description: "Learn how to connect backend and frontend transactions."
---

## What is distributed tracing?

Applications can consist of multiple components, which are also called services. A web application for example can consist of a frontend, a backend and a microservice. A mobile app can alike constist of the mobile app running on the device and a backend and a microserivce.

When a user triggeres an action in the frontend/app it will call the backend which on its part calls the microservice.
So the users action leaves a trace through three services.

Adding a unique trace ID to the users actions and passing it on from the frontend/app to the backend and further on to the microservice is called distributed tracing.

This way all the information that is collect on the frontend, the backend and the microservice is associated with one unique trace. Which makes it possible to relate information that was collected on the frontend with information collected in the backend or microservice

You could for example see what UI element was clicked on the frontend that lead to an error in the microservice. This gives you the complete picture of what was happing in your application as a whole, not just what was happening in one service.

## How does distributed tracing work in Sentry?

The Sentry SDKs can inject tracing information into outgoing requests and can also extract tracing information from incoming requests.

![Trace propagation in Sentry SDK](distributed-tracing-trace-propagation.png)

There are two headers that are used to propagate tracing information:

- `sentry-trace`
- `baggage`

For distributed tracing to work make sure that those headers are not blocked or stripped by your proxy servers or firefwalls.

## Configure

TODO: header beschreiben
TODO: beispiel header anzeigen

Config f√ºrs limitieren auf gewisse hosts
`trace-propagation-targets`

### Supported frameworks

In the following frameworks distributed tracing works out of the box:

- [Django](/platforms/python/guides/django/distributed-tracing/instrumentation/automatic-instrumentation/)
- [FastAPI](/platforms/python/guides/fastapi/distributed-tracing/instrumentation/automatic-instrumentation/)
- [Flask](/platforms/python/guides/flask/distributed-tracing/instrumentation/automatic-instrumentation/)
- [Bottle](/platforms/python/guides/bottle/distributed-tracing/instrumentation/automatic-instrumentation/)
- [Falcon](/platforms/python/guides/falcon/distributed-tracing/instrumentation/automatic-instrumentation/)
- [Pyramid](/platforms/python/guides/pyramid/distributed-tracing/instrumentation/automatic-instrumentation/)
- [Quart](/platforms/python/guides/quart/distributed-tracing/instrumentation/automatic-instrumentation/)
- [Starlette](/platforms/python/guides/starlette/distributed-tracing/instrumentation/automatic-instrumentation/)
- [Starlite](/platforms/python/guides/starlite/distributed-tracing/instrumentation/automatic-instrumentation/)
- [Tornado](/platforms/python/guides/tornado/distributed-tracing/instrumentation/automatic-instrumentation/)

<!--
TODO: Check these if there is really auto instrumentation:
- AWS Lambda
- GCP
- Trytond
- Celery
- rq
 -->

If you have a vanilla Python project or use a (yet) unsupported framework you need to implement <PlatformLink to="/distributed-tracing/instrumentation/custom-instrumentation/">Custom Instrumentation</PlatformLink>.

## Setup Your Other Services

-> Link to list of supported frameworks/guides or to frameworks/guides with performance enabled.

## Verify

Screenshots wie es aussehen soll und wo man in Sentry.io es sich ansehen kann.

Von Instrumentationssue auf Trace

Von Replay auf Trace

## Temp

Ab welcher Version ist es supported?

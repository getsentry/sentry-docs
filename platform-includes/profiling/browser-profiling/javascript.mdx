<Alert>

Browser Profiling is currently in beta. Beta features are still in progress and may have bugs. We recognize the irony.

</Alert>

The browser profiling integration is built using the [JS Self-Profiling API](https://wicg.github.io/js-self-profiling/) and will likely only move out of beta once the specification progresses and gains adoption. See [platform status](https://chromestatus.com/feature/5170190448852992).

Note that since the profiling API is currently only exposed in Chromium, profiles collected only include that demographic. We hope that as the API gains adoption, other browsers will implement it as well.

<PlatformContent includePath="profiling/index/why-profiling" />

## Prerequisites

To get started with JavaScript browser profiling, you'll need to:

<PlatformSection notSupported={["javascript.electron"]}>

- Install the <PlatformSdkPackageName fallback="@sentry/browser"/> SDK, minimum version `10.27.0` (UI Profiling) or `7.60.0` (deprecated transaction-based Profiling)

</PlatformSection>

<PlatformSection supported={["javascript.electron"]}>

- Install the <PlatformSdkPackageName fallback="@sentry/electron"/> SDK, minimum version `7.4.0` (UI Profiling) or `4.16.0` (deprecated transaction-based Profiling)

</PlatformSection>

- Configure the document response header to include `Document-Policy: js-profiling`
- Configure the SDK to use the `browserProfilingIntegration` and set `profileSessionSampleRate` (UI Profiling) or `profilesSampleRate` (deprecated transaction-based Profiling)

## Step 1: Install the <PlatformOrGuideName/> SDK

Install our <PlatformOrGuideName/> SDK using either `npm`, `yarn`, or `pnpm`.

<PlatformContent includePath="profiling/automatic-instrumentation-intro" />

## Step 2: Add Document-Policy: js-profiling header

For the JavaScript browser profiler to start, the document response header needs to include a `Document-Policy` header key with the `js-profiling` value.

<PlatformContent includePath="profiling/automatic-instrumentation-headers" />

## Step 3: Configure the <PlatformOrGuideName/> SDK

Configuration should happen as early as possible in your application's lifecycle. Once this is done, Sentry's JavaScript SDK will capture all unhandled exceptions and transactions.

<PlatformContent includePath="profiling/automatic-instrumentation-setup" />

<Alert level="warning" title="Local Profiling with Chrome DevTools">

When you enable `browserProfilingIntegration` in your SDK configuration, Chrome will incorrectly attribute regular rendering work as “Profiling Overhead” if you are doing local profiling via the Chrome DevTools Performance panel. To avoid this, disable or remove the integration when profiling with Chrome DevTools.

</Alert>

## Profiling Modes

Profiling supports two modes: `manual` and `trace`. These modes are mutually exclusive and cannot be used at the same time.

In `manual` mode, you can manage the profiling data collection via calls to `Sentry.uiProfiler.startProfiler` and `Sentry.uiProfiler.stopProfiler`. You have full control over when the profiler runs.

In `trace` mode, the profiler manages its own start and stop calls based on spans. It continues to run while at least one span is active, and stops when there are no active spans.

### Manual Lifecycle Profiling

Manual lifecycle profiling is the default mode and enables you to start and stop the profiler manually.

After enabling the `browserProfilingIntegration` and setting a `profileSessionSampleRate`, you can start and stop the profiler with the following calls:

```javascript {9}
// All spans (unless those discarded by sampling) will have profiling data attached to them.
Sentry.uiProfiler.startProfiler();
// Code executed between these two calls will be profiled
Sentry.uiProfiler.stopProfiler();
```

### Trace Lifecycle Profiling

To enable trace lifecycle profiling, <PlatformLink to="/tracing">enable tracing</PlatformLink> and set `profileLifecycle` to `'trace'` in your SDK configuration.

```javascript {9}
Sentry.init({
  dsn: "___PUBLIC_DSN___",
  integrations: [
    Sentry.browserTracingIntegration(), // Enables tracing
    Sentry.browserProfilingIntegration(),
  ],
  tracesSampleRate: 1.0, // Enables tracing
  profileSessionSampleRate: 1.0,
  profileLifecycle: "trace",
});
```

## The Difference Between DevTools & Sentry's JavaScript Browser Profiler

What does Sentry's JavaScript browser profile offer that Chrome DevTools does not?

- Sentry's JavaScript profiler runs in production and captures real user data, showing real-world performance. DevTools runs locally and only shows profiles of what's running on your machine.
- Sentry runs at a lower sampling rate of 100Hz with a 10ms sample period versus a sampling rate of 1000Hz and a 1ms sample period for DevTools.
- Sentry supports deobfuscation, making it so that all the function names in your code are correct. Typically, when you run JavaScript code, it's minified, meaning that all the function names are replaced with machine-generated abbreviations.

Please note, that since the browser profiling API is currently only implemented in Chromium-based browsers, the profiles collected with Sentry's JavaScript browser profiling will inherently be biased toward that demographic. This is something that you'll need to consider if you're basing your decisions on the data collected.

We hope that as the JavaScript browser profiling API gains adoption, other browsers will implement it as well. If you find the browser profiling feature helpful and would like to see it gain further adoption, please consider supporting the spec at the official WICG repository.

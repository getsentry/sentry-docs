Remix SDK attaches `sentry-trace` and `baggage` values from your `root` loader. You need to use the [`meta`](https://remix.run/docs/en/v1/api/conventions#meta) function to attach the data from your `loader` as `<meta>` tags. The following code snippet shows how to do this:

```typescript {tabTitle: Remix v1} {filename: root.tsx}
export const meta: MetaFunction = ({ data }) => {
  return {
    // ...
    "sentry-trace": data.sentryTrace,
    baggage: data.sentryBaggage,
  };
};
```

```typescript {tabTitle: Remix v2} {filename: root.tsx}
// Sentry provides a type for Remix v2 MetaFunction parameters
// so you can access `data.sentryTrace` and `data.sentryBaggage` alongside other data from loader.
import type { SentryMetaArgs } from "@sentry/remix";

export const meta = ({ data }: SentryMetaArgs<MetaFunction<typeof loader>>) => {
  return [
    {
      name: "sentry-trace",
      content: data.sentryTrace,
    },
    {
      name: "baggage",
      content: data.sentryBaggage,
    },
  ];
};
```

The `name` attributes must be the strings `"sentry-trace"` and `"baggage"` and the `content` attributes must be generated by your backend Sentry SDK. For `sentry-trace`, use `span.toSentryTrace()` (or equivalent, depending on the backend platform). This guarantees that a new and unique value will be generated for each request. For `baggage`, use `serializeBaggage(span.getBaggage())`.

To get around possible [Browser CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) issues, you should define `tracePropagationTargets` on the client side. See <PlatformLink to="/tracing/trace-propagation/dealing-with-cors-issues/">Dealing with CORS Issues</PlatformLink> for more information.

<Alert>

Note: port numbers are relevant for trace propagation and the origin. You may need to configure the `tracePropagationTargets` to ensure that traces are propagated across your services if they run on different ports.

For example, if you have a Node.js backend running locally on port 3000, that destination (`http://localhost:3000`) should be added to the `tracePropagationTargets` array on your frontend to ensure that CORS doesn't restrict the propagation of traces.

</Alert>

```javascript
// entry.client.tsx
Sentry.init({
  dsn: "___PUBLIC_DSN___",
  integrations: [Sentry.browserTracingIntegration()],
  // Capture 100% of spans. This is useful for development and debugging. Consider reducing in production or using traceSampler
  tracesSampleRate: 1.0,
  tracePropagationTargets: ["https://myproject.org", /^\/api\//],
});
```

If you're using version `7.57.x` or below, you'll need to have our <PlatformLink to="/tracing/">tracing feature enabled</PlatformLink> in order for distributed tracing to work.

#### Example 1: Microservices E-commerce Platform

```javascript
// entry.client.tsx
Sentry.init({
  dsn: "___PUBLIC_DSN___",
  integrations: [Sentry.browserTracingIntegration()],
  // Capture 100% of spans. This is useful for development and debugging. Consider reducing in production or using traceSampler
  tracesSampleRate: 1.0,
  tracePropagationTargets: [
    "https://api.myecommerce.com",
    "https://auth.myecommerce.com",
  ],
});
```

This tells Sentry to pass trace headers across the following paths:

* Your main API server (where product data comes from)
* Your authentication server (where logins happen)

This way, if a customer experiences an error during checkout, or you want to check the performance of a specific endpoint, you can see the complete path their request took across these different services.

#### Example 2: Mobile App with Backend Services

```javascript
// entry.client.tsx
Sentry.init({
  dsn: "___PUBLIC_DSN___",
  integrations: [Sentry.browserTracingIntegration()],
  tracePropagationTargets: [
    "https://api.myapp.com",
    "https://media.myapp.com",
    /^\/local-api\//
  ],
});
```

This configuration lets your app track user actions across:

* Your main API server (handles most app functions)
* Your media server (handles images, videos, etc.)
* Any local API endpoints in your app

If your app crashes while a user is uploading a photo, you can trace exactly where the problem occurred - in the app itself, the main API, or the media service.

### Strict Trace Continuation

_Available since SDK version 10_

When your application receives requests, they might include `sentry-trace` and `baggage` headers from an upstream service that is also using Sentry.
By default, the SDK will continue the trace from the incoming headers. This can be undesirable if the requests are from a third-party service,
as it can lead to unwanted traces, increased billing, and skewed performance data.

To prevent this, you can enable `strictTraceContinuation`. When this option is set to `true`, the SDK checks the incoming request for Sentry trace information.
It only continues the trace if it belongs to the same Sentry organization. Otherwise, it starts a new trace.
This is useful if your application is a public API or receives requests from services outside your organization.

```javascript {5}
Sentry.init({
  dsn: "___PUBLIC_DSN___",
  tracesSampleRate: 1.0,
  // Ensure that only traces from your own organization are continued
  strictTraceContinuation: true,
});
```

The SDK automatically parses the organization ID from your DSN. If you use a DSN format that doesn't include the organization ID (number followed by the letter `"o"`), or if you need to override it, you can provide it manually using the `orgId` option:

```javascript {6}
Sentry.init({
  dsn: "___PUBLIC_DSN___",
  tracesSampleRate: 1.0,
  strictTraceContinuation: true,
  // Manually provide your organization ID (overrides organization ID parsed from DSN)
  orgId: 12345,
});
```

### Disabling Distributed Tracing

If you want to disable distributed tracing and ensure no Sentry trace headers are sent, you can configure your SDK like this:

```javascript
Sentry.init({
  dsn: "___PUBLIC_DSN___",

  // Overwrite the defaults to ensure no trace headers are sent
  tracePropagationTargets: [],
});
```

On this page you will learn how to manually propagate trace information into and out of your Unity application. Please note, that you do not need to do this manually if you have our <PlatformLink to="/tracing/">tracing feature</PlatformLink> turned on.

To set it up manually, all you have to do is to make sure your application extracts incoming headers and to set those headers again when making an outgoing request within your application.

## Step 1) Extract Incoming Tracing Information

Incoming tracing information has to be extracted and stored in memory for later use. Sentry provides the `ContinueTrace()` function to help you with this. Tracing information can come from incoming headers, for example, by another Sentry SDK used in your backend service.

Here's an example using Unity's `UnityWebRequest` to extract and store incoming tracing information using `ContinueTrace()`:

```csharp
using System.Collections;
using UnityEngine;
using UnityEngine.Networking;

public class TraceReceiver : MonoBehaviour
{
    IEnumerator MakeRequest()
    {
        using (UnityWebRequest www = UnityWebRequest.Get("https://example.com/api/data"))
        {
            yield return www.SendWebRequest();

            if (www.result == UnityWebRequest.Result.Success)
            {
                // Extract headers from the incoming response
                var responseHeaders = www.GetResponseHeaders();
                if (responseHeaders != null)
                {
                    var sentryTraceHeader = string.Empty;
                    var sentryBaggageHeader = string.Empty;

                    if (responseHeaders.TryGetValue("sentry-trace", out var traceHeader))
                    {
                        sentryTraceHeader = traceHeader;
                    }

                    if (responseHeaders.TryGetValue("baggage", out var baggageHeader))
                    {
                        sentryBaggageHeader = baggageHeader;
                    }

                    // Continue the trace from the backend service
                    var transactionContext = SentrySdk.ContinueTrace(sentryTraceHeader, sentryBaggageHeader);
                    var transaction = SentrySdk.StartTransaction(transactionContext);

                    // Process your data here...

                    transaction.Finish();
                }
            }
        }
    }
}
```

If you pass these headers to Sentry's `ContinueTrace()` function it will store them in memory for later use.

## Step 2) Inject Tracing Information to Outgoing Requests

For distributed tracing to work, the two headers `sentry-trace` and `baggage`, must now also be added to outgoing requests.

If you send outgoing HTTP requests with an HTTP client that uses `SentryHttpMessageHandler`, this tracing information is automatically added to outgoing requests. You do not have to enable Performance for distributed tracing to work.

If you're not using the `SentryHttpMessageHandler`, you can generate this tracing information with the Sentry SDK's `GetTraceHeader()` and `GetBaggage()` functions. Here's an example using Unity's `UnityWebRequest`:

```csharp
using System.Collections;
using UnityEngine;
using UnityEngine.Networking;

public class TraceSender : MonoBehaviour
{
    IEnumerator SendRequest()
    {
        using (UnityWebRequest www = UnityWebRequest.Post("https://example.com/api/action", "{}"))
        {
            // Add Sentry trace headers to propagate the trace
            var traceHeader = SentrySdk.GetTraceHeader();
            if (traceHeader != null)
            {
                www.SetRequestHeader("sentry-trace", traceHeader.ToString());
            }

            var baggageHeader = SentrySdk.GetBaggage();
            if (baggageHeader != null)
            {
                www.SetRequestHeader("baggage", baggageHeader.ToString());
            }

            // Set content type for the request
            www.SetRequestHeader("Content-Type", "application/json");

            yield return www.SendWebRequest();

            if (www.result == UnityWebRequest.Result.Success)
            {
                Debug.Log("Request sent with trace headers");
            }
        }
    }
}
```

This way, tracing information is propagated to the project receiving the message. If this project uses the Sentry .NET SDK, it will extract and save the tracing information for later use.

The two services are now connected with your custom distributed tracing implementation.

## Verification

If you make outgoing requests from your project to other services, check if the headers `sentry-trace` and `baggage` are present in the request. If so, distributed tracing is working.
